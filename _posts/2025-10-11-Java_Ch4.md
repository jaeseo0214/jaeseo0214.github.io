---
layout: single
title: "Java Chapter 4 – 배열"
date: 2025-10-11
categories:
  - Java
  - java_grammer
tags: [Java, 문법]  
author_profile: true
read_time: true
comments: true
share: true
related: true
sidebar:
  nav: "categories_sidebar"
---


# Java 배열


프로그래밍을 하다 보면 하나의 데이터 타입을 여러 개 다루고 싶을 때가 있다.<br>
예를 들어 학생 10명의 수학 점수를 변수에 저장하고 싶을때,<br>


```java
int num1;
int num2;
int num3;
    :
    :
    :
int num10;
```

이런 식으로 작성하면 코드가 깔끔하지 못할뿐더러,<br>
관리 효율이 극도로 떨어지게 된다.<br>


그래서 사용하는 것이 '배열'이다.<br>
배열은 인덱스와 그에 대응하는 데이터들로 이루어진 연속된 자료 구조다.<br>
만약 위에서 말했던 프로그램을 작성할 때 배열을 사용하면 아래와 같이 간단해진다.<br>


```java
int i[] = new int[10];
```


똑같은 정수 10개를 담을 수 있는 코드이나,<br>
후자가 훨씬 더 간단하고 사용, 유지 측면에서 효율성이 높다.<br>


## 1. 배열 선언


Java에서는 C/C++과 달리 래퍼런스 변수 선언과 배열 생성 단계가 필요하다.<br>


일단 다음과 같이 배열에 대한 레퍼런스 변수를 선언한다.<br>


```java
int intArray[]; 
//또는
int [] intArray;
```

단 선언 시 [] 안에 크기를 지정해서는 안된다.<br>
컴파일 오류가 발생한다.<br>

다음으로 배열을 생성한다.<br>
배열 공간을 할당 받는 것이다.<br>


```java
intArray = new int[5];
```


new 연산자를 사용하며, [] 안에 생성할 원소 개수를 지정해 준다.<br>

이 과정을 합쳐서 다음과 같이 한 번에 선언할 수 있다<br>


```java
int intArray[] = new int[5];
```


다음과 같이 배열 선언문에서 초기화를 하는 것도 가능하다.<br>


```java
int intArray[] = {1, 2, 3, 4, 5};
```


이렇게 선언하면 배열의 크기는 자동으로 5가 된다.<br>
배열의 크기는 {} 안에 나열된 원소 개수로 정해지는 것이다.<br>






## 2. 배열 인덱스와 배열 접근


배열을 활용하려면 인덱스를 사용해야 한다.<br>
배열의 인덱스는 음수 또는 배열의 크기(=범위)를 넘어선 수는 사용할 수 없다.<br>


다음은 오류 발생 예시들이다.<br>


```java
int intArray[] = {1, 2, 3, 4, 5};
int n = intArray[-2];   //오류: 인덱스로 음수 사용 불가
int m = intArray[5];    //오류: 5는 배열의 크기를 초과한 숫자임(0~4 인덱스 사용 가능)

int iA [];  //래퍼런스만 선언
iA[1] = 8;  //오류: 래퍼런스만 선언되어 있고, 배열은 생성되지 않은 상태에서 사용 불가
```


배열에서 인덱스는 1이 아닌 0부터 시작한다.<br>
첫번째 요소는 인덱스 0, 두번째 요소는 인덱스 1 ... 이런 식이다.<br>






## 3. 레퍼런스 치환과 배열 공유


자바에서는 레퍼런스 변수와 배열 공간이 분리되어있다.<br>
그래서 생성된 배열에 대한 공유가 쉽게 이루어진다.<br>
다음과 같이, 생성된 배열을 다수의 레퍼런스가 참조 가능하다.<br>


```java
int intArray[] = new int[5];
int myArray[] = intArray;   //레퍼런스 치환. myArray는 intArray와 동일 배열 참조
```


이는 새로운 배열이 생성된 것이 아니라, 레퍼런스만 복사된 것이므로<br>
myArray는 intArray의 값을 가지게 된다. 즉, 배열을 공유하고<br>
myArray로 intArray의 값에 마음대로 접근이 가능하다.<br>






## 4. 배열 크기와 length 필드


지금 파트에서 공부하진 않지만, 자바는 배열을 객체로 다룬다.<br>
배열이 생성되면, 배열의 크기를 가진 length 필드가 배열 객체 내에 생성된다.<br>
때문에 배열 크기를 관리할 필요가 없어서 배열을 다루기 수월하다.<br>


사용 예시는 다음과 같다.<br>


```java
int intArray[] = new int[5];
int size = intArray.length; //size는 5가 된다.
```


지금까지 공부한 배열과 length 필드로 간단한 프로그램을 만들어 보겠다.<br>


```java
import java.util.Scanner;

public class ArrayEx{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);

        int scoreArray[] = new int[5];
        int sum = 0;
        double avg = 0;

        System.out.print("점수 입력>>> ");

        for(int i = 0; i < scoreArray.length; i++){
            scoreArray[i] = sc.nextInt();
            sum += scoreArray[i]; 
        }

        avg = (double)sum / scoreArray.length;

        System.out.println("점수 평균>>> " + avg);
        sc.close();
    }
}
```


위 프로그램은 점수 5개를 입력 받고, 그 점수의 평균을 구해 출력하는 프로그램이다.<br>
반복문 조건식 부분과 평균을 구하는 부분에 length 필드를 사용했다.<br>






## 5. 배열과 for-each문


for-each문은 for문을 변형한 것이다.<br>
배열의 크기만큼 루프를 돌면서 각 원소에 순차적으로 접근하는 데에 유용하다.<br>
일반적인 형식은 다음과 같다.<br>


```java
for(변수 : 배열레퍼런스){
    반복 작업문;
}
```


for-each문을 사용한 간단한 프로그램을 만들어 보겠다.<br>


```java
int num[] = {1, 2, 3, 4, 5};
int sum = 0;

for(int k : num){   //num.length 만큼 반복
    sum += k;       //반복마다 k = num[0], num[1]... 이런 식으로 설정됨.
}
```


위 프로그램은 배열에 저장된 원소의 합을 구하는 프로그램이다.<br>
일반적인 for문을 활용한 것보다 훨씬 간소화 된 코드 작성이 가능하다.<br>






## 6. 다차원 배열


지금까지 공부했던 것은 1차원 배열이다.<br>
Java에서 다차원 배열 구현이 가능하다.<br>
하지만 일반적으로 3차원 이상의 배열은 잘 사용되지 않는다고 한다.<br>
그러니 2차원 배열까지만 공부해 보겠다.<br>


먼저 1차원 배열과 마찬가지로 *레퍼런스 변수 선언 > 배열 생성*  단계는 동일하다.<br>


```java
int intArray[][];   //레퍼런스 선언 방법1
int [][] intArray;  //레퍼런스 선언 방법2
```


```java
intArray = new int[2][5];   //2행 5열의 2차원 배열 생성
```


위에서부터 순서대로 *레퍼런스 선언 > 배열 생성* 의 과정이다.<br>


다음은 초기화 방법과 length 필드 사용 방법이다.<br>


```java
int intArray[][] = { {0, 1, 2}, {3, 4, 5}, {6, 7, 8} };       //3x3 배열 생성
char charArray[][] = { {'a', 'b', 'c'}, {'d', 'e', 'f'} };    //2x3 배열 생성
double doubleArray[][] = { {0.1, 0.2}, {0.3, 0.4} };          //2x2 배열 생성

int n[][] = new int[2][5];
int size1 = n.length;    //size1 = 2 >>> 행의 개수
int size2 = n[0].length; //size2 = 5 >>> 첫 번째 행의 원소 개수
int size3 = n[1].length; //size3 = 5 >>> 두 번째 행의 원소 개수
```


예제 프로그램으로 2차원 배열을 활용해 보겠다.<br>


```java
public class ScoreAvgEx{
    public static void main(String[] args){
        double score[][] = {    //1학년부터 4학년까지 각 1, 2학기 학점 저장
            {3.3, 3.4},         //1학년 1, 2학기
            {3.5, 3.6},         //2학년 1, 2학기
            {3.7, 4.0},         //3학년 1, 2학기
            {4.1, 4.2}          //4학년 1, 2학기
        };

        double sum = 0;
        double avg  = 0;

        for(int year = 0; year < score.length; year++){     //학년별
            for(int term = 0; term < score[year].length; term++){   //학기별
                sum += score[year][term];
            }
        }

        int n = score.length;       //행(학년) 4
        int m = score[0].length;    //열(학기) 2
        avg = sum / (n * m);

        System.out.println("학점 전체 평균>>> " + avg); 
    }
}
```


위 프로그램은 4년 동안 전체 학점 평균을 구하는 프로그램이다.<br>
학년은 4학년, 학기는 학년 당 1, 2학기가 있으므로 4x2 배열이 생성된다.<br>
반복문으로 sum 에 학점을 저장할 땐, 바깥 루프는 학년, 안쪽 루프는 학기로 돌아야 한다.<br>
평균을 구할 땐 전체 배열의 원소 개수로 sum을 나눠준다.<br>






## 7. 메소드의 배열 리턴


메소드는 배열을 리턴하는 것이 가능하다.<br>
하지만 이 경우 배열 메모리 전체가 아닌, 배열 레퍼런스만 리턴된다.<br>


```java
//리턴 타입 메소드 이름
int[] makeArray(){
    int temp[] = new int[4];
    return temp;    //배열 리턴    
}
```


위 코드는 배열 레퍼런스를 리턴하는 메소드의 예시이다.<br>
주의할 점은 메소드의 리턴 타입에 크기를 지정하지 않아야 한다.<br>


```java
int [] intArray;        //makeArray() 메소드의 리턴 타입과 동일한 타입으로 선언
intArray = makeArray(); //메소드가 리턴하는 배열을 받음
```


이러면 intArray는 makeArray()가 리턴한 배열을 가리키게 되며,<br>


```java
for(int i = 0; i < intArray.length; i++){
    intArray[i] = i;
}
```


이런 식으로 접근이 가능하다.<br>


정리하자면,<br>


1. int[] intArray 선언 (메소드의 리턴 타입과 동일한 타입으로 배열 참조 변수 선언)<br>


2. makeArray()의 temp는 new int[4] 의 배열<br>


3. intArray에 temp 값이 치환됨 > 즉, new int[4]의 배열을 가리킴.<br>


4. intArray로 넘겨받은 배열 사용 가능.<br>


마지막으로 예제 프로그램으로 조금 더 자세히 공부해 보겠다.<br>


```java
public class ReturnArrayEx{
    static int[] makeArray(){
        int temp[] = new int[4];

        for(int i = 0; i < temp.length; i++){
            temp[i] = i;
        }
        return temp;
    }
    public static void main(String[] args){
        int intArray[];
        
        intArray = makeArray();

        for(int i = 0; i < intArray.length; i++){
            System.out.print(intArray[i] + " ");
        }
    }
}
```


위 프로그램은 makeArray() 메소드에서 생성한 배열을 반환하고,<br>
메인 메소드에서 그 배열을 참조하여 출력하는 프로그램이다.<br>
makeArray()가 종료되어도 생성된 배열은 소멸되지 않고,<br>
메인 메소드의 intArray 레퍼런스가 생성된 배열을 가리키게 된다.<br>
때문에 위와 같은 형식으로 결과 출력이 가능해지는 것이다.<br>


지금까지 배열에 대해서 공부해 보았다.<br>
배열을 공부하면서 헷갈렸던 부분은 일반 변수와 레퍼런스는 무엇이 다른가? 였다.<br>


```java
int num;    //일반 변수
int[] arr;  //레퍼런스(참조 변수)
```


선언된 위 두 변수의 차이점이 무엇일까?<br>
먼저 선언된 num 은 일반 변수로서 값 자체를 저장한다.<br>
하지만 arr은 참조 변수로서 객체의 주소를 저장한다.<br>
즉 참조 변수는 객체를 가리키는 변수인 것이다.<br>
하지만 자바는 주소를 직접 다루거나 연산할 수 없다.<br>
때문에 안전한 메모리 관리가 가능하다.<br>


-----------------------------------------------------------------------<br>


지금까지 자바의 배열에 대해 공부해 보았다.<br>
다음 글에서는 자바의 예외 처리에 대해서 공부해 보겠다.<br>


---
※ 본 글은 개인 학습을 목적으로 「명품 자바 에센셜」(황기태 지음, 생능출판)을 참고하여 작성하였습니다.