---
layout: single
title: "Java Chapter 13 – 그래픽"
date: 2026-01-26
categories:
  - Java
  - java_grammer
tags: [Java, 문법]
author_profile: true
read_time: true
comments: true
share: true
related: true
sidebar:
  nav: "categories_sidebar"
---


# 자바 그래픽






## 1. 스윙 컴포넌트 그리기


스윙 컴포넌트는 화면에 자신의 모양을 직접 그린다.<br>
예를 들어 JButton, JComboBox 등은<br>
각각 버튼과 콤보박스의 모양을 화면에 출력한다.<br>

자바의 Swing에서는 JComponent를 상속받은 컴포넌트가<br>
자신의 모양을 그리기 위한 코드를<br>
paintComponent() 메소드에 작성하도록 설계되어 있다.<br>

paintComponent() 메소드의 원형은 다음과 같다.<br>


```java
protected void paintComponent(Graphics g)
```

paintComponent() 메소드는 JComponent 클래스에 이미 구현되어 있으며,<br>
필요한 경우 개발자가 이를 오버라이딩하여 재정의할 수 있다.<br>

이 메소드는 자바 플랫폼에 의해 자동으로 호출되며,<br>
개발자가 직접 호출해서는 안 된다.<br>
컴포넌트를 다시 그리고 싶을 경우 repaint() 메소드를 호출해야 한다.<br>

paintComponent() 메소드는 다음과 같은 경우에 호출된다.<br>


1. 컴포넌트가 처음 화면에 표시될 때<br>

2. 컴포넌트의 크기나 위치 등 상태가 변경될 때<br>

3. 다른 윈도우에 의해 가려졌다가 다시 나타날 때<br>

4. 창이 최소화되었다가 다시 복원될 때<br>

5. 프로그램에서 repaint() 메소드를 호출했을 때<br>


paintComponent(Graphics g)의 매개변수로 전달되는<br>
Graphics 객체는 컴포넌트를 그리기 위한 그래픽 컨텍스트로,<br>
자바 플랫폼에 의해 생성되어 전달된다.<br>

개발자가 새로운 컴포넌트를 만들거나<br>
기존 스윙 컴포넌트의 모양을 변경하고자 할 때는<br>
다음과 같이 paintComponent() 메소드를 오버라이딩하여<br>
직접 그리기 코드를 작성할 수 있다.<br>


```java
class MyComponent extends JComponent {
    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        // 컴포넌트를 그리는 코드 작성
    }
}
```


paintComponent()를 오버라이딩할 때는<br>
반드시 super.paintComponent(g)를 호출하여<br>
컴포넌트의 기본적인 배경 처리와 정상적인 화면 갱신이<br>
이루어지도록 해야 한다.<br>


다음은 JPanel을 상속받은 패널에 도형을 그리는 예제이다.<br>


```java
public class paintJPanelEx extends JFrame {

	public paintJPanelEx() {
		setTitle("JPanel의 paintComponent() 예제");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		setContentPane(new MyPanel()); // MyPanel 패널을 컨텐트팬으로 사용

		setSize(250, 200);
		setVisible(true);
	}

	// JPanel 을 상속받는 새 패널 구현
	class MyPanel extends JPanel {
		protected void paintComponent(Graphics g) {
			super.paintComponent(g); // JPanel 의 paintComponent() 호출 -> 패널 내에 이전에 그려진 잔상 지우기 위해 호출

			g.setColor(Color.BLUE);
			g.drawRect(10, 10, 50, 50); // (10,10) 위치에 50x50 크기 사각형 그리기
			g.drawRect(50, 50, 50, 50); // (50,50) 위치에 50x50 크기 사각형 그리기

			g.setColor(Color.GRAY);
			g.drawRect(90, 90, 50, 50); // (90,90) 위치에 50x50 크기 사각형 그리기
		}
	}

	public static void main(String[] args) {
		new paintJPanelEx();
	}
}
```


여기서 JFrame은 최상위 컨테이너로서 창을 구성하는 역할을 하고,<br>
실제 그래픽 출력은 paintComponent()를 제공하는<br>
JPanel과 같은 JComponent에서 수행한다.<br>


실행 결과는 다음과 같다.<br>


![JPanel 도형 예제](/assets/images/JPanel%20도형%20예제.PNG)






## 2. Graphics


그래픽이란 스윙 컴포넌트의 기본 모양 대신,<br>
개발자가 선, 도형, 이미지 등을 이용하여<br>
화면을 직접 그리는 방식을 말한다.<br>

그래픽은 스윙 컴포넌트에 비해<br>
화면 표현의 자유도가 높아<br>
게임 화면 등 사용자 정의 화면을 표현하는 데 유리하다.<br>

Graphics 클래스의 경로명은 java.awt.Graphics이며,<br>
그리기, 칠하기, 이미지 출력 등 다양한 필드와 메소드를 제공한다.<br>


### Graphics의 좌표 체계


자바 그래픽의 좌표 값은 그래픽 대상 컴포넌트의<br>
왼쪽 상단 모서리가 (0, 0)이며,<br>
오른쪽으로 x축 값이 증가하고, 아래쪽으로 y축 값이 증가한다.<br>


### Graphics의 기능 - 문자열 그리기


문자열을 그리기 위한 Graphics 메소드는 다음과 같다.<br>


```java
void drawString(String str, int x, int y)

문자열의 시작 위치를 기준으로
(x, y) 좌표에 문자열을 출력.
이때 y좌표는 문자열의 기준선(baseline)을 의미.
```


### Graphics의 기능 - 색상과 폰트


Color와 Font 클래스는 색과 문자 폰트를 지정하는 데 사용된다.<br>

자바에서 색은 r(red), g(green), b(blue) 성분으로 구성되며,<br>
각 성분은 0~255(8비트) 범위의 정수이다.<br>

Color의 생성자는 다음과 같다.<br>


```java
Color(int r, int g, int b) r, g, b 값으로 sRGB 생성

Color(int rgb) rgb는 32비트의 정수이지만 하위 24비트만 유효.
즉, 0x00rrggbb로 표현. 각 바이트가 r, g, b의 색 성분
```


색은 위의 생성자를 이용하지 않고도,<br>
다음과 같이 Color 클래스에 상수로 선언된 필드를 사용하는 것도 가능하다.<br>


```java
Graphics g;

g.setColor(Color.BLUE);
```


Font는 문자의 폰트 정보를 담으며, 생성자는 다음과 같다.<br>


```java
Font(String fontFace, int style, int size)

* fontFace : 폰트 이름

* style : Font.BOLD, Font.ITALIC, Font.PLAIN 중 한 값으로, 문자의 스타일

* size : 문자의 크기(point 단위)

point란 1/72인치를 기준으로 하는 물리적인 길이 단위.
```


색과 폰트를 설정하는 Graphics 메소드는 다음과 같다.<br>


```java
void setColor(Color color)  // 그래픽 색을 color로 설정

void setFont(Font font) // 그래픽 폰트를 font로 설정
```


다음은 Color와 Font를 이용한 예제이다.<br>


```java
public class ColorFontEx extends JFrame {

	public ColorFontEx() {
		setTitle("JPanel의 paintComponent() 예제");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		setContentPane(new MyPanel()); // MyPanel 패널을 컨텐트팬으로 사용

		setSize(300, 300);
		setVisible(true);
	}

	// JPanel 을 상속받는 새 패널 구현
	class MyPanel extends JPanel {
		protected void paintComponent(Graphics g) {
			super.paintComponent(g); // JPanel 의 paintComponent() 호출 -> 패널 내에 이전에 그려진 잔상 지우기 위해 호출

			g.setColor(Color.BLUE);
			g.drawString("자바 자바", 30, 30); // (30, 30) 에 문자열 출력

			g.setColor(new Color(255, 0, 0));
			g.setFont(new Font("Arial", Font.ITALIC, 30));
			g.drawString("Hi Hi Hi", 30, 70);

			g.setColor(new Color(0x00ff00ff));

			for (int i = 1; i <= 4; i++) {
				g.setFont(new Font("Jokerman", Font.ITALIC, i * 10));
				g.drawString("Bye Bye Bye", 30, 60 + i * 40);
			}
		}
	}

	public static void main(String[] args) {
		new ColorFontEx();
	}
}
```


실행 결과는 다음과 같다.<br>


![ColorFont 예제](/assets/images/ColorFont%20예제.PNG)


### Graphics의 기능 - 도형 그리기


Graphics를 이용하여 다양한 도형을 그릴 수 있다.<br>

도형을 그리는 Graphics의 주요 메소드는 다음과 같다.<br>


```java
void drawLine(int x1, int y1, int x2, int y2)
// (x1, y1) 에서 (x2, y2) 까지 선을 그림.

void drawOval(int x, int y, int w, int h)
// (x, y)를 왼쪽 위 모서리로 하는 너비 w, 높이 h인 사각형에 내접하는 타원을 그림. w나 h가 0 이하일 경우 아무 것도 그려지지 않음.

void drawRect(int x, int y, int w, int h)
// (x, y)를 왼쪽 위로 하는 너비 w, 높이 h인 사각형을 그림.

void drawRoundRect(int x, int y, int w, int h, int arcWidth, int arcHeight)
// (x, y)를 왼쪽 위로 하는 사각형을 그리되, 네 모서리가 arcWidth, arcHeight 크기의 타원으로 둥글게 처리됨. arcWidth/arcHeight가 클수록 모서리가 더 둥글게 처리됨.

* arcWidth : 모서리 타원의 수평 지름

* arcHeight : 모서리 타원의 수직 지름

void drawArc(int x, int y, int w, int h, int startAngle, int arcAngle)
// (x, y)를 왼쪽 위로 하는 w x h 크기의 사각형에 내접하는 원호를 그림. 3시 방향이 0도 기점. startAngle 지점에서 arcAngle 각도만큼 원호를 그림. arcAngle 이 양수이면 반시계 방향, 음수이면 시계 방향으로 그림.

* startAngle : 원호의 시작 각도

* arcAngle : 원호 각도

void drawPolygon(int []x, int []y, int n)
// x, y 배열에 저장된 점들 중 n개를 순서대로 연결하며, 마지막 점과 첫 번째 점을 자동으로 연결하여 폐다각형을 그림.
```


다음은 위 메소드들을 이용하여 도형들을 그리는 예제이다.<br>


```java
public class GraphicsDrawEx extends JFrame {

	public GraphicsDrawEx() {
		setTitle("GraphicsDraw 예제");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		setContentPane(new MyPanel());

		setSize(400, 450);
		setVisible(true);
	}

	class MyPanel extends JPanel {
		@Override
		public void paintComponent(Graphics g) {
			super.paintComponent(g);

			g.setColor(Color.RED);

			g.drawLine(20, 20, 100, 100); // (20, 20) 에서 (100, 100) 을 잇는 선 그리기

			g.drawOval(120, 20, 80, 80); // (120, 20) 에서 80x80 원 그리기

			g.drawRect(220, 20, 80, 80); // (220, 20) 에서 80x80 사각형 그리기

			g.drawRoundRect(20, 120, 120, 80, 40, 60); // (20, 120) 에서 120x80 크기의 사각형을 그리되, 각 모서리를 40x60 크기의 타원으로 둥글게 처리

			g.drawArc(220, 120, 80, 80, 90, 270); // (220, 120) 에서 80x80 사각형에 내접하는 원호를 그리되, 시작 각도는 90도, 원호의 각도는 270도

			int[] x = { 180, 140, 180, 220 };
			int[] y = { 240, 320, 400, 320 };

			g.drawPolygon(x, y, 4); // x, y 각 배열 원소를 점으로 순차적으로 잇는 폐다각형 그리기
		}
	}

	public static void main(String[] args) {
		new GraphicsDrawEx();
	}
}
```


![GraphicsDraw 예제](/assets/images/GraphicsDraw%20예제.PNG)


참고로 Graphics의 도형 그리기는 기본적으로 1픽셀 두께로만 그려지며,<br>
선의 두께를 직접 지정할 수 없다.<br>
외곽선의 두께를 다양하게 표현하고자 할 경우에는<br>
크기를 달리하여 여러 번 도형을 겹쳐 그리거나,<br>
Graphics 2D를 사용해야 한다.<br>


### Graphics의 기능 - 도형 칠하기


도형 채우기란 도형의 외곽선과 내부를 동일한 색으로 채우는 기능이다.<br>

만약 외곽선과 내부를 다른 색으로 표현하고 싶다면,<br>

1. 먼저 도형 내부를 채운 뒤<br>

2. 다시 외곽선을 그려야 한다.<br>

도형을 칠하는 메소드는 다음과 같다.<br>


```java
void fillXXX()	// XXX는 도형의 이름
```


다음은 도형 칠하기 메소드를 이용한 예제이다.<br>


```java
public class GraphicsFillEx extends JFrame {

	public GraphicsFillEx() {
		setTitle("GraphicsFill 예제");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		setContentPane(new MyPanel());

		setSize(400, 450);
		setVisible(true);
	}

	class MyPanel extends JPanel {
		@Override
		public void paintComponent(Graphics g) {
			super.paintComponent(g);

			g.setColor(Color.RED);
			g.fillOval(120, 20, 80, 80); // (120, 20) 에서 80x80 원 칠하기

			g.setColor(Color.BLUE);
			g.fillRect(220, 20, 80, 80); // (220, 20) 에서 80x80 사각형 칠하기

			g.setColor(Color.GREEN);
			g.fillRoundRect(20, 120, 120, 80, 40, 60); // (20, 120) 에서 120x80 크기의 사각형을 칠하되, 각 모서리를 40x60 크기의 타원으로 둥글게 처리

			g.setColor(Color.PINK);
			g.fillArc(220, 120, 80, 80, 90, 270); // (220, 120) 에서 80x80 사각형에 내접하는 원호를 칠하되, 시작 각도는 90도, 원호의 각도는 270도

			int[] x = { 180, 140, 180, 220 };
			int[] y = { 240, 320, 400, 320 };

			g.setColor(Color.CYAN);
			g.fillPolygon(x, y, 4); // x, y 각 배열 원소를 점으로 순차적으로 잇는 폐다각형 칠하기
		}
	}

	public static void main(String[] args) {
		new GraphicsFillEx();
	}
}
```


실행 결과는 다음과 같다.<br>


![GraphicsFill 예제](/assets/images/GraphicsFill%20예제.PNG)


### Graphics의 기능 - 이미지 그리기


스윙에서 이미지는 다음 2가지 방법으로 그릴 수 있다.<br>

1. JLabel을 이용한 이미지 그리기<br>

2. Graphics의 drawImage()를 이용한 이미지 그리기<br>


첫 번째 방법은 JLabel 컴포넌트를 이용하는 것으로,<br>
전 글에서 이미 해본 방법이다.<br>


```java
ImageIcon image = new ImageIcon("images/dog.jpg");	// 이미지 로딩

JLabel label = new JLabel(image);	// 이미지 레이블 만들기

panel.add(label);	// 이미지 레이블을 패널에 삽입.
```


이 방법은 이미지의 크기 조절이 어렵다는 단점이 있다.<br>


두 번째 방법은 Graphics의 drawImage() 메소드를 이용하는데,<br>
이 메소드를 이용하면 원하는 위치에, 원하는 크기, 비율로<br>
이미지를 그리는 것이 가능하다.<br>

하지만 이 방법은 이미지를 그리는 코드를 직접 작성해야 한다.<br>

다음은 원본 크기로 이미지를 그리는 메소드와,<br>
이미지 크기를 조절하여 그리는 메소드이다.<br>


```java
boolean drawImage(Image img, int x, int y, Color bgColor, ImageObserver observer)

boolean drawImage(Image img, int x, int y, ImageObserver observer)

* img : 이미지 객체

* x, y : 이미지가 그려질 좌표

* bgColor : 이미지가 투명한 부분을 가지고 있을 때, 이미지의 투명한 영역을 채울 배경색

* observer : 이미지 로딩 상태 변화를 통보받는 객체

// img 를 그래픽 영역의 (x, y) 위치에 원본 크기로 그림.
```


```java
boolean drawImage(Image img, int x, int y, int width, int height, Color bgColor, ImageObserver observer)

boolean drawImage(Image img, int x, int y, int width, int height, ImageObserver observer)

* width : 그려지는 폭으로서 픽셀 단위

* height : 그려지는 높이로서 픽셀 단위

// img 를 그래픽 영역의 (x, y) 위치에 width x height 크기로 그림.
```


다음은 원본 크기로 이미지를 그리는 예제이다.<br>


```java
public class GraphicsDrawImageEx1 extends JFrame {

	public GraphicsDrawImageEx1() {
		setTitle("GraphicsDrawImage 예제1");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		setContentPane(new MyPanel());

		setSize(400, 300);
		setVisible(true);
	}

	class MyPanel extends JPanel {
		private ImageIcon icon = new ImageIcon("images/dog.jpg"); // 이미지 로딩
		private Image img = icon.getImage(); // 이미지 객체

		@Override
		public void paintComponent(Graphics g) {
			super.paintComponent(g);

			g.drawImage(img, 20, 20, this); // 이미지를 패널의 (20, 20) 에 원래 크기로 그림
		}
	}

	public static void main(String[] args) {
		new GraphicsDrawImageEx1();
	}
}
```


실행 결과는 다음과 같다.<br>


![GraphicsDrawImage 예제1](/assets/images/GraphicsDrawImage%20예제1.PNG)


다음은 JPanel 크기에 맞춰 이미지를 그리는 예제이다.<br>


```java
public class GraphicsDrawImageEx2 extends JFrame {

	public GraphicsDrawImageEx2() {
		setTitle("GraphicsDrawImage 예제2");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		setContentPane(new MyPanel());

		setSize(400, 300);
		setVisible(true);
	}

	class MyPanel extends JPanel {
		private ImageIcon icon = new ImageIcon("images/dog.jpg"); // 이미지 로딩
		private Image img = icon.getImage(); // 이미지 객체

		@Override
		public void paintComponent(Graphics g) {
			super.paintComponent(g);

			g.drawImage(img, 0, 0, getWidth(), getHeight(), this);
			// 이미지를 패널 크기로 조절하여 그림
			// getWidth(), getHeight() -> 패널의 폭과 높이
			// 마지막 인자는 이미지 로딩 상태를 통보받는 객체 지정 (this 이므로 JPanel이 처리)
			// 이미지 로딩 상태 통보가 필요 없으면 null 로 지정
		}
	}

	public static void main(String[] args) {
		new GraphicsDrawImageEx2();
	}
}
```


실행 결과는 다음과 같다.<br>


![GraphicsDrawImage 예제2](/assets/images/GraphicsDrawImage%20예제2.PNG)


이 예제에서는 마우스로 프레임의 크기를 변경하면<br>
MyPanel의 paintComponent()가 다시 호출되고,<br>
drawImage()가 변경된 패널 크기에 맞추어 이미지를 다시 그린다.<br>






## 3. repaint()와 그래픽 응용


### repaint()는 그림을 그리는 메서드가 아니다

repaint()는 화면에 직접 그림을 그리지 않는다.<br>
이 메서드는 “이 컴포넌트를 다시 그려야 한다”는 요청만을 Swing에게 전달한다.<br>

실제 그림을 그리는 작업은 항상<br>
paintComponent(Graphics g) 메소드에서 이루어진다.<br>

즉, 화면 갱신의 흐름은 다음과 같다.<br>


```java
repaint() 호출
 → paint() 호출
   → paintComponent() 호출
```

개발자가 paintComponent()를 직접 호출해서는 안 된다.<br>


### repaint()는 자동으로 호출되는 경우가 많다

다음과 같은 상황에서는 repaint()를 직접 호출하지 않아도<br>
Swing이 자동으로 다시 그리기를 수행한다.<br>

1. 프레임이나 패널의 크기를 변경할 때<br>

2. 창이 다른 창에 가려졌다가 다시 나타날 때<br>

3. 컴포넌트가 이동하거나 겹칠 때<br>

4. 컴포넌트가 처음 화면에 표시될 때<br>

이 때문에 프레임 크기를 마우스로 변경하면<br>
paintComponent()가 자동으로 다시 호출되어<br>
현재 크기에 맞게 그림이 다시 그려진다.<br>


### 상태가 바뀌면 반드시 repaint()를 호출해야 한다

좌표, 색상, 이미지, 크기 등<br>
화면에 그려지는 내용에 영향을 주는 값이 변경되었을 경우에는<br>
반드시 repaint()를 호출해야 한다.<br>

값만 변경하고 repaint()를 호출하지 않으면<br>
화면은 이전 상태 그대로 유지된다.<br>


### paintComponent() 안에서 repaint()를 호출하면 안 된다

paintComponent() 내부에서 repaint()를 호출하면<br>
다시 paintComponent()가 호출되는 무한 반복이 발생할 수 있다.<br>

이는 CPU 사용량 증가와 프로그램 멈춤의 원인이 되므로<br>
절대로 사용해서는 안 된다.<br>


다음은 repaint()를 이용한 예제이다.<br>


```java
public class GraphicsRepaintEx extends JFrame {

	public GraphicsRepaintEx() {
		setTitle("GraphicsRepaint 예제");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		setContentPane(new MyPanel());

		setSize(300, 300);
		setVisible(true);
	}

	class MyPanel extends JPanel {

		private Vector<Point> vStart = new Vector<Point>();
		private Vector<Point> vEnd = new Vector<Point>();

		public MyPanel() {

			// Mouse 리스너 등록
			// 마우스 버튼이 눌려지면 시작점을 vStart 벡터에 저장
			// 마우스 버튼이 놓여지면 끝점을 vEnd 벡터에 저장

			addMouseListener(new MouseAdapter() { // MouseListener 구현 대신 MouseAdapter 상속 → 필요한 메소드만 구현
				@Override
				public void mousePressed(MouseEvent e) {

					Point startP = e.getPoint(); // 마우스가 눌린 위치 좌표 가져오기

					vStart.add(startP); // 시작점 벡터에 저장
				}

				@Override
				public void mouseReleased(MouseEvent e) {

					Point endP = e.getPoint(); // 마우스가 놓인 위치 좌표 가져오기

					vEnd.add(endP); // 끝점 벡터에 저장

					repaint(); // 패널 다시 그리기 요청 → paintComponent 호출
				}
			});
		}

		@Override
		public void paintComponent(Graphics g) {
			super.paintComponent(g);

			g.setColor(Color.BLUE);

			// 벡터에 저장된 모든 선을 순차적으로 그림
			for (int i = 0; i < vStart.size(); i++) {

				Point s = vStart.elementAt(i); // 벡터에 들어있는 시작점 알아내기

				Point e = vEnd.elementAt(i); // 벡터에 들어있는 끝점 알아내기

				g.drawLine((int) s.getX(), (int) s.getY(), (int) e.getX(), (int) e.getY()); // 시작점에서 끝점까지 선 그리기
			}
		}
	}

	public static void main(String[] args) {
		new GraphicsRepaintEx();
	}
}
```


이 예제에서는 마우스를 눌러 드래그하면 선이 그려지고,<br> 
각 선의 시작점과 끝점 좌표가 벡터에 저장된다.<br>

새로운 선이 추가될 때마다 repaint()를 호출하여 화면을 다시 그리며,<br> 
벡터에 저장된 모든 선을 순차적으로 그린다.<br>

결과적으로 이전에 그린 선들도 화면에 그대로 남아 있는 것처럼 보여,<br> 
사용자는 계속해서 선이 쌓이는 것처럼 느껴진다.<br>

동작 순서를 정리하면 다음과 같다.<br>


1. 마우스 누름 (mousePressed) → 현재 마우스 위치를 시작점 벡터(vStart)에 저장<br>

2. 마우스 놓음 (mouseReleased) → 현재 마우스 위치를 끝점 벡터(vEnd)에 저장<br>

3. repaint() 호출 → Swing이 화면 갱신 요청<br>

4. paintComponent() 호출 → 화면 초기화 후 벡터를 순회하면서 모든 선을 다시 그림<br>

5. 사용자 관점 → 이전에 그린 선도 포함되어 계속 선이 쌓이는 것처럼 보임<br>


실행 결과는 다음과 같다.<br>


![GraphicsRepaintEx 예제](/assets/images/GraphicsRepaint%20예제.PNG)


-----------------------------------------------------------------------<br>


지금까지 자바의 그래픽에 대해 공부해 보았다.<br>
다음 글에서는 자바의 스레드 기초에 대해서 공부해 보겠다.<br>


---
※ 본 글은 개인 학습을 목적으로 「명품 자바 에센셜」(황기태 지음, 생능출판)을 참고하여 작성하였습니다.