---
layout: single
title: "Java Chapter 7 – 상속"
date: 2025-12-14
categories:
  - Java
  - java_grammer
tags: [Java, 문법]
author_profile: true
read_time: true
comments: true
share: true
related: true
sidebar:
  nav: "categories_sidebar"
---


# Java의 상속


개발을 하다 보면 여러 클래스를 작성하면서 동일한 기능을 가진 메소드를<br>
각 클래스마다 작성하게 되는 경우가 있다.<br>
이때 해당 메소드에 문제가 발생하면 모든 클래스를 하나하나 수정해야 하므로<br>
유지보수가 어려워진다.<br>


이처럼 동일한 코드가 여러 클래스에 중복되는 문제를 해결하기 위해<br>
자바에서는 상속(Inheritance)을 제공한다.<br>


상속을 이용하면 공통 기능을 부모 클래스에 정의하고,<br>
자식 클래스에서는 이를 재사용하거나 확장할 수 있다.<br>






## 1. 상속 선언


자바에서 상속 선언은 extends 키워드를 사용한다.<br>
상속하는 클래스(부모 클래스)를 슈퍼 클래스(super class),<br>
상속받는 클래스(자식 클래스)를 서브 클래스(sub class)라고 부른다.<br>


```java
class Animal{
    String name;
}

class Dog extends Animal{
    void bark(){
        System.out.println(name + "멍멍");
    }
}
```


위 예제는 부모 클래스 Animal을 상속받은 자식 클래스 Dog가<br>
부모 클래스의 필드 name 을 그대로 사용하고,<br>
bark() 메소드를 추가로 정의한 예시이다.<br>


```java
class Animal{
    String name;
    private int age;

    public int getAge(){
        return age;
    }
}

class Dog extends Animal{
    void bark(){
        System.out.println(getAge() + "살 " + name + "은 멍멍");
    }
}
```


위의 예시는 private 필드를 추가한 상속 예시이다.<br>
자식 클래스라 하더라도 부모 클래스의 private 멤버에는 직접 접근할 수 없다.<br>
따라서 private 필드에 접근하기 위해서는 <br>
부모 클래스가 제공하는 메소드를 통해 간접적으로 접근해야 한다.<br>


```java
Dog dog = new Dog();

dog.name = "바둑이";
dog.age = 1;        //컴파일 오류 -> private 필드는 클래스 내부에서만 접근 가능
```


또한 객체를 통해 외부에서  private 필드를 접근하는 것도 불가능하다.<br>


자바 상속은 다음과 같은 특징들을 가진다.<br>


첫째, 자바에서는 클래스 다중 상속을 지원하지 않는다.<br>
다중 상속은 여러 가지 문제점을 가지고 있기 때문이다.<br>


둘째, 자바의 모든 클래스는 자바에서 제공하는 Object 클래스를<br>
자동으로 상속받도록 컴파일된다. 위의 예시에서 Animal 클래스는<br>
아무것도 상속받고 있지 않지만 컴파일러에 의해 Object 클래스를<br>
상속받는다. Object 클래스는 슈퍼 클래스를 가지지 않는 유일한 클래스이다.<br>
(Object 클래스의 경로명은 java.lang.Object 이다.)<br>






## 2. 슈퍼 클래스의 디폴트 멤버에 대한 서브 클래스의 접근


자바의 접근 지정자 4개 중 디폴트 접근 지정과 protected 접근 지정에 대해 알아보자.<br>


### 디폴트 접근 지정


접근 지정이 선언되어 있지 않을 때를 디폴트 접근 지정이라고 부르며,<br>
디폴트 멤버는 동일한 패키지의 클래스들에게만 접근이 허용된다.<br>
만약 서브 클래스가 슈퍼 클래스와 다른 패키지에 있다면,<br>
슈퍼 클래스의 디폴트 멤버들에 접근이 불가능하다.<br>


### protected 접근 지정


슈퍼 클래스의 protected 멤버는 다음 두 가지 경우에 접근이 허용된다.<br>
1. 같은 패키지에 속한 모든 클래스<br>
2. 상속되는 서브 클래스(같은 패키지, 다른 패키지 상관 없음)<br>


아래는 슈퍼 클래스 멤버에 대한 접근 지정을 표로 정리한 것이다.<br>


![접근 지정 정리표](/assets/images/접근%20지정%20정리표.jpg)<br>






## 3. 상속과 생성자


서브 클래스와 슈퍼 클래스의 객체가 생성될 때,<br>
두 클래스의 생성자는 모두 실행된다.<br>

이때 먼저 실행되는 것은 항상 슈퍼 클래스의 생성자이다.<br>

비록 서브 클래스의 생성자가 먼저 호출되는 것처럼 보이더라도,<br>
컴파일러는 슈퍼 클래스의 생성자를 먼저 호출한 뒤<br>
서브 클래스의 생성자 코드를 실행하도록 컴파일한다.<br>

이는 슈퍼 클래스가 먼저 초기화된 후,<br>
이를 기반으로 서브 클래스가 초기화되어야 하기 때문이다.<br>


### ●슈퍼 클래스 기본 생성자의 묵시적 선택


개발자의 명시적 지시가 없으면, 서브 클래스 생성자의 매개변수 유무와 상관없이<br>
슈퍼 클래스의 생성자로 기본 생성자가 선택된다.<br>
이 선택은 자바 컴파일러에 의해 묵시적으로 이루어진다.<br>


```java
class A{
    public A() {
        System.out.println("생성자 A");
    }
    public A(int x) {
        .......
    }
}

class B extends A{
    public B() {
        System.out.println("생성자 B");
    }
}

public class ConstructorEx {
    public static void main(String[] args) {
        B b;
        b = new B();    //생성자 호출
    }
}
```


위의 예시 코드에서 b = new B(); 로 생성자를 호출하면,<br><br>


생성자 호출 순서는 다음과 같다.<br>


1. 생성자 B() 호출
2. 생성자 A() 호출
3. 생성자 A() 실행
4. 생성자 B() 실행


그러므로 프로그램 실행 결과는<br>


```java
생성자 A
생성자 B
```


가 된다.<br>
서브 클래스의 기본 생성자에 대해 컴파일러는 자동으로<br>
슈퍼 클래스의 기본 생성자와 짝을 맺은 것이다.<br><br>


그렇다면 클래스 A에 기본 생성자가 없이<br>
A(int x) 생성자만 선언되어 있다면 어떻게 될까?<br>

이 경우 B()와 짝을 이룰 A() 생성자를 찾을 수 없기 때문에<br>
컴파일 오류가 발생한다.<br>


이제 서브 클래스의 매개 변수를 가진 생성자의 경우를 살펴보겠다.<br>
이 경우에도 개발자의 특별한 지시가 없다면,<br>
슈퍼 클래스의 기본 생성자가 호출된다.<br>


```java
class A{
    public A() {
        System.out.println("생성자 A");
    }
    public A(int x) {
        System.out.println("매개 변수 생성자 A");
    }
}

class B extends A{
    public B() {
        System.out.println("생성자 B");
    }
    public B(int x) {
        System.out.println("매개 변수 생성자 B");
    }
}

public class ConstructorEx {
    public static void main(String[] args) {
        B b;
        b = new B(5);    //생성자 호출
    }
}
```


위의 예시 코드에서 b = new B(5); 로 생성자를 호출하면,<br><br>


생성자 호출 순서는 다음과 같다.<br>


1. 생성자 B(int x) 호출
2. 생성자 A() 호출
3. 생성자 A() 실행
4. 생성자 B(int x) 실행


그러므로 프로그램 실행 결과는<br>


```java
생성자 A
매개 변수 생성자 B
```


가 된다.<br>


### ●super()를 이용한 명시적 슈퍼 클래스 생성자 선택


super()를 이용하면, 서브 클래스의 생성자에서 슈퍼 클래스의 생성자를<br>
명시적으로 선택할 수 있다.<br>
super()는 슈퍼 클래스 생성자의 호출을 의미한다.<br>


```java
class A{
    public A() {
        System.out.println("생성자 A");
    }
    public A(int x) {
        System.out.println("매개 변수 생성자 A" + x);
    }
}

class B extends A{
    public B() {
        System.out.println("생성자 B");
    }
    public B(int x) {
        super(x);
        System.out.println("매개 변수 생성자 B" + x);
    }
}

public class ConstructorEx {
    public static void main(String[] args) {
        B b;
        b = new B(5);    //생성자 호출
    }
}
```


위의 예시 코드에서 b = new B(5); 로 생성자를 호출하면,<br><br>


생성자 호출 순서는 다음과 같다.<br>


1. 생성자 B(int x) 호출
2. super(x) 로 인한 생성자 A(int x) 호출
3. 생성자 A(int x) 실행
4. 생성자 B(int x) 실행


그러므로 프로그램 실행 결과는<br>


```java
매개 변수 생성자 A5
매개 변수 생성자 B5
```


가 된다.<br>


> 주의할 점은 super()의 호출은 반드시 생성자의 첫 라인에 와야 한다.<br>






## 4. 업캐스팅과 다운캐스팅, instanceof 연산자


캐스팅(casting)이란 타입 변환을 말한다.<br>
자바에서 클래스에 대한 캐스팅은<br>
업캐스팅(upcasting)과 다운캐스팅(downcasting)으로 나뉜다.<br>


### 업캐스팅(upcasting)


서브 클래스는 슈퍼 클래스의 속성을 상속받는다.<br>
그러므로 서브클래스는 슈퍼 클래스로 취급될 수 있다.<br>
생물이 들어가는 박스에 사람이나 동물이 들어갈 수 있고,<br>
사람이나 동물을 생물이라고 불러도 되는 것과 같은 맥락이다.<br>


이와 비슷하게, 서브 클래스 객체가 슈퍼 클래스 타입으로 변환되는 것을<br>
업캐스팅(upcasting)이라고 한다.<br>


```java
class Person {
    String name;
    String id;

    public Person(String name) {
        this.name = name;
    }
}

class Student extends Person {
    String grade;
    String department;

    public Student(String name) {
        super(name);
    }
}

public class UpcastingEx {
    public static void main(String[] args) {
        Person P;
        Student s = new Student("홍길동");
        
        P = s;  //업캐스팅

        System.out.println(P.name); //오류 X

        P.grade = "A";  //컴파일 오류
        P.department = "Com";   //컴파일 오류
    }
}
```


슈퍼 클래스의 레퍼런스 P가 서브 클래스 객체를 가리키도록<br>
치환되는 것이 바로 업캐스팅이다.<br>


하지만 P가 Student 객체를 가리키고 있더라도,<br>
P로는 Person 클래스의 멤버에만 접근할 수 있다.<br>
Student 클래스의 멤버에는 접근이 불가하다.<br>
P는 Person 타입이기 때문이다.<br>


반면, 레퍼런스 s를 이용하면 Student 멤버 및 Person 멤버까지<br>
모두 접근이 가능하다.<br>


그리고 업캐스팅은 명시적 타입 변환을 하지 않아도 된다.<br>


```java
P = (Person)s;  //(Person) 생략 가능
```


### 다운캐스팅(downcasting)


업캐스팅된 서브 클래스 객체는 자신의 고유한 속성을 잃어버리는 것이 아니다.<br>
잠시 속성이 가려져 있을 뿐이다.<br>
업캐스팅된 것을 다시 원래대로 되돌리는 것을 다운캐스팅(downcasting)이라고 한다.<br>


```java
public class DowncastingEx {
    public static void main(String[] args) {
        Person P = new Student("홍길동");   //업캐스팅 발생
        Student s;

        s = (Student)P; //다운캐스팅

        System.out.println(s.name); //오류 없음
        s.grade = "A";  //오류 없음
    }
}
```


다운캐스팅을 통해 레퍼런스 s는 P가 가리키던 Student 객체를<br>
다시 가리키게 되었고, s를 통해 Student 객체 전체를 접근할 수 있게 되었다.<br>


다운캐스팅은 업캐스팅과 달리 명시적으로 타입 변환을 지정해야 한다.<br>


```java
s = (Student)P; //(Student)의 타입 변환을 반드시 지정
```


> 단, 업캐스팅된 객체의 실제 타입이 서브 클래스가 아닐 경우,<br>
다운캐스팅을 시도하면 실행 시 오류(ClassCastException)가 발생한다.


### instanceof 연산자와 객체 구별


업캐스팅을 한 경우 레퍼런스가 가리키는 객체의<br>
실제 클래스 타입을 구분하기 어렵다.<br>


만약 다음과 같은 코드와 상속 관계가 있다고 하자.<br>


```java
Person P = new Person();
Person P = new Student();   //업캐스팅
Person P = new Professor(); //업캐스팅
```


![상속 예시](/assets/images/상속%20예시2.PNG)<br>


Person 타입의 레퍼런스는 Person과 자식 클래스들의 타입 객체를<br>
모두 가리킬 수 있기 때문에, 실행 중 P가 가리키는<br>
실제 클래스 타입이 무엇인지 구별할 방법이 필요하다.<br>


이때 사용하는 것이 instanceof 연산자이다.<br>
instanceof 연산자는 이항 연산자로서 다음과 같이 사용된다.<br>


```java
객체레퍼런스 instanceof 클래스 타입
```


instanceof 연산자는 '레퍼런스'가 가리키는 객체가<br>
해당 '클래스 타입'이면 true, 아니면 false로 처리한다.<br>


```java
Person P = new Professor();

System.out.println(P instanceof Person);     //true
System.out.println(P instanceof Student);    //false
System.out.println(P instanceof Researcher); //true
System.out.println(P instanceof Professor);  //true
```


상속 관계 이미지를 보면, Professor 타입의 객체는<br>
곧, Person 타입, Researcher 타입이라고도 할 수 있기 때문에 true이지만<br>
Student를 상속받진 않았기 때문에 false를 반환한다.<br>


참고로 instanceof는 클래스에만 적용되므로 다음은 오류이다.<br>


```java
if(3 instanceof int)    //문법 오류
```






## 5. 메소드 오버라이딩


메소드 오버라이딩(method overriding)이란<br>
서브 클래스에서 슈퍼 클래스에 선언된 메소드를 재정의하는 것이다.<br>


이때, 서브 클래스에서 오버라이딩한 메소드는<br>


● 메소드 이름<br>

● 매개변수의 타입, 개수, 순서<br>

● 리턴 타입<br>

이 모두가 슈퍼 클래스의 메소드와 같아야 한다.<br>


다음과 같은 부모 자식 클래스가 있다고 하자.<br>


```java
class A {
    void f() {
        System.out.println("A의 f() 호출");
    }
}

class B extends A {
    void f() {
        System.out.println("B의 f() 호출");
    }
}
```


