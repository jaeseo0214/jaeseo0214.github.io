---
layout: single
title: "Java Chapter 7 – 상속"
date: 2025-12-14
categories:
  - Java
  - java_grammer
tags: [Java, 문법]
author_profile: true
read_time: true
comments: true
share: true
related: true
sidebar:
  nav: "categories_sidebar"
---


# Java의 상속


개발을 하다 보면 여러 클래스를 작성하면서 동일한 기능을 가진 메소드를<br>
각 클래스마다 작성하게 되는 경우가 있다.<br>
이때 해당 메소드에 문제가 발생하면 모든 클래스를 하나하나 수정해야 하므로<br>
유지보수가 어려워진다.<br>


이처럼 동일한 코드가 여러 클래스에 중복되는 문제를 해결하기 위해<br>
자바에서는 상속(Inheritance)을 제공한다.<br>


상속을 이용하면 공통 기능을 부모 클래스에 정의하고,<br>
자식 클래스에서는 이를 재사용하거나 확장할 수 있다.<br>






## 1. 상속 선언


자바에서 상속 선언은 extends 키워드를 사용한다.<br>
상속하는 클래스(부모 클래스)를 슈퍼 클래스(super class),<br>
상속받는 클래스(자식 클래스)를 서브 클래스(sub class)라고 부른다.<br>


```java
class Animal{
    String name;
}

class Dog extends Animal{
    void bark(){
        System.out.println(name + "멍멍");
    }
}
```


위 예제는 부모 클래스 Animal을 상속받은 자식 클래스 Dog가<br>
부모 클래스의 필드 name 을 그대로 사용하고,<br>
bark() 메소드를 추가로 정의한 예시이다.<br>


```java
class Animal{
    String name;
    private int age;

    public int getAge(){
        return age;
    }
}

class Dog extends Animal{
    void bark(){
        System.out.println(getAge() + "살 " + name + "은 멍멍");
    }
}
```


위의 예시는 private 필드를 추가한 상속 예시이다.<br>
자식 클래스라 하더라도 부모 클래스의 private 멤버에는 직접 접근할 수 없다.<br>
따라서 private 필드에 접근하기 위해서는 <br>
부모 클래스가 제공하는 메소드를 통해 간접적으로 접근해야 한다.<br>


```java
Dog dog = new Dog();

dog.name = "바둑이";
dog.age = 1;        //컴파일 오류 -> private 필드는 클래스 내부에서만 접근 가능
```


또한 객체를 통해 외부에서  private 필드를 접근하는 것도 불가능하다.<br>


자바 상속은 다음과 같은 특징들을 가진다.<br>


첫째, 자바에서는 클래스 다중 상속을 지원하지 않는다.<br>
다중 상속은 여러 가지 문제점을 가지고 있기 때문이다.<br>


둘째, 자바의 모든 클래스는 자바에서 제공하는 Object 클래스를<br>
자동으로 상속받도록 컴파일된다. 위의 예시에서 Animal 클래스는<br>
아무것도 상속받고 있지 않지만 컴파일러에 의해 Object 클래스를<br>
상속받는다. Object 클래스는 슈퍼 클래스를 가지지 않는 유일한 클래스이다.<br>
(Object 클래스의 경로명은 java.lang.Object 이다.)<br>






## 2. 슈퍼 클래스의 디폴트 멤버에 대한 서브 클래스의 접근


자바의 접근 지정자 4개 중 디폴트 접근 지정과 protected 접근 지정에 대해 알아보자.<br>


### 디폴트 접근 지정


접근 지정이 선언되어 있지 않을 때를 디폴트 접근 지정이라고 부르며,<br>
디폴트 멤버는 동일한 패키지의 클래스들에게만 접근이 허용된다.<br>
만약 서브 클래스가 슈퍼 클래스와 다른 패키지에 있다면,<br>
슈퍼 클래스의 디폴트 멤버들에 접근이 불가능하다.<br>


### protected 접근 지정


슈퍼 클래스의 protected 멤버는 다음 두 가지 경우에 접근이 허용된다.<br>
1. 같은 패키지에 속한 모든 클래스<br>
2. 상속되는 서브 클래스(같은 패키지, 다른 패키지 상관 없음)<br>


아래는 슈퍼 클래스 멤버에 대한 접근 지정을 표로 정리한 것이다.<br>


![접근 지정 정리표](/assets/images/접근%20지정%20정리표.jpg)<br>






## 3. 상속과 생성자


서브 클래스와 슈퍼 클래스의 객체가 생성될 때,<br>
두 클래스의 생성자는 모두 실행된다.<br>

이때 먼저 실행되는 것은 항상 슈퍼 클래스의 생성자이다.<br>

비록 서브 클래스의 생성자가 먼저 호출되는 것처럼 보이더라도,<br>
컴파일러는 슈퍼 클래스의 생성자를 먼저 호출한 뒤<br>
서브 클래스의 생성자 코드를 실행하도록 컴파일한다.<br>

이는 슈퍼 클래스가 먼저 초기화된 후,<br>
이를 기반으로 서브 클래스가 초기화되어야 하기 때문이다.<br>


### ●슈퍼 클래스 기본 생성자의 묵시적 선택


개발자의 명시적 지시가 없으면, 서브 클래스 생성자의 매개변수 유무와 상관없이<br>
슈퍼 클래스의 생성자로 기본 생성자가 선택된다.<br>
이 선택은 자바 컴파일러에 의해 묵시적으로 이루어진다.<br>


```java
class A{
    public A() {
        System.out.println("생성자 A");
    }
    public A(int x) {
        .......
    }
}

class B extends A{
    public B() {
        System.out.println("생성자 B");
    }
}

public class ConstructorEx {
    public static void main(String[] args) {
        B b;
        b = new B();    //생성자 호출
    }
}
```


위의 예시 코드에서 b = new B(); 로 생성자를 호출하면,<br><br>


생성자 호출 순서는 다음과 같다.<br>


1. 생성자 B() 호출
2. 생성자 A() 호출
3. 생성자 A() 실행
4. 생성자 B() 실행


그러므로 프로그램 실행 결과는<br>


```java
생성자 A
생성자 B
```


가 된다.<br>
서브 클래스의 기본 생성자에 대해 컴파일러는 자동으로<br>
슈퍼 클래스의 기본 생성자와 짝을 맺은 것이다.<br><br>


그렇다면 클래스 A에 기본 생성자가 없이<br>
A(int x) 생성자만 선언되어 있다면 어떻게 될까?<br>

이 경우 B()와 짝을 이룰 A() 생성자를 찾을 수 없기 때문에<br>
컴파일 오류가 발생한다.<br>


이제 서브 클래스의 매개 변수를 가진 생성자의 경우를 살펴보겠다.<br>
이 경우에도 개발자의 특별한 지시가 없다면,<br>
슈퍼 클래스의 기본 생성자가 호출된다.<br>


```java
class A{
    public A() {
        System.out.println("생성자 A");
    }
    public A(int x) {
        System.out.println("매개 변수 생성자 A");
    }
}

class B extends A{
    public B() {
        System.out.println("생성자 B");
    }
    public B(int x) {
        System.out.println("매개 변수 생성자 B");
    }
}

public class ConstructorEx {
    public static void main(String[] args) {
        B b;
        b = new B(5);    //생성자 호출
    }
}
```


위의 예시 코드에서 b = new B(5); 로 생성자를 호출하면,<br><br>


생성자 호출 순서는 다음과 같다.<br>


1. 생성자 B(int x) 호출
2. 생성자 A() 호출
3. 생성자 A() 실행
4. 생성자 B(int x) 실행


그러므로 프로그램 실행 결과는<br>


```java
생성자 A
매개 변수 생성자 B
```


가 된다.<br>


### ●super()를 이용한 명시적 슈퍼 클래스 생성자 선택


super()를 이용하면, 서브 클래스의 생성자에서 슈퍼 클래스의 생성자를<br>
명시적으로 선택할 수 있다.<br>
super()는 슈퍼 클래스 생성자의 호출을 의미한다.<br>


```java
class A{
    public A() {
        System.out.println("생성자 A");
    }
    public A(int x) {
        System.out.println("매개 변수 생성자 A" + x);
    }
}

class B extends A{
    public B() {
        System.out.println("생성자 B");
    }
    public B(int x) {
        super(x);
        System.out.println("매개 변수 생성자 B" + x);
    }
}

public class ConstructorEx {
    public static void main(String[] args) {
        B b;
        b = new B(5);    //생성자 호출
    }
}
```


위의 예시 코드에서 b = new B(5); 로 생성자를 호출하면,<br><br>


생성자 호출 순서는 다음과 같다.<br>


1. 생성자 B(int x) 호출
2. super(x) 로 인한 생성자 A(int x) 호출
3. 생성자 A(int x) 실행
4. 생성자 B(int x) 실행


그러므로 프로그램 실행 결과는<br>


```java
매개 변수 생성자 A5
매개 변수 생성자 B5
```


가 된다.<br>


> 주의할 점은 super()의 호출은 반드시 생성자의 첫 라인에 와야 한다.<br>






## 4. 업캐스팅과 다운캐스팅, instanceof 연산자


캐스팅(casting)이란 타입 변환을 말한다.<br>
자바에서 클래스에 대한 캐스팅은<br>
업캐스팅(upcasting)과 다운캐스팅(downcasting)으로 나뉜다.<br>


### 업캐스팅(upcasting)


서브 클래스는 슈퍼 클래스의 속성을 상속받는다.<br>
그러므로 서브클래스는 슈퍼 클래스로 취급될 수 있다.<br>
생물이 들어가는 박스에 사람이나 동물이 들어갈 수 있고,<br>
사람이나 동물을 생물이라고 불러도 되는 것과 같은 맥락이다.<br>


이와 비슷하게, 서브 클래스 객체가 슈퍼 클래스 타입으로 변환되는 것을<br>
업캐스팅(upcasting)이라고 한다.<br>


```java
class Person {
    String name;
    String id;

    public Person(String name) {
        this.name = name;
    }
}

class Student extends Person {
    String grade;
    String department;

    public Student(String name) {
        super(name);
    }
}

public class UpcastingEx {
    public static void main(String[] args) {
        Person P;
        Student s = new Student("홍길동");
        
        P = s;  //업캐스팅

        System.out.println(P.name); //오류 X

        P.grade = "A";  //컴파일 오류
        P.department = "Com";   //컴파일 오류
    }
}
```


슈퍼 클래스의 레퍼런스 P가 서브 클래스 객체를 가리키도록<br>
치환되는 것이 바로 업캐스팅이다.<br>


하지만 P가 Student 객체를 가리키고 있더라도,<br>
P로는 Person 클래스의 멤버에만 접근할 수 있다.<br>
Student 클래스의 멤버에는 접근이 불가하다.<br>
P는 Person 타입이기 때문이다.<br>


반면, 레퍼런스 s를 이용하면 Student 멤버 및 Person 멤버까지<br>
모두 접근이 가능하다.<br>


그리고 업캐스팅은 명시적 타입 변환을 하지 않아도 된다.<br>


```java
P = (Person)s;  //(Person) 생략 가능
```


### 다운캐스팅(downcasting)


업캐스팅된 서브 클래스 객체는 자신의 고유한 속성을 잃어버리는 것이 아니다.<br>
잠시 속성이 가려져 있을 뿐이다.<br>
업캐스팅된 것을 다시 원래대로 되돌리는 것을 다운캐스팅(downcasting)이라고 한다.<br>


```java
public class DowncastingEx {
    public static void main(String[] args) {
        Person P = new Student("홍길동");   //업캐스팅 발생
        Student s;

        s = (Student)P; //다운캐스팅

        System.out.println(s.name); //오류 없음
        s.grade = "A";  //오류 없음
    }
}
```


다운캐스팅을 통해 레퍼런스 s는 P가 가리키던 Student 객체를<br>
다시 가리키게 되었고, s를 통해 Student 객체 전체를 접근할 수 있게 되었다.<br>


다운캐스팅은 업캐스팅과 달리 명시적으로 타입 변환을 지정해야 한다.<br>


```java
s = (Student)P; //(Student)의 타입 변환을 반드시 지정
```


> 단, 업캐스팅된 객체의 실제 타입이 서브 클래스가 아닐 경우,<br>
다운캐스팅을 시도하면 실행 시 오류(ClassCastException)가 발생한다.


### instanceof 연산자와 객체 구별


업캐스팅을 한 경우 레퍼런스가 가리키는 객체의<br>
실제 클래스 타입을 구분하기 어렵다.<br>


만약 다음과 같은 코드와 상속 관계가 있다고 하자.<br>


```java
Person P = new Person();
Person P = new Student();   //업캐스팅
Person P = new Professor(); //업캐스팅
```


![상속 예시](/assets/images/상속%20예시2.PNG)<br>


Person 타입의 레퍼런스는 Person과 자식 클래스들의 타입 객체를<br>
모두 가리킬 수 있기 때문에, 실행 중 P가 가리키는<br>
실제 클래스 타입이 무엇인지 구별할 방법이 필요하다.<br>


이때 사용하는 것이 instanceof 연산자이다.<br>
instanceof 연산자는 이항 연산자로서 다음과 같이 사용된다.<br>


```java
객체레퍼런스 instanceof 클래스 타입
```


instanceof 연산자는 '레퍼런스'가 가리키는 객체가<br>
해당 '클래스 타입'이면 true, 아니면 false로 처리한다.<br>


```java
Person P = new Professor();

System.out.println(P instanceof Person);     //true
System.out.println(P instanceof Student);    //false
System.out.println(P instanceof Researcher); //true
System.out.println(P instanceof Professor);  //true
```


상속 관계 이미지를 보면, Professor 타입의 객체는<br>
곧, Person 타입, Researcher 타입이라고도 할 수 있기 때문에 true이지만<br>
Student를 상속받진 않았기 때문에 false를 반환한다.<br>


참고로 instanceof는 클래스에만 적용되므로 다음은 오류이다.<br>


```java
if(3 instanceof int)    //문법 오류
```






## 5. 메소드 오버라이딩


메소드 오버라이딩(method overriding)이란<br>
서브 클래스에서 슈퍼 클래스에 선언된 메소드를 재정의하는 것이다.<br>


이때, 서브 클래스에서 오버라이딩한 메소드는<br>


● 메소드 이름<br>

● 매개변수의 타입, 개수, 순서<br>

● 리턴 타입<br>

이 모두가 슈퍼 클래스의 메소드와 같아야 한다.<br>


다음과 같은 부모 자식 클래스가 있다고 하자.<br>


```java
class A {
    void f() {
        System.out.println("A의 f() 호출");
    }
}

class B extends A {
    @Override
    void f() {  //A의 f() 오버라이딩
        System.out.println("B의 f() 호출");
    }
}
```


그리고 B b = new B()로 객체를 하나 생성한다.<br>
이때, b 객체에는 A의 f()를 오버라이딩한 B의 f()만이 유효하며,<br>
실행 시점에는 B의 f()만 호출된다.<br>


오버라이딩의 목적은 다형성 실현에 있다.<br>


```java
class Shape {
    public void draw() {
        System.out.println("Shape");
    }
}

class Line extends Shape {
    @Override
     public void draw() {
        System.out.println("Line");
    }
}

class Rect extends Shape {
    @Override
     public void draw() {
        System.out.println("Rect");
    }
}

class Circle extends Shape {
    @Override
     public void draw() {
        System.out.println("Circle");
    }
}
```


위와 같이 Shape 클래스를 상속받아<br>
부모 클래스의 draw() 메소드를 각 클래스의 특성에 맞게 재정의할 수 있다.<br>


즉, 상속을 통해 하나의 같은 이름의 메소드에 대해<br>
서로 다른 내용을 구현함으로써 객체 지향의 다형성을 실현할 수 있다.<br>


### 동적 바인딩


동적 바인딩이란 실행할 메소드를 컴파일 시점에 결정하는 것이 아니라,<br>
실행 시점에 객체의 실제 타입을 기준으로 결정하는 것을 말한다.<br>


자바에서는 동적 바인딩을 통해<br>
오버라이딩된 메소드가 항상 객체의 실제 타입에 맞게 실행되도록 보장한다.<br>


```java
class SuperObj {
    public void paint() {
        draw();
    }
    
    public void draw() {
        System.out.println("Super Object");
    }
}

class SubObj extends SuperObj {
    @Override
    public void draw() {
        System.out.println("Sub Object");
    }
}
```


이렇게 두 클래스가 있을 때,


```java
SuperObj a = new SuperObj();
a.paint();
```

의 결과는 SuperObj의 draw()를 호출한다.<br>


하지만 아래의 경우는 다른 결과가 나온다.<br>


```java
SuperObj b = new SubObj();
b.paint();
```


이 경우 paint() 메소드 자체는 SuperObj의 것이지만,<br>
그 내부에서 호출되는 draw()는<br>
SuperObj의 draw()를 오버라이딩한 SubObj의 draw()가 호출된다.<br>


이는 실행 시점에 메소드가 결정되는 동적 바인딩이 일어난 결과이다.<br>


### 오버라이딩과 super 키워드


super 키워드는 오버라이딩된 상황에서도<br>
슈퍼 클래스의 멤버를 명시적으로 지정하여 접근할 수 있게 해준다.<br>

일반적으로 자바에서는 오버라이딩된 메소드가 동적 바인딩에 의해<br>
객체의 실제 타입을 기준으로 호출되지만,<br>
super를 사용하면 이러한 동적 바인딩을 우회하여<br>
슈퍼 클래스의 메소드를 직접 호출할 수 있다.<br>

super는 자바에서 자동으로 제공되는 슈퍼 클래스에 대한 참조이며,<br>
필드와 메소드 모두에 접근할 수 있다.<br>


```java
class SuperObj {
    protected String name;

    public void paint() {
        draw();
    }
    
    public void draw() {
        System.out.println(name);
    }
}

public class SubObj extends SuperObj {
    protected String name;

    @Override
    public void draw() {
        name ="Sub";    //SubObj의 name
        super.name = "Super";   //SuperObj의 name
        super.draw();   //SuperObj의 draw() -> 정적 바인딩
        System.out.println(name);   //SubObj의 name 출력
    }

    public static void main(String [] args) {
        SuperObj b = new SubObj();

        b.paint();
    }
}
```


결과적으로 위 코드의 실행결과는


```java
Super
Sub
```


이 된다.<br>


### 오버라이딩(Overriding)과 오버로딩(Overloading)


오버라이딩은 슈퍼 클래스에 선언된 메소드를<br>
서브 클래스에서 재정의하는 것을 말한다.<br>

오버로딩은 한 클래스 내에서<br>
매개변수의 타입, 개수, 순서가 다른 메소드를<br>
같은 이름으로 여러 개 정의하는 것을 말한다.<br>


아래 표는 둘의 차이점을 정리한 것이다.<br>


![오버라이딩 오버로딩 차이점](/assets/images/오버라이딩%20오버로딩%20차이.jpg)<br>






## 6. 추상 클래스(Abstract class)


추상 메소드(abstract method)는 다음과 같이 abstract 키워드와 함께 원형만 선언되고,<br>
코드는 작성되지 않은 메소드이다.<br>


```java
abstract public String getName();   //추상 메소드
```


추상 클래스란 추상 메소드를 가질 수 있는 클래스이다.<br>
추상 클래스는 abstratct 키워드로 선언한다.<br>


### 추상 클래스 선언


추상 클래스는 추상 메소드를 한 개 이상 가지고 선언될 수 있고,<br>
추상 메소드 없이 선언될 수도 있다.<br>


하지만 추상 메소드를 가진 클래스는 반드시 추상 클래스로 선언되어야 하며,<br>
상속 받은 클래스가 일반 클래스라면 모든 추상 메소드를 구현해야 한다.<br>


다음은 여러 가지 경우의 예시이다.<br>


```java
//추상 메소드를 가진 추상 클래스
abstract class Shape {
    public Shape() { ... }
    public void edit() { ... }

    abstract public void draw();    //추상 메소드 선언
}

//추상 메소드가 없는 추상 클래스
abstract class JComponent {
    String name;

    public void load(String name) {
        this.name = name;
    }
}

//추상 클래스의 상속
abstract class A {
    abstract public int add(int x, int y);  //추상 메소드
}

abstract class B extends A {    //추상 클래스 -> 추상 메소드 구현 필요 없음
    public void show() {
        System.out.println("B");
    }
}

class C extends A {     //일반 클래스 -> 추상 메소드를 구현해야 함
    @Override
    public int add(int x, int y) {
        return x + y;
    }
}
```


여기서 중요한 점은, 클래스 A를 상속받은 B와 C의 차이점이다.<br>
B는 추상 클래스로 선언되었기 때문에 A의 add() 메소드를 구현하지 않아도 된다.<br>
하지만 C는 정상 클래스로 선언되었기 때문에 반드시 A의 add() 메소드를 구현해야 한다.<br>


또한 추상 클래스는 인스턴스(객체)를 생성할 수 없다.<br>
실행 코드가 없는 미완성 상태의 추상 메소드가 존재할 수 있기 때문이다.<br>
따라서 A와 B는 인스턴스(객체)를 생성할 수 없지만, C는 생성이 가능하다.<br>


### 추상 클래스의 목적


추상 클래스는 인스턴스(객체) 생성을 목적으로 하지 않으며,<br>
상속을 위한 슈퍼 클래스로 활용된다.<br>
추상 클래스는 추상 메소드를 통해 서브 클래스가 구현해야 할<br>
메소드의 원형을 정의함으로써 구현 규칙을 제시하고,<br>
서브 클래스의 다형성을 실현한다.<br>






## 7. 인터페이스(Interface)


자바에서 인터페이스란, 클래스가 반드시 구현해야 할 메소드의 규격을 정의하여<br>
소프트웨어를 규격화된 모듈로 만드는 것이다.<br>


### 인터페이스 선언과 상속


자바의 인터페이스는 다음과 같이 interface 키워드를 사용하여 작성한다.<br>


```java
interface PhoneInterface {  //인터페이스 선언
    public static final int TIMEOUT = 10000;    //상수 필드 -> public static final 생략 가능
    public abstract void sendCall();            //추상 메소드 -> public abstract 생략 가능
    public abstract void receiveCall();         //추상 메소드 -> public abstract 생략 가능
    public default void printLogo() {           //default 메소드 -> public 생략 가능
        System.out.println("*** Phone ***");
    }
}
```


인터페이스는 5종류의 멤버로 구성되며,<br>
일반적인 필드(인스턴스 변수)는 선언할 수 없다.<br>

1. 상수 -> public static final 속성, 속성 생략 가능

2. 추상 메소드 -> 속성이 public abstract로 정해져 있음, 생략 가능

3. default 메소드 -> (Java 8부터)의 접근 지정은 public으로 고정

4. private 메소드 -> (Java 9부터)는 인터페이스 내의 다른 메소드에서만 호출 가능

5. static 메소드 -> (Java 9부터) 접근 지정 생략 시 public이며 private로 지정 가능


default, private, static 메소드는 반드시 메소드 구현을 가져야 한다.<br>


인터페이스는 객체를 생성할 수 없으며,<br>
다른 인터페이스를 상속하는 것이 가능하다.<br>
상속을 통해 기존 인터페이스에 새로운 규격을 추가할 수 있으며,<br>
클래스 상속과 마찬가지로 extends 키워드를 사용한다.<br>


다음은 인터페이스 상속의 예시이다.<br>


```java
interface MobilePhoneInterface extends PhoneInterface {
    void sendSMS();     //추상 메소드
    void receiveSMS();  //추상 메소드
}
```


MobilePhoneInterface는 PhoneInterface의 멤버를 모두 상속받아<br>
총 6개의 멤버를 가지게 된다.<br>


또한 인터페이스는 다음과 같이 콤마(,)로 연결하여<br>
2개 이상의 인터페이스를 다중 상속할 수 있다.<br>


```java
interface MusicPhoneInterface extends PhoneInterface, MP3Interface {
    .......
}
```


### 인터페이스 구현


인터페이스 구현이란 인터페이스의 모든 추상 메소드를<br> 
구현한 클래스를 작성하는 것을 말한다.<br>
implements 키워드를 사용한다.<br>


다음은 PhoneInterface를 구현한 SamsungPhone 클래스를 작성한 예시이다.<br>


```java
class SamsungPhone implements PhoneInterface {
    //추상 메소드 구현
    public void sendCall() {
        System.out.println("전화를 거는 중입니다.");
    }

    public void receiveCall() {
        System.out.println("전화가 왔습니다.");
    }

    //추가 메소드 작성
    public void flash() {
        System.out.println("불이 켜졌습니다.");
    }
}
```


PhoneInterface의 추상 메소드는 반드시 구현해야 하며,<br>
default 메소드는 구현하지 않아도 그대로 상속받아 사용할 수 있다.<br>


-----------------------------------------------------------------------<br>


지금까지 자바의 상속 대해 공부해 보았다.<br>
다음 글에서는 자바의 모듈과 패키지, 그리고 패키지 활용에 대해서 공부해 보겠다.<br>


---
※ 본 글은 개인 학습을 목적으로 「명품 자바 에센셜」(황기태 지음, 생능출판)을 참고하여 작성하였습니다.