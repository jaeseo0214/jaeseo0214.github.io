---
layout: single
title: "Java Chapter 11 – 자바의 이벤트 처리"
date: 2026-01-09
categories:
  - Java
  - java_grammer
tags: [Java, 문법]
author_profile: true
read_time: true
comments: true
share: true
related: true
sidebar:
  nav: "categories_sidebar"
---


# 자바의 이벤트 처리





## 1. 이벤트 기반 GUI 프로그래밍


이벤트 기반 프로그래밍(Event Driven Programming)은<br>
이벤트 발생에 의해 프로그램 실행 흐름이 결정되는<br>
프로그래밍 패러다임이다.<br>

이벤트는 키 입력, 마우스 클릭, 마우스 드래그 등<br>
사용자의 액션이나, 외부 장치로부터의 입력,<br>
네트워크를 통한 다른 컴퓨터로부터의 데이터 수신,<br>
다른 스레드나 프로그램으로부터의 메시지 수신 등에 의해 발생한다.<br>

이벤트 기반 응용프로그램은<br>
각 이벤트를 처리하는 이벤트 리스너(event listener) 코드를 보유하고,<br>
이벤트가 발생할 때마다 해당 리스너가 처리하게 한다.<br>

일반적인 GUI 응용프로그램은<br>
이벤트 기반 프로그래밍 기법으로 작성한다.<br>

자바에서는 AWT나 스윙을 이용하여<br>
이벤트 기반 GUI 응용프로그램을 작성할 수 있다.<br>

특히 스윙 패키지는 GUI와 더불어 강력한 이벤트 플랫폼을 제공한다.<br>


### 자바의 이벤트 기반 GUI 응용프로그램 구조


예를 들어 스윙 응용프로그램에<br> 
JButton 하나가 있다고 가정해 보자.<br>
이 때 이 버튼이 클릭되어<br>
이벤트가 발생하고 처리되는 과정은<br>
다음과 같다.<br>


1. 사용자가 마우스로 화면의 JButton 클릭<br>

2. 버튼 클릭은 마우스 드라이버, 운영체제를 거쳐<br>
자바 가상 기계에 전달됨<br>

3. 자바 가상 기계는 이벤트 큐(Event Queue)를 통해<br>
이벤트 분배 스레드(Event Dispatch Thread, EDT)에<br>
마우스 클릭 정보를 전달함<br>

4. 이벤트 분배 스레드는 이벤트 큐로부터<br>
이벤트 객체를 꺼내어 처리한다.<br>
이 이벤트 객체에는 이벤트 종류, 이벤트 소스,<br>
좌표 등의 정보가 담겨 있다.<br>
이벤트 객체 내에 저장되는 정보 중,<br>
특별히 이벤트를 발생시킨 컴포넌트를<br>
이벤트 소스(Event source)라고 부름.<br>

5. 이벤트 분배 스레드는 JButton에 등록된<br>
이벤트 리스너(ActionListener 등)의<br>
이벤트 처리 메서드를 호출한다.<br>

6. 이벤트 분배 스레드는 이벤트 리스너로부터 리턴한 후,<br>
다음 이벤트 발생을 기다림<br>


다음은 이벤트 관련 용어를 정리한 것이다.<br>


[

  * 이벤트 소스 - 이벤트를 발생시킨 GUI 컴포넌트<br>

  * 이벤트 객체 - 발생한 이벤트에 대한 여러 정보<br>

  * 이벤트 리스너 - 사용자가 작성하며, 이벤트를 처리하는 자바 프로그램 코드로,<br>
    보통 리스너 인터페이스를 구현한 클래스로 작성<br>

  * 이벤트 분배 스레드 - 무한 루프를 돌면서 이벤트 큐로부터 이벤트 객체를 꺼내<br>
    이벤트 리스너를 찾아 호출하는 스레드, 자바 플랫폼에서 제공<br>

]






## 2. 이벤트 객체


이벤트 객체는 현재 발생한 이벤트에 관한<br>
여러 정보를 가진 객체로, 이벤트 리스너에게 전달된다.<br>

모든 이벤트 객체는 java.util.EventObject 클래스를 상속받는다.<br>

또한 이벤트 객체는<br>
사용자가 이벤트에 대한 정보를 얻을 수 있도록<br>
여러 메소드를 제공한다.<br>

그 중 모든 이벤트 객체에 공통적으로 있으면서<br>
가장 많이 사용되는 메소드는,<br>
어떤 컴포넌트에 이벤트가 발생했는지<br>
이벤트 소스를 알려주는 getSource() 메소드이다.<br>

getSource() 메소드는 Object를 리턴하므로<br>
캐스팅 해서 사용해야 하는데,<br>
만약 버튼 컴포넌트에서 이벤트가 발생한 경우라면,<br>
다음과 같이 캐스팅 하면 된다.<br>


```java
JButton b = (JButton)event.getSource(); // b 는 이벤트가 발생한 버튼의 레퍼런스
```


다음은 이벤트 객체와 이벤트 소스,<br>
그리고 이벤트가 발생하는 경우를<br>
정리한 표이다.<br>


![이벤트 관련 표](/assets/images/이벤트%20관련%20표.png)


여기서 MouseEvent의 이벤트 소스는 Component이므로,<br>
Component를 상속받은 GUI 컴포넌트는<br>
마우스 이벤트의 대상이 될 수 있다.<br>

즉 Component를 상속받은 GUI 컴포넌트는,<br>
사용자가 마우스를 조작하면<br>
해당 컴포넌트가 마우스 이벤트를 받을 수 있는 상태일 경우,<br>
MouseEvent가 발생한다.<br>






## 3. 사용자 이벤트 리스너 작성


이벤트 리스너란 이벤트를 처리하는 자바 프로그램 코드로,<br>
일반적으로 클래스로 작성된다.<br>

자바는 이벤트 리스너 인터페이스(interface)를 제공하며,<br>
개발자는 이 리스너 인터페이스를 구현(implements)하고,<br>
추상 메소드를 구현하여 이벤트 리스너를 작성한다.<br>

다음은 이벤트 리스너 인터페이스를 정리한 표이다.<br>


![이벤트 리스너 인터페이스](/assets/images/이벤트%20리스너%20인터페이스.png)


### 이벤트 리스너 작성 기초


이벤트 리스너는 전형적으로 다음 3단계로 작성한다.<br>


1. 이벤트와 이벤트 리스너 선택 - 목적에 필요한 이벤트와<br>
리스너 인터페이스 선택<br>

2. 이벤트 리스너 클래스 작성 - 리스너 인터페이스를 구현하는<br>
클래스를 작성하고, 추상 메소드 모두 구현<br>

3. 이벤트 리스너 등록 - 이벤트를 받을 GUI 컴포넌트에 이벤트 리스너 등록<br>


먼저 1번 과정에서 이벤트는 Action 이벤트,<br>
이벤트 리스너는 ActionListener, 이벤트 객체는 ActionEvent로 정하자.<br>


다음 2번 과정에서 이벤트 리스너를 작성해보자.<br>
ActionListener 인터페이스를 구현한<br>
MyActionListener 클래스를 선언하고,<br>
추상 메소드 actionPerformed(ActionEvent e)를<br>
다음과 같이 구현한다.<br>


```java
class MyActionListener implements ActionListener {
    public void actionPerformed(ActionEvent e) {    // Action 이벤트가 발생했을 때 호출되는 메소드
        JButton b = (JButton)e.getSource(); // 사용자가 클릭한 버튼 알아내기

        if(b.getText().equals("Action")) {  // 버튼의 현재 문자열이 "Action"인지 비교
            b.setText("액션");  // JButton 의 setText() 를 호출하여 문자열 변경
        }
        else {
            b.setText("Action");    // JButton 의 setText() 를 호출하여 문자열 변경
        }
    }
}
```


마지막으로 이벤트 리스너가 작동되기 위해서는<br>
MyActionListener 클래스의 객체를<br>
버튼 컴포넌트에 등록해야 하므로,<br>
다음과 같이 등록해 준다.<br>


```java
MyActionListener listener = new MyActionListener();  // 리스너 인스턴스 생성
btn.addActionListener(listener);  // 리스너 등록
```


일반적으로 컴포넌트에 이벤트 리스너를 등록할 때,<br>
다음과 같이 등록한다.<br>


```java
component.addXXXListener(listener);
```


이벤트에 따라 addActionListener(),<br>
addMouseListener() 등으로 작성하면 된다.<br>


### 이벤트 리스너 작성 1 - 독립 클래스로 Action 이벤트 리스너 만들기


버튼을 클릭할 때마다 문자열이 바뀌는<br>
프로그램을 작성해 보자.<br>


```java
public class IndepClassListener extends JFrame {

	public IndepClassListener() {
		setTitle("독립 클래스로 Action 이벤트 리스너 만들기");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		Container c = getContentPane();
		c.setLayout(new FlowLayout());

		JButton btn = new JButton("Action");
		btn.addActionListener(new MyActionListener()); // Action 이벤트 리스너 등록

		c.add(btn);

		setSize(250, 130);
		setVisible(true);
	}

	public static void main(String[] args) {
		new IndepClassListener();
	}

}

class MyActionListener implements ActionListener {
	public void actionPerformed(ActionEvent e) {
		JButton b = (JButton) e.getSource(); // 이벤트를 발생시킨 버튼 객체 얻기

		if (b.getText().equals("Action")) { // 버튼의 문자열이 "Action" 인지 비교
			b.setText("액션"); // 버튼의 문자열을 변경
		} else {
			b.setText("Action"); // 버튼의 문자열을 변경
		}
	}
}
```


실행 결과는 다음과 같다.<br>
버튼을 클릭할 때마다 문자열이 바뀐다.<br>


![독립 클래스 이벤트 리스너](/assets/images/독립%20클래스%20이벤트%20리스너.PNG)


### 이벤트 리스너 작성 2 - 내부 클래스로 Action 이벤트 리스너 만들기


이벤트 리스너 클래스는 내부 클래스(inner class)로도 작성할 수 있다.<br>
다음 코드는 이벤트 리스너 작성 1의 코드를<br>
내부 클래스로 작성한 경우이다.<br>

내부 클래스는 자신을 내포한 클래스의 멤버와 같으므로,<br>
MyActionListener는 InnerClassListener 클래스나<br>
슈퍼 클래스인 JFrame의 멤버를 자유롭게 접근할 수 있다.<br>


```java
public class InnerClassListener extends JFrame {

	public InnerClassListener() {
		setTitle("내부 클래스로 Action 이벤트 리스너 만들기");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		Container c = getContentPane();
		c.setLayout(new FlowLayout());

		JButton btn = new JButton("Action");
		btn.addActionListener(new MyActionListener()); // Action 이벤트 리스너 등록

		c.add(btn);

		setSize(250, 130);
		setVisible(true);
	}

	// 내부 클래스로 Action 리스너 작성
	private class MyActionListener implements ActionListener {
		public void actionPerformed(ActionEvent e) {
			JButton b = (JButton) e.getSource(); // 이벤트 소스 버튼 알아내기

			if (b.getText().equals("Action")) { // 버튼의 문자열이 "Action" 인지 비교
				b.setText("액션"); // 버튼의 문자열을 변경
			} else {
				b.setText("Action"); // 버튼의 문자열을 변경
			}

			// InnerClassListener 의 멤버나 JFrame 의 멤버 호출 가능
			InnerClassListener.this.setTitle(b.getText()); // 프레임의 타이틀에 버튼 문자열 출력
		}
	}

	public static void main(String[] args) {
		new InnerClassListener();
	}

}
```


실행 결과는 다음과 같다.<br>
기본적인 동작은 1번 예제와 동일하다.<br>
다만, 버튼을 클릭할 때마다 응용프로그램의 타이틀을<br>
버튼의 문자열로 변경하는 기능이 추가되었다.<br>


![내부 클래스 이벤트 리스너](/assets/images/내부%20클래스%20이벤트%20리스너.PNG)


### 이벤트 리스너 작성 3 - 익명 클래스로 Action 이벤트 리스너 만들기


익명 클래스는 클래스 이름 없이,<br>
클래스 선언과 인스턴스 생성을<br>
하나로 작성하는 방식이다.<br>

익명 클래스를 작성하는 기본 형태는 다음과 같다.<br>


```java
new 익명클래스의 슈퍼클래스(생성자 인자들) {
    .......................
    익명 클래스의 멤버 구현
    .......................
}
```


익명 클래스는 별도의 MyActionListener 클래스를 작성하지 않고도,<br>
ActionListener를 구현하면서<br>
바로 actionPerformed() 메소드를 구현하면 된다.<br>


익명 클래스 또한 일종의 내부 클래스이므로,<br>
외부 클래스의 멤버에 자유롭게 접근할 수 있다.<br>


다음은 익명 클래스를 활용해 이벤트 리스너를 작성한 코드이다.<br>


```java
public class AnonymousClassListener extends JFrame {

	public AnonymousClassListener() {
		setTitle("익명 클래스로 Action 이벤트 리스너 만들기");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		Container c = getContentPane();
		c.setLayout(new FlowLayout());

		JButton btn = new JButton("Action");

		c.add(btn);

		btn.addActionListener(new ActionListener() { // 익명 클래스로 Action 리스너 작성
			public void actionPerformed(ActionEvent e) {
				JButton b = (JButton) e.getSource(); // 이벤트 소스 버튼 알아내기

				if (b.getText().equals("Action")) { // 버튼의 문자열이 "Action" 인지 비교
					b.setText("액션"); // 버튼의 문자열을 변경
				} else {
					b.setText("Action"); // 버튼의 문자열을 변경
				}

				// AnonymousClassListener 의 멤버나 JFrame 의 멤버 호출 가능
				AnonymousClassListener.this.setTitle(b.getText()); // 프레임의 타이틀에 버튼 문자열 출력
			}
		});

		setSize(250, 130);
		setVisible(true);
	}

	public static void main(String[] args) {
		new AnonymousClassListener();
	}

}
```


실행 결과는 다음과 같다.<br>
버튼 클릭 시의 동작은 2번 예제와 동일하다.<br>


![익명 클래스 이벤트 리스너](/assets/images/익명%20클래스%20이벤트%20리스너.PNG)


### 이벤트 리스너 작성 4 - 마우스 이벤트 리스너


컨텐트팬의 아무 위치에서 마우스 버튼을 누르면,<br>
마우스 포인터가 있는 위치로 레이블의 문자열이 이동하는<br>
프로그램을 만들어 보자.<br>

MouseListener 인터페이스를 구현하고,<br>
마우스 버튼이 눌렸을 때 호출되는 mousePressed() 메소드에<br>
동작 코드를 작성하면 된다.<br>

컨텐트팬의 배치관리자를 삭제해야<br>
컴포넌트를 마음대로 이동시킬 수 있다.<br>


```java
public class MouseListenerEx extends JFrame {

	private JLabel la = new JLabel("Java");

	public MouseListenerEx() {
		setTitle("마우스 이벤트 리스너");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		Container c = getContentPane();

		c.addMouseListener(new MyMouseListener()); // 컨텐트팬에 마우스 리스너 등록

		c.setLayout(null); // 컨텐트팬의 배치 관리자 삭제

		la.setSize(50, 30);
		la.setLocation(30, 30);

		c.add(la); // 레이블 삽입

		setSize(300, 300);
		setVisible(true);
	}

	class MyMouseListener implements MouseListener { // Mouse 리스너 구현

		public void mousePressed(MouseEvent e) {
			int x = e.getX(); // 마우스 클릭 좌표 x
			int y = e.getY(); // 마우스 클릭 좌표 y

			la.setLocation(x, y); // 레이블의 위치를 (x,y)로 이동
		}

		public void mouseReleased(MouseEvent e) {
		}

		public void mouseClicked(MouseEvent e) {
		}

		public void mouseEntered(MouseEvent e) {
		}

		public void mouseExited(MouseEvent e) {
		}
	}

	public static void main(String[] args) {
		new MouseListenerEx();
	}

}
```


실행 결과는 다음과 같다.<br>
마우스로 클릭한 부분으로<br>
레이블의 좌표가 이동된다.<br>


![마우스 이벤트 리스너](/assets/images/마우스%20이벤트%20리스너.PNG)






## 4. 어댑터(Adapter) 클래스


리스너 인터페이스를 통해 이벤트 리스너를 구현할 때<br>
리스너 인터페이스의 메소드를 모두 구현해야 하는 부담이 있다.<br>

자바는 이러한 부담을 줄이기 위해<br>
리스너 인터페이스의 추상 메소드를<br>
아무 동작도 하지 않는 빈 메소드로 미리 구현해 둔 클래스를 제공하는데,<br>
이를 어댑터(Adapter) 클래스라고 한다.<br>

다음은 리스너 인터페이스와 대응하는 어댑터 클래스를 정리한 표이다.<br>

※ 모든 이벤트 리스너 인터페이스에 어댑터 클래스가 제공되는 것은 아니다.<br>


![어댑터 클래스](/assets/images/어댑터%20클래스.png)


그럼 어댑터 클래스를 이용해서,<br>
위에서 작성한 마우스 이벤트 리스너 코드를 수정해 보자.<br>


```java
public class MouseAdapterEx extends JFrame {

	private JLabel la = new JLabel("Java");

	public MouseAdapterEx() {
		setTitle("마우스 이벤트 리스너");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		Container c = getContentPane();

		c.addMouseListener(new MyMouseAdapter()); // 컨텐트팬에 마우스 리스너 등록

		c.setLayout(null); // 컨텐트팬의 배치 관리자 삭제

		la.setSize(50, 30);
		la.setLocation(30, 30);

		c.add(la); // 레이블 삽입

		setSize(300, 300);
		setVisible(true);
	}

	class MyMouseAdapter extends MouseAdapter { // MouseAdapter 를 상속받아 리스너 구현

		public void mousePressed(MouseEvent e) {
			int x = e.getX(); // 마우스 클릭 좌표 x
			int y = e.getY(); // 마우스 클릭 좌표 y

			la.setLocation(x, y); // 레이블의 위치를 (x,y)로 이동
		}

	}

	public static void main(String[] args) {
		new MouseAdapterEx();
	}

}
```


처음 코드에서는 MouseListener 인터페이스를 직접 구현해야 하므로,<br>
다음과 같이 사용하지 않는 메소드까지 모두 구현해야 했다.<br>


```java
class MyMouseListener implements MouseListener { // Mouse 리스너 구현

		public void mousePressed(MouseEvent e) {
			int x = e.getX(); // 마우스 클릭 좌표 x
			int y = e.getY(); // 마우스 클릭 좌표 y

			la.setLocation(x, y); // 레이블의 위치를 (x,y)로 이동
		}

		public void mouseReleased(MouseEvent e) {
		}

		public void mouseClicked(MouseEvent e) {
		}

		public void mouseEntered(MouseEvent e) {
		}

		public void mouseExited(MouseEvent e) {
		}
	}
```


하지만 어댑터 클래스를 사용하면<br>
다음과 같이 필요한 메소드만 선택적으로 구현할 수 있다.<br>


```java
class MyMouseAdapter extends MouseAdapter { // MouseAdapter 를 상속받아 리스너 구현

		public void mousePressed(MouseEvent e) {
			int x = e.getX(); // 마우스 클릭 좌표 x
			int y = e.getY(); // 마우스 클릭 좌표 y

			la.setLocation(x, y); // 레이블의 위치를 (x,y)로 이동
		}

	}
```






## 5. Key 이벤트와 KeyListener


Key 이벤트는 사용자가 키를 입력할 때 발생하는 이벤트이며,<br>
모든 컴포넌트가 Key 이벤트를 받을 수 있다.<br>

그러나 응용프로그램 내에 포커스(focus)를 가진 컴포넌트가<br>
키 입력을 독점하기 때문에,<br>
현재 포커스를 가진 컴포넌트에만 Key 이벤트가 발생한다.<br>
포커스란 키 입력의 독점권을 뜻한다.<br>

어떤 컴포넌트에게 키를 입력하고자 한다면,<br>
`<Tab>` 키 등 스윙의 포커스 이동 방향을 통해<br>
컴포넌트로 포커스를 이동시켜야 한다.<br>

응용프로그램에서 강제로 임의의 컴포넌트에게<br>
포커스를 주기 위해서는 다음 두 코드가 모두 필요하다.<br>


```java
component.setFocusable(true);	// component 가 포커스를 받을 수 있도록 설정
component.requestFocus();	// component 에게 포커스를 주어 키 입력을 받을 수 있게 설정
```


KeyListener의 메소드 중<br>
keyPressed()는 키를 누르는 순간에,<br>
keyReleased()는 누른 키를 떼는 순간에 호출된다.<br>
keyTyped()는 하나의 문자가 입력되었을 때 호출되며,<br>
유니코드 문자에 해당하는 키 입력에서만 발생한다.<br>

유니코드(Unicode)란 전 세계의 모든 문자를<br>
컴퓨터에서 일관되게 표현하고 다루고자 설계된<br>
국제 산업 표준이다.<br>

유니코드는 한글, 영어 알파벳 등<br>
세계 여러 나라의 문자들에 대해 코드 값을 정의하고 있다.<br>

그러므로 모든 키 입력에 대해서 keyPressed(), keyReleased()가 호출되고,<br>
A~Z, a~z, 0~9, !, @, & 등 문자 키에 대해서는<br>
keyTyped()가 추가적으로 호출된다.<br>

F1, Home, Delete, Shift, Alt 등<br>
문자가 아닌 키가 입력될 땐 keyTyped()가 호출되지 않는다.<br>

Key 이벤트가 발생하면 입력된 키 정보가 KeyEvent 객체에 담겨져 전달된다.<br>
이 객체는 입력된 키 값을 리턴하는 두 개의 메소드를 제공하며,<br>
이들을 이용해 입력된 키를 판별할 수 있다.<br>


### char KeyEvent.getKeyChar()


입력된 키의 유니코드 값을 리턴하고,<br>
유니코드 키가 아닌 경우<br>
KeyEvent.CHAR_UNDEFINED 를 리턴한다.<br>


### int KeyEvent.getKeyCode()


모든 키에 대해 정수형의 키 코드(key code)를 리턴한다.<br>
키 코드는 운영체제나 하드웨어마다 다를 수 있기 때문에,<br>
입력된 키 판별을 위해선 반드시 getKeyCode()가 리턴한<br>
키 코드와, 가상 키(Virtual Key) 값을 비교해야 한다.<br>

가상 키는 KeyEvent 클래스에 VK_로 시작하는<br>
static 상수로 선언되어 있다.<br>


이 메소드들을 사용해 `<Enter>` 키를 누르면 배경색을,<br>
방향키를 누르면 문자열이 이동하는 프로그램을 만들어 보자.<br>


```java
public class KeyEventEx extends JFrame {

	// private -> 이 클래스에서만 접근 가능
	private JLabel la = new JLabel("<Enter>키로 배경색이 바뀝니다.");
	private JLabel la2 = new JLabel("Java");

	public KeyEventEx() {
		super("KeyEvent 응용프로그램");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		Container c = getContentPane(); // 컨텐트팬 알아내기

		c.setLayout(null); // 문자열을 움직이기 위해 배치관리자 삭제

		la.setLocation(30, 30); // la 의 초기 위치
		la.setSize(500, 150);

		la2.setLocation(50, 50); // la2 의 초기 위치
		la2.setSize(100, 30);

		c.add(la);
		c.add(la2);

		c.addKeyListener(new MyKeyListener()); // 키 리스너 등록

		setSize(300, 300);
		setVisible(true);

		c.setFocusable(true); // 컨텐트팬이 포커스를 받을 수 있도록 설정
		c.requestFocus(); // 컨텐트팬에 포커스 설정 -> 키 입력 가능해짐
	}

	class MyKeyListener extends KeyAdapter { // 키 리스너

		public void keyPressed(KeyEvent e) {

			int keyCode = e.getKeyCode();

			switch (keyCode) {
			case KeyEvent.VK_ENTER: // Enter 키
				// 임의의 색을 만들기 위해 랜덤 r, g, b 성분 생성
				int r = (int) (Math.random() * 256); // 0~255 사이의 임의의 red 성분
				int g = (int) (Math.random() * 256); // 0~255 사이의 임의의 green 성분
				int b = (int) (Math.random() * 256); // 0~255 사이의 임의의 blue 성분

				getContentPane().setBackground(new Color(r, g, b)); // 컨텐트팬 배경색 설정
				break;
			case KeyEvent.VK_UP: // UP 키
				la2.setLocation(la2.getX(), la2.getY() - 10);
				break;
			case KeyEvent.VK_DOWN: // DOWN 키
				la2.setLocation(la2.getX(), la2.getY() + 10);
				break;
			case KeyEvent.VK_LEFT: // LEFT 키
				la2.setLocation(la2.getX() - 10, la2.getY());
				break;
			case KeyEvent.VK_RIGHT: // RIGHT 키
				la2.setLocation(la2.getX() + 10, la2.getY());
				break;
			}
		}
	}

	public static void main(String[] args) {
		new KeyEventEx();
	}

}
```


실행 결과는 다음과 같다.<br>
`<Enter>` 키로 배경색을,<br>
방향키로 문자열의 위치를 변경하는 모습이다.<br>


![KeyEvent 예제](/assets/images/KeyEvent%20예제.PNG)






## 6. Mouse 이벤트와 MouseListener, MouseMotionListener


Mouse 이벤트는 다음과 같이<br>
사용자가 마우스를 조작하는 7가지 경우에 발생한다.<br>


![Mouse 이벤트](/assets/images/Mouse%20이벤트.png)


마우스가 눌린 위치에서 그대로 떼어지면,<br>
다음과 같은 순서로 메소드가 호출된다.<br>


```java
mousePressed(), mouseReleased(), mouseClicked()
```


하지만 마우스가 드래그되면,<br>
다음과 같은 순서로 메소드가 호출된다.<br>


```java
mousePressed(), mouseDragged(), mouseDragged(), .... ,  mouseReleased()
```


### 마우스 리스너 달기


위 표의 처음 5가지 경우에 발생하는<br>
Mouse 이벤트를 처리하고자 한다면,<br>
리스너를 다음과 같이 등록하면 된다.<br>


```java
component.addMouseListener(new MyMouseListener());
```


그러나 같은 컴포넌트가 마우스 드래깅과<br>
마우스 무브를 함께 처리하고자 한다면,<br>
MouseMotion 리스너를 따로 등록해야 한다.<br>


```java
component.addMouseMotionListener(new MyMouseListener());
```


### MouseEvent 객체 활용


MouseEvent 객체는 Mouse 이벤트나<br>
MouseMotion 이벤트가 발생한 상황 정보를 제공한다.<br>
이 객체를 통해 마우스 포인터의 위치와 클릭 횟수를 알아낼 수 있다.<br>


```java
int getX()	// 마우스 포인터의 x 위치 리턴
int getY()	// 마우스 포인터의 y 위치 리턴

int getClickCount()	// 마우스의 클릭 횟수 리턴
```


이 메소드들을 활용해<br>
7가지의 마우스 이벤트를 처리하는 프로그램을 만들어 보자.<br>


```java
public class MouseEventEx extends JFrame {

	private JLabel la = new JLabel("   Move Me"); // 마우스로 이동시킬 레이블 컴포넌트

	public MouseEventEx() {
		super("MouseEvent 응용프로그램");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		Container c = getContentPane();

		MyMouseListener listener = new MyMouseListener(); // 마우스/모션 리스너 객체 생성

		c.addMouseListener(listener);
		c.addMouseMotionListener(listener);

		c.setLayout(null);

		la.setSize(70, 30);
		la.setLocation(100, 70);

		c.add(la);

		setSize(330, 200);
		setVisible(true);
	}

	class MyMouseListener implements MouseListener, MouseMotionListener {
		// MouseListener 의 5개 메소드 구현
		public void mousePressed(MouseEvent e) {
			la.setLocation(e.getX(), e.getY()); // 마우스가 눌러진 위치로 레이블 이동
			setTitle("mousePressed(" + e.getX() + "," + e.getY() + ")"); // 눌러진 위치 출력
		}

		public void mouseReleased(MouseEvent e) {
			la.setLocation(e.getX(), e.getY()); // 마우스가 놓여진 위치에 레이블 이동
			setTitle("mouseReleased(" + e.getX() + "," + e.getY() + ")"); // 떼어진 위치 출력
		}

		public void mouseClicked(MouseEvent e) {
		}

		public void mouseEntered(MouseEvent e) {
			Component comp = (Component) e.getSource();
			comp.setBackground(Color.cyan); // 마우스가 올라간 곳 색 변경
		}

		public void mouseExited(MouseEvent e) {
			Component comp = (Component) e.getSource();
			comp.setBackground(Color.yellow); // 마우스가 내려간 곳 색 변경

			setTitle("mouseExited(" + e.getX() + "," + e.getY() + ")"); // 벗어난 위치 출력
		}

		// MouseMotionListener 의 2개 메소드 구현
		public void mouseDragged(MouseEvent e) { // 마우스가 드래깅되는 동안 계속 호출
			la.setLocation(e.getX(), e.getY());
			setTitle("mouseDragged(" + e.getX() + "," + e.getY() + ")"); // 드래깅 위치 출력
		}

		public void mouseMoved(MouseEvent e) { // 마우스가 움직이는 동안 계속 호출
			la.setLocation(e.getX(), e.getY());
			setTitle("mouseMoved(" + e.getX() + "," + e.getY() + ")"); // 무브 위치 출력
		}
	}

	public static void main(String[] args) {
		new MouseEventEx();
	}

}
```


실행 결과는 다음과 같다.<br>


![MouseEvent 예제](/assets/images/MouseEvent%20예제.PNG)


-----------------------------------------------------------------------<br>


지금까지 자바의 이벤트 처리에 대해 공부해 보았다.<br>
다음 글에서는 자바의 스윙 컴포넌트 활용에 대해서 공부해 보겠다.<br>


---
※ 본 글은 개인 학습을 목적으로 「명품 자바 에센셜」(황기태 지음, 생능출판)을 참고하여 작성하였습니다.