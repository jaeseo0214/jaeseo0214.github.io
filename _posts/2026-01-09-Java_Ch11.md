---
layout: single
title: "Java Chapter 11 – 자바의 이벤트 처리"
date: 2026-01-09
categories:
  - Java
  - java_grammer
tags: [Java, 문법]
author_profile: true
read_time: true
comments: true
share: true
related: true
sidebar:
  nav: "categories_sidebar"
---


# 자바의 이벤트 처리





## 1. 이벤트 기반 GUI 프로그래밍


이벤트 기반 프로그래밍(Event Driven Programming)은<br>
이벤트 발생에 의해 프로그램 실행 흐름이 결정되는<br>
프로그래밍 패러다임이다.<br>

이벤트는 키 입력, 마우스 클릭, 마우스 드래그 등<br>
사용자의 액션이나, 외부 장치로부터의 입력,<br>
네트워크를 통한 다른 컴퓨터로부터의 데이터 수신,<br>
다른 스레드나 프로그램으로부터의 메시지 수신 등에 의해 발생한다.<br>

이벤트 기반 응용프로그램은<br>
각 이벤트를 처리하는 이벤트 리스너(event listener) 코드를 보유하고,<br>
이벤트가 발생할 때마다 해당 리스너가 처리하게 한다.<br>

일반적인 GUI 응용프로그램은<br>
이벤트 기반 프로그래밍 기법으로 작성한다.<br>

자바에서는 AWT나 스윙을 이용하여<br>
이벤트 기반 GUI 응용프로그램을 작성할 수 있다.<br>

특히 스윙 패키지는 GUI와 더불어 강력한 이벤트 플랫폼을 제공한다.<br>


### 자바의 이벤트 기반 GUI 응용프로그램 구조


예를 들어 스윙 응용프로그램에<br> 
JButton 하나가 있다고 가정해 보자.<br>
이 때 이 버튼이 클릭되어<br>
이벤트가 발생하고 처리되는 과정은<br>
다음과 같다.<br>


1. 사용자가 마우스로 화면의 JButton 클릭<br>

2. 버튼 클릭은 마우스 드라이버, 운영체제를 거쳐<br>
자바 가상 기계에 전달됨<br>

3. 자바 가상 기계는 이벤트 큐(Event Queue)를 통해<br>
이벤트 분배 스레드(Event Dispatch Thread, EDT)에<br>
마우스 클릭 정보를 전달함<br>

4. 이벤트 분배 스레드는 이벤트 큐로부터<br>
이벤트 객체를 꺼내어 처리한다.<br>
이 이벤트 객체에는 이벤트 종류, 이벤트 소스,<br>
좌표 등의 정보가 담겨 있다.<br>
이벤트 객체 내에 저장되는 정보 중,<br>
특별히 이벤트를 발생시킨 컴포넌트를<br>
이벤트 소스(Event source)라고 부름.<br>

5. 이벤트 분배 스레드는 JButton에 등록된<br>
이벤트 리스너(ActionListener 등)의<br>
이벤트 처리 메서드를 호출한다.<br>

6. 이벤트 분배 스레드는 이벤트 리스너로부터 리턴한 후,<br>
다음 이벤트 발생을 기다림<br>


다음은 이벤트 관련 용어를 정리한 것이다.<br>


[

  * 이벤트 소스 - 이벤트를 발생시킨 GUI 컴포넌트<br>

  * 이벤트 객체 - 발생한 이벤트에 대한 여러 정보<br>

  * 이벤트 리스너 - 사용자가 작성하며, 이벤트를 처리하는 자바 프로그램 코드로,<br>
    보통 리스너 인터페이스를 구현한 클래스로 작성<br>

  * 이벤트 분배 스레드 - 무한 루프를 돌면서 이벤트 큐로부터 이벤트 객체를 꺼내<br>
    이벤트 리스너를 찾아 호출하는 스레드, 자바 플랫폼에서 제공<br>

]






## 2. 이벤트 객체


이벤트 객체는 현재 발생한 이벤트에 관한<br>
여러 정보를 가진 객체로, 이벤트 리스너에게 전달된다.<br>

모든 이벤트 객체는 java.util.EventObject 클래스를 상속받는다.<br>

또한 이벤트 객체는<br>
사용자가 이벤트에 대한 정보를 얻을 수 있도록<br>
여러 메소드를 제공한다.<br>

그 중 모든 이벤트 객체에 공통적으로 있으면서<br>
가장 많이 사용되는 메소드는,<br>
어떤 컴포넌트에 이벤트가 발생했는지<br>
이벤트 소스를 알려주는 getSource() 메소드이다.<br>

getSource() 메소드는 Object를 리턴하므로<br>
캐스팅 해서 사용해야 하는데,<br>
만약 버튼 컴포넌트에서 이벤트가 발생한 경우라면,<br>
다음과 같이 캐스팅 하면 된다.<br>


```java
JButton b = (JButton)event.getSource(); // b 는 이벤트가 발생한 버튼의 레퍼런스
```


다음은 이벤트 객체와 이벤트 소스,<br>
그리고 이벤트가 발생하는 경우를<br>
정리한 표이다.<br>


![이벤트 관련 표](/assets/images/이벤트%20관련%20표.png)


여기서 MouseEvent의 이벤트 소스는 Component이므로,<br>
Component를 상속받은 GUI 컴포넌트는<br>
마우스 이벤트의 대상이 될 수 있다.<br>

즉 Component를 상속받은 GUI 컴포넌트는,<br>
사용자가 마우스를 조작하면<br>
해당 컴포넌트가 마우스 이벤트를 받을 수 있는 상태일 경우,<br>
MouseEvent가 발생한다.<br>






## 3. 사용자 이벤트 리스너 작성


이벤트 리스너란 이벤트를 처리하는 자바 프로그램 코드로,<br>
일반적으로 클래스로 작성된다.<br>

자바는 이벤트 리스너 인터페이스(interface)를 제공하며,<br>
개발자는 이 리스너 인터페이스를 구현(implements)하고,<br>
추상 메소드를 구현하여 이벤트 리스너를 작성한다.<br>

다음은 이벤트 리스너 인터페이스를 정리한 표이다.<br>


![이벤트 리스너 인터페이스](/assets/images/이벤트%20리스너%20인터페이스.png)


### 이벤트 리스너 작성 기초


이벤트 리스너는 전형적으로 다음 3단계로 작성한다.<br>


1. 이벤트와 이벤트 리스너 선택 - 목적에 필요한 이벤트와<br>
리스너 인터페이스 선택<br>

2. 이벤트 리스너 클래스 작성 - 리스너 인터페이스를 구현하는<br>
클래스를 작성하고, 추상 메소드 모두 구현<br>

3. 이벤트 리스너 등록 - 이벤트를 받을 GUI 컴포넌트에 이벤트 리스너 등록<br>


먼저 1번 과정에서 이벤트는 Action 이벤트,<br>
이벤트 리스너는 ActionListener, 이벤트 객체는 ActionEvent로 정하자.<br>


다음 2번 과정에서 이벤트 리스너를 작성해보자.<br>
ActionListener 인터페이스를 구현한<br>
MyActionListener 클래스를 선언하고,<br>
추상 메소드 actionPerformed(ActionEvent e)를<br>
다음과 같이 구현한다.<br>


```java
class MyActionListener implements ActionListener {
    public void actionPerformed(ActionEvent e) {    // Action 이벤트가 발생했을 때 호출되는 메소드
        JButton b = (JButton)e.getSource(); // 사용자가 클릭한 버튼 알아내기

        if(b.getText().equals("Action")) {  // 버튼의 현재 문자열이 "Action"인지 비교
            b.setText("액션");  // JButton 의 setText() 를 호출하여 문자열 변경
        }
        else {
            b.setText("Action");    // JButton 의 setText() 를 호출하여 문자열 변경
        }
    }
}
```


마지막으로 이벤트 리스너가 작동되기 위해서는<br>
MyActionListener 클래스의 객체를<br>
버튼 컴포넌트에 등록해야 하므로,<br>
다음과 같이 등록해 준다.<br>


```java
MyActionListener listener = new MyActionListener();  // 리스너 인스턴스 생성
btn.addActionListener(listener);  // 리스너 등록
```


일반적으로 컴포넌트에 이벤트 리스너를 등록할 때,<br>
다음과 같이 등록한다.<br>


```java
component.addXXXListener(listener);
```


이벤트에 따라 addActionListener(),<br>
addMouseListener() 등으로 작성하면 된다.<br>


### 이벤트 리스너 작성 1 - 독립 클래스로 Action 이벤트 리스너 만들기


버튼을 클릭할 때마다 문자열이 바뀌는<br>
프로그램을 작성해 보자.<br>


```java
public class IndepClassListener extends JFrame {

	public IndepClassListener() {
		setTitle("독립 클래스로 Action 이벤트 리스너 만들기");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		Container c = getContentPane();
		c.setLayout(new FlowLayout());

		JButton btn = new JButton("Action");
		btn.addActionListener(new MyActionListener()); // Action 이벤트 리스너 등록

		c.add(btn);

		setSize(250, 130);
		setVisible(true);
	}

	public static void main(String[] args) {
		new IndepClassListener();
	}

}

class MyActionListener implements ActionListener {
	public void actionPerformed(ActionEvent e) {
		JButton b = (JButton) e.getSource(); // 이벤트를 발생시킨 버튼 객체 얻기

		if (b.getText().equals("Action")) { // 버튼의 문자열이 "Action" 인지 비교
			b.setText("액션"); // 버튼의 문자열을 변경
		} else {
			b.setText("Action"); // 버튼의 문자열을 변경
		}
	}
}
```


실행 결과는 다음과 같다.<br>
버튼을 클릭할 때마다 문자열이 바뀐다.<br>


![독립 클래스 이벤트 리스너](/assets/images/독립%20클래스%20이벤트%20리스너.PNG)


### 이벤트 리스너 작성 2 - 내부 클래스로 Action 이벤트 리스너 만들기


이벤트 리스너 클래스는 내부 클래스(inner class)로도 작성할 수 있다.<br>
다음 코드는 이벤트 리스너 작성 1의 코드를<br>
내부 클래스로 작성한 경우이다.<br>

내부 클래스는 자신을 내포한 클래스의 멤버와 같으므로,<br>
MyActionListener는 InnerClassListener 클래스나<br>
슈퍼 클래스인 JFrame의 멤버를 자유롭게 접근할 수 있다.<br>


```java
public class InnerClassListener extends JFrame {

	public InnerClassListener() {
		setTitle("내부 클래스로 Action 이벤트 리스너 만들기");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		Container c = getContentPane();
		c.setLayout(new FlowLayout());

		JButton btn = new JButton("Action");
		btn.addActionListener(new MyActionListener()); // Action 이벤트 리스너 등록

		c.add(btn);

		setSize(250, 130);
		setVisible(true);
	}

	// 내부 클래스로 Action 리스너 작성
	private class MyActionListener implements ActionListener {
		public void actionPerformed(ActionEvent e) {
			JButton b = (JButton) e.getSource(); // 이벤트 소스 버튼 알아내기

			if (b.getText().equals("Action")) { // 버튼의 문자열이 "Action" 인지 비교
				b.setText("액션"); // 버튼의 문자열을 변경
			} else {
				b.setText("Action"); // 버튼의 문자열을 변경
			}

			// InnerClassListener 의 멤버나 JFrame 의 멤버 호출 가능
			InnerClassListener.this.setTitle(b.getText()); // 프레임의 타이틀에 버튼 문자열 출력
		}
	}

	public static void main(String[] args) {
		new InnerClassListener();
	}

}
```


실행 결과는 다음과 같다.<br>
기본적인 동작은 1번 예제와 동일하다.<br>
다만, 버튼을 클릭할 때마다 응용프로그램의 타이틀을<br>
버튼의 문자열로 변경하는 기능이 추가되었다.<br>


![내부 클래스 이벤트 리스너](/assets/images/내부%20클래스%20이벤트%20리스너.PNG)


### 이벤트 리스너 작성 3 - 익명 클래스로 Action 이벤트 리스너 만들기


익명 클래스는 클래스 이름 없이,<br>
클래스 선언과 인스턴스 생성을<br>
하나로 작성하는 방식이다.<br>

익명 클래스를 작성하는 기본 형태는 다음과 같다.<br>


```java
new 익명클래스의 슈퍼클래스(생성자 인자들) {
    .......................
    익명 클래스의 멤버 구현
    .......................
}
```


익명 클래스는 별도의 MyActionListener 클래스를 작성하지 않고도,<br>
ActionListener를 구현하면서<br>
바로 actionPerformed() 메소드를 구현하면 된다.<br>


익명 클래스 또한 일종의 내부 클래스이므로,<br>
외부 클래스의 멤버에 자유롭게 접근할 수 있다.<br>


다음은 익명 클래스를 활용해 이벤트 리스너를 작성한 코드이다.<br>


```java
public class AnonymousClassListener extends JFrame {

	public AnonymousClassListener() {
		setTitle("익명 클래스로 Action 이벤트 리스너 만들기");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		Container c = getContentPane();
		c.setLayout(new FlowLayout());

		JButton btn = new JButton("Action");

		c.add(btn);

		btn.addActionListener(new ActionListener() { // 익명 클래스로 Action 리스너 작성
			public void actionPerformed(ActionEvent e) {
				JButton b = (JButton) e.getSource(); // 이벤트 소스 버튼 알아내기

				if (b.getText().equals("Action")) { // 버튼의 문자열이 "Action" 인지 비교
					b.setText("액션"); // 버튼의 문자열을 변경
				} else {
					b.setText("Action"); // 버튼의 문자열을 변경
				}

				// AnonymousClassListener 의 멤버나 JFrame 의 멤버 호출 가능
				AnonymousClassListener.this.setTitle(b.getText()); // 프레임의 타이틀에 버튼 문자열 출력
			}
		});

		setSize(250, 130);
		setVisible(true);
	}

	public static void main(String[] args) {
		new AnonymousClassListener();
	}

}
```


실행 결과는 다음과 같다.<br>
버튼 클릭 시의 동작은 2번 예제와 동일하다.<br>


![익명 클래스 이벤트 리스너](/assets/images/익명%20클래스%20이벤트%20리스너.PNG)


### 이벤트 리스너 작성 4 - 마우스 이벤트 리스너


컨텐트팬의 아무 위치에서 마우스 버튼을 누르면,<br>
마우스 포인터가 있는 위치로 레이블의 문자열이 이동하는<br>
프로그램을 만들어 보자.<br>

MouseListener 인터페이스를 구현하고,<br>
마우스 버튼이 눌렸을 때 호출되는 mousePressed() 메소드에<br>
동작 코드를 작성하면 된다.<br>

컨텐트팬의 배치관리자를 삭제해야<br>
컴포넌트를 마음대로 이동시킬 수 있다.<br>


```java
public class MouseListenerEx extends JFrame {

	private JLabel la = new JLabel("Java");

	public MouseListenerEx() {
		setTitle("마우스 이벤트 리스너");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		Container c = getContentPane();

		c.addMouseListener(new MyMouseListener()); // 컨텐트팬에 마우스 리스너 등록

		c.setLayout(null); // 컨텐트팬의 배치 관리자 삭제

		la.setSize(50, 30);
		la.setLocation(30, 30);

		c.add(la); // 레이블 삽입

		setSize(300, 300);
		setVisible(true);
	}

	class MyMouseListener implements MouseListener { // Mouse 리스너 구현

		public void mousePressed(MouseEvent e) {
			int x = e.getX(); // 마우스 클릭 좌표 x
			int y = e.getY(); // 마우스 클릭 좌표 y

			la.setLocation(x, y); // 레이블의 위치를 (x,y)로 이동
		}

		public void mouseReleased(MouseEvent e) {
		}

		public void mouseClicked(MouseEvent e) {
		}

		public void mouseEntered(MouseEvent e) {
		}

		public void mouseExited(MouseEvent e) {
		}
	}

	public static void main(String[] args) {
		new MouseListenerEx();
	}

}
```


실행 결과는 다음과 같다.<br>
마우스로 클릭한 부분으로<br>
레이블의 좌표가 이동된다.<br>


![마우스 이벤트 리스너](/assets/images/마우스%20이벤트%20리스너.PNG)