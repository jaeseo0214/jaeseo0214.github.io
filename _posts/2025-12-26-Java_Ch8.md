---
layout: single
title: "Java Chapter 8 – 자바의 모듈과 패키지"
date: 2025-12-26
categories:
  - Java
  - java_grammer
tags: [Java, 문법]
author_profile: true
read_time: true
comments: true
share: true
related: true
sidebar:
  nav: "categories_sidebar"
---


# Java의 모듈과 패키지


자바에서 패키지(package)란 서로 관련 있는 클래스나<br>
인터페이스의 컴파일된 클래스 파일들을<br>
하나의 디렉터리에 모아 놓은 것이다.<br>


그리고 모듈(module) 은 이러한 패키지들을<br>
여러 개 묶어 관리하는 단위이다.<br>


2017년 9월, Java 9 에서 모듈 개념이 새롭게 도입되었으며,<br>
자바 플랫폼에서 제공하는 수많은 패키지들을<br>
수십 개의 모듈로 나누어 제공하기 시작했다.<br>


각 모듈은 JDK 설치 디렉터리 하위의 jmods 디렉터리에<br>
.jmod 확장자를 가진 ZIP 압축 파일 형태로 저장되어 있다.<br>






## 1. 패키지 사용


개발 시 자주 사용하는 Scanner 클래스는<br>
java.base 모듈에 포함된 java.util 패키지에 존재한다.<br>


자바에서 다른 패키지에 있는 클래스를 사용하려면,<br>
패키지명을 포함한 완전한 경로명을 사용하여<br>
컴파일러가 해당 클래스의 위치를<br> 
찾을 수 있도록 해야 한다.<br>


다음 예시는 완전한 경로명을 사용하여<br>
Scanner 클래스를 사용하는 코드이다.<br>


```java
public class ImportEx {
    public static void main(String[] args) {
        java.util.Scanner sc = new java.util.Scanner(System.in);
        System.out.println(sc.next());
    }
}
```


하지만 매번 완전한 경로명을 사용하는 것은 번거롭고,<br>
타이핑 실수가 발생할 가능성도 있다.<br>
이를 해결하기 위해 import 문을 사용한다.<br>


import 문은 다음과 같은 두 가지 방법으로 사용할 수 있다.<br>


1. 사용할 클래스마다 완전한 경로명을 지정하는 방법<br>


```java
import 패키지.클래스;
```


2. *을 사용하여 해당 패키지의 클래스를 한 번에 선언하는 방법<br>


```java
import 패키지.*;
```


다음은 위의 두 가지 방법을 적용하여<br>
앞서 작성한 예제 코드를 수정한 것이다.<br>


```java
//1번 방법
import java.util.Scanner;
public class ImportEx {
    public static void main(String [] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println(sc.next());
    }
}

//2번 방법
import java.util.*;
public class ImportEx {
    public static void main(String [] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println(sc.next());
    }
}
```






## 2. 패키지 만들기


클래스나 인터페이스가 컴파일되면 클래스 파일이 생성되는데,<br>
이 클래스 파일은 반드시 어떤 패키지에 소속되어야 한다.<br>


따라서 클래스 파일에는 다음과 같이<br>
package 키워드를 사용하여<br>
해당 클래스가 소속될 패키지명을 선언해야 한다.<br>


```java
package 패키지명;
```


하지만 실제 개발 환경에서는<br>
패키지를 생성하고 클래스 파일을 만드는 과정에서<br>
대부분의 작업을 개발 도구(IDE)가 자동으로 처리해 준다.<br>


이제 다음 예제 프로젝트를<br>
두 개의 패키지로 분리해 보자.<br>


```java
abstract class Calculator {
    public abstract int add(int a, int b);
    public abstract int subtract(int a, int b);
    public abstract double average(int[] a);
}

public class GoodCalc extends Calculator {
    public int add(int a, int b) {
        return a + b;
    }

     public int subtract(int a, int b) {
        return a - b;
     }

     public double average(int[] a) {
        double sum = 0;

        for(int i = 0; i < a.length; i++) {
            sum += a[i];
        }

        return sum / a.length;
     }

     public static void main(String [] args) {
        Calculator c = new GoodCalc();

        System.out.println(c.add(2,3));
        System.out.println(c.subtract(2,3));
        System.out.println(c.average(new int [] { 2, 3, 4}));
     }
}
```


먼저 프로젝트 하위에<br>
lib 패키지와 app 패키지를 생성한다.<br>


lib 패키지에는 Calculator 클래스를 작성하고,<br>
app 패키지에는 GoodCalc 클래스를 작성한다.<br>


```java
package lib; // Calculator.java를 컴파일하면 Calculator.class가 lib 폴더에 저장된다.

public abstract class Calculator {
    public abstract int add(int a, int b);
    public abstract int subtract(int a, int b);
    public abstract double average(int[] a);
}
```


```java
package app;
import lib.Calculator;  // GoodCalc 클래스에서 Calculator를 사용하기 위해 import

public class GoodCalc extends Calculator {
    public int add(int a, int b) {
        return a + b;
    }

     public int subtract(int a, int b) {
        return a - b;
     }

     public double average(int[] a) {
        double sum = 0;

        for(int i = 0; i < a.length; i++) {
            sum += a[i];
        }

        return sum / a.length;
     }

     public static void main(String [] args) {
        Calculator c = new GoodCalc();

        System.out.println(c.add(2,3));
        System.out.println(c.subtract(2,3));
        System.out.println(c.average(new int [] { 2, 3, 4}));
     }
}
```


마지막으로 중요한 점은,<br>
lib 패키지에 포함된 Calculator 클래스가<br>
다른 패키지에서 사용되기 위해서는<br>
접근 지정자를 public으로 선언해야 한다는 것이다.<br>






## 3. 모듈


모듈은 앞서 설명했듯이 Java 9부터 도입된 개념으로,<br>
여러 개의 패키지를 하나로 묶은 상위 단위이다.<br>


모듈은 단순히 패키지를 묶는 것뿐만 아니라,<br>
의존성 정보와 접근 제어 정보를 함께 관리한다.<br>


모듈 도입에 대한 Oracle 공식 목적은 다음과 같다.<br>

1. 의존성을 명확하게 관리하기 위해

2. 내부 API를 강하게 캡슐화하기 위해

3. Java SE 플랫폼을 모듈 단위로 분리하기 위해


모듈은 module-info.java라는 선언 파일로 정의되며,<br>
이 파일은 모듈의 설계 계약서 역할을 한다.<br>


```java
module 모듈명 {
    requires 다른모듈;
    exports 패키지명;
}
```

requires는 해당 모듈이 의존하는 다른 모듈을 선언하는 키워드이다.<br>
모듈은 requires로 선언된 모듈에 대해서만 접근할 수 있다.<br>


또한 public 클래스라 하더라도,<br>
exports되지 않은 패키지에 포함되어 있다면<br>
다른 모듈에서는 접근할 수 없다.<br>


이를 통해 모듈은 공개 API와 내부 구현을 명확히 분리한다.<br>


exports는 외부에 공개할 패키지를 지정하는 역할을 한다.<br>
exports로 선언된 패키지에 포함된<br>
public 타입만 다른 모듈에서 사용할 수 있다.<br>


모듈 중에서도 반드시 알아야 할 기본 모듈은<br>
java.base 모듈이다.<br>


java.base 모듈은 java.base.jmod 파일에 포함되어 있으며,<br>
java.lang, java.util 등<br>
자바 응용 프로그램에서 가장 많이 사용되는<br>
기본 패키지와 클래스들을 제공한다.<br>


또한 java.base 모듈은<br>
모든 자바 프로그램에 자동으로 포함되므로,<br>
별도로 requires java.base;를 선언할 필요는 없다.<br>





## 4. 자바 JDK에서 제공하는 패키지


자바 개발 도구인 JDK(Java Development Kit)는<br>
화면 출력, 키 입력, 네트워킹 등 프로그램 개발에 필요한<br>
기본적인 기능과 다양한 응용 기능을 구현한 많은 클래스와<br>
인터페이스들을 포함하는 표준 패키지들을 제공한다.<br>
이를 자바 API라고 한다.<br>


자바의 표준 패키지는 모듈로 나누어져,<br>
JDK가 설치된 디렉터리 밑의 jmods 디렉터리에<br>
압축 파일 형태로 담겨져 있다<br>


이 중 주요 패키지를 정리하면 다음과 같다.<br>

- java.lang -> System을 비롯하여 문자열, 수학 함수, 입출력 등<br>
자바 프로그래밍에 필요한 기본적인 클래스와 인터페이스를 제공한다.<br>
이 패키지의 클래스들은 import 문을 작성하지 않아도 자동 import 된다.<br>


- java.util -> 날짜, 시간, 벡터, 해시맵 등 유틸리티 클래스와 인터페이스를 제공한다.<br>


- java.io -> 키보드, 모니터, 프린터 등의 입출력 클래스와 인터페이스를 제공한다.<br>


- java.awt -> GUI 프로그래밍에 필요한 AWT 클래스와 인터페이스를 제공한다.<br>


- java.swing -> 스윙 GUI 프로그래밍에 필요한 클래스와 인터페이스를 제공한다.<br>





## 5. Object 클래스


Object 클래스는 java.lang 패키지에 속한<br>
자바 클래스 계층 구조의 최상위 클래스이다.<br>
모든 클래스는 강제로 Object 클래스를 상속 받으며,<br>
Object 클래스는 아무 클래스도 상속받지 않는다.<br>


다음은 Object 클래스의 주요 메소드들이다.<br>


### 1. int hashCode()

객체의 해시 코드 값을 제공한다.<br>
해시 코드 값은 객체가 생성될 때 할당받는 고유한 정수 값이다.<br>


### 2. Class getClass()

객체의 클래스 정보를 담은 Class 객체를 리턴한다.<br>


### 3. String getName()

객체의 클래스 명을 리턴한다.<br>


### 4. String toString()

객체를 문자열로 변환한다.<br>
각 클래스는 toString()을 오버라이딩하여<br>
자신만의 문자열을 리턴할 수 있다.<br>
(public으로 선언해야 함을 주의)<br>


### 5. boolean equals(Object obj)

객체를 비교한다.
== 연산자는 객체의 레퍼런스 값을 비교하는 반면,<br>
equals() 메소드는 객체의 내용을 비교한다.<br>
두 객체가 동일한지를 비교하려면,<br>
해당 클래스에서 equals() 메소드를 재정의해야 한다.<br>


### 6. void notify()

현 객체에 대해 대기하고 있는 하나의 스레드를 깨운다.<br>


### 7. void notifyAll()

현 객체에 대해 대기하고 있는 모든 스레드를 깨운다.<br>


### 8. void wait()

다른 스레드가 깨울 때까지 현재 스레드를 대기하게 한다.<br>


실제 사용은 다음과 같다.<br>


```java
class Point {
    private int x, y;

    public Point(int x, int y) {
        this.x = x;
        this. y = y;
    }

    @Override
    public String toString() {
        return "Point(" + x + ", " + y + ")";
    }

    @Override
    public boolean equals(Object obj) {
        Point p = (Point)obj;   // obj를 Point 타입으로 다운캐스팅

        if(x == p.x && y == p.y) {
            return true;
        }
        else {
            return false;
        }
    }
}

public class ObjectEx {
    public static void main(String [] args) {
        Point a = new Point(2, 3);
        Point b = new Point(3, 4);

        System.out.println(a.hashCode());   // 해시 코드 값
        System.out.println(a.getClass().getName()); // 클래스 이름
        System.out.println(a.toString());   // 객체의 문자열

        if(a.equals(b)) {
             System.out.println("a = b");
        }
    }
}
```


실행 결과는 다음과 같다.<br>


```java
22279806    // 해시 코드의 16진수 값 -> 실행 시마다 달라질 수 있음
Point       // 클래스 이름
Point(2, 3) // 객체의 문자열 리턴값
a = b      // equals() 메소드 실행 결과
```





## 6. Wrapper 클래스


Wrapper라는 이름의 클래스는 존재하지 않는다.<br>
다만 8개의 기본 타입을 객체로 다루기 위해<br>
8개 클래스들을 통칭하여 Wrapper 클래스라고 말한다.<br>


![Wrapper 클래스](/assets/images/Wrapper.png)<br>


자바는 객체 지향 언어이기 때문에,<br>
기본적으로 객체를 대상으로 처리하는 경우가 많다.<br>
JDK의 많은 클래스들 또한 객체만을 다루기 때문에,<br>
기본 타입 값을 객체로 만들어 사용할 수 있게 하는 것이<br>
바로 Wrapper 클래스이다.<br>


8개의 Wrapper 클래스들의 사용법은 거의 비슷하다.<br>
다음은 Wrapper 클래스의 객체 생성 예시이다.<br>


```java
Integer i = Integer.valueOf(10);         // 정수 10의 객체화
Character c = Character.valueOf('c');    // 문자 'c'의 객체화
Boolean b = Boolean.valueOf(true);       // 불린 값 true의 객체화
```


또한 Character를 제외한 나머지는 문자열로 객체 생성이 가능하다.<br>


```java
Integer i = Integer.valueOf("10");
Boolean b = Boolean.valueOf("false");
```


추가로, 위의 객체 생성 방법은 Java 9부터 도입되었다.<br>
이전의 new Integer() 방식은 더 나은 메모리 효율과<br>
빠른 속도를 위해 폐기되었다.<br>


Wrapper 클래스에는 기본 타입 값을 문자열로 변환하거나<br>
문자열을 기본 타입 값으로 변환하는 메소드들이 주를 이룬다.<br>
많이 사용되는 Integer 클래스의 주요 메소드들은 다음과 같다.<br>
추가로 많은 메소드들이 static 타입이다.<br>


### 1. static int bitCount(int i)

정수 i의 이진수 표현에서 1의 개수를 리턴한다.<br>


### 2. double doubleValue()

double 타입으로 값을 리턴한다.<br>


### 3. int intValue()

int 타입으로 값을 리턴한다.<br>


### 4. static int parseInt(String s)

문자열 s를 10진 정수로 변환한 값을 리턴한다.<br>


### 5. static int parseInt(String s, int radix)

문자열 s를 지정된 진법의 정수로 변환한 값을 리턴한다.<br>


### 6. static String toBinaryString(int i)

정수 i를 이진수 표현으로 변환한 문자열을 리턴한다.<br>


### 7. static String toHexString(int i)

정수 i를 16진수 표현으로 변환한 문자열을 리턴한다.<br>


### 8. static String toString(int i)

정수 i를 문자열로 변환하여 리턴한다.<br>


다음은 다양한 Wrapper 클래스의 활용 예시이다.<br>


```java
public class WrapperEx {
    public static void main(String [] args) {
        // Character 사용
         System.out.println(Character.toLowerCase('A'));    // 'A' 를 소문자로 변환

         char c1 = '3'; 
         char c2 = 'D';

         if(Character.isDigit(c1)) {    // 문자 c1이 숫자이면 true
             System.out.println(c1 + "은 숫자");
         }

         if(Character.isAlphabetic(c2)) {   // 문자 c2가 영문자이면 true
             System.out.println(c2 + "는 영문자");
         }

         // Integer 사용
         System.out.println(Integer.parseInt("33"));    // 문자열 "33"을 10진수로 변환
         System.out.println(Integer.toString(33));      // 정수 33을 문자열로 변환
         System.out.println(Integer.toBinaryString(33)); // 33을 이진수 문자열로 변환
         System.out.println(Integer.bitCount(33));       // 33에 대한 이진수의 1의 개수

         Integer i = Integer.valueOf(33);
         System.out.println(i.doubleValue());    // 정수 33을 double 값으로 변환 -> 33.0

         // Double 사용
         Double d = Double.valueOf(3.14);
         
         System.out.println(d.toString());  // Double을 문자열 "3.14"로 변환
         System.out.println(Double.parseDouble("3.14"));  // 문자열을 실수 3.14로 변환

         // Boolean 사용
         boolean b = (4>3); // b는 true

         System.out.println(Boolean.toString(b));  // true를 문자열 "true"로 변환
         System.out.println(Boolean.parseBoolean("false")); // 문자열을 false로 변환
    }
}
```


실행 결과는 다음과 같다.<br>


```java
a                // 'A'를 소문자로 변환
3은 숫자         // '3'은 숫자
D는 영문자       // 'D'는 영문자
33              // 문자열 "33"을 10진수로 변환
33              // 정수 33을 문자열로 변환
100001          // 33을 이진수 문자열로 변환
2               // 33에 대한 2진수의 1의 개수
33.0            // 정수 33을 double 값으로 변환 -> 33.0
3.14            // Double을 문자열 "3.14"로 변환
3.14            // 문자열을 실수 3.14로 변환
true            // true를 문자열 "true"로 변환
false           // 문자열을 false로 변환
```


### 박싱과 언박싱


기본 타입의 값을 Wrapper 객체로 변환하는 것을 박싱(boxing),<br>
반대의 경우를 언박싱(unboxing)이라고 한다.<br>


```java
Integer ten = Integer.valueOf(10);  // 박싱
int n = ten.intValue(); // 언박싱
```


JDK 1.5부터 박싱과 언박싱은 자동으로 이루어지며,<br>
이를 자동 박싱(auto boxing),<br>
자동 언박싱(auto unboxing)이라고 부른다.<br>
위의 코드를 이를 이용해 다음과 같이 간단하게 작성할 수 있다.<br>


```java
Integer ten = 10;   // 자동 박싱, Integer ten = Integer.valueOf(10); 과 동일
int n = ten;    // 자동 언박싱, int n = ten.intValue(); 과 동일
```





## 7. String과 StringBuffer 클래스


String 클래스는 문자열을 나타내며,<br>
String 리터럴은 String 객체로 처리된다.<br>
String 객체는 다음과 같이 생성할 수 있다.<br>


```java
String str1 = "abcd";   // String 리터럴로 String 객체 생성
char data[] = {'a', 'b', 'c', 'd'};
String str2 = new String(data);
String str3 = new String("abcd");   // str2, str3는 모두 "abcd" 문자열
```


하지만 리터럴로 생성된 String과<br>
new String()으로 생성된 String은 서로 다르게 관리된다.<br>


String 리터럴은 자바 내부에서 리터럴 테이블로<br>
특별히 관리하여, 동일한 리터럴은 하나의 객체를 공유한다.<br>
그러나 new String()에 의해 생성된 String은<br>
힙 메모리에 별도로 생성된다.<br>


```java
String a = "Hello";
String b = "Java";
String c = "Hello";

String d = new String("Hello");
String e = new String("Java");
String f = new String("Java");
```


위와 같은 코드가 있다고 할 때,<br>


a와 c는 String 리터럴 테이블에 있는 "Hello"를 공유하지만,<br>
d, e, f는 힙 메모리에 생성된 각각의 String을 가리킨다.<br>


### String 객체의 수정


String 리터럴로 생성되었든, new String()으로 생성되었든<br>
일단 생성된 String 객체는 수정이 불가능하다.<br>
따라서 리터럴로 만들어진 String 객체를<br>
여러 변수가 공유하더라도 값 변경으로 인한 문제가 발생하지 않는다.<br>


```java
String s = new String("Hello"); // s는 수정이 불가
String t = s.concat("Java");    // s에 "Java"를 덧붙인 String 리턴
```


위 코드에선 s와 t가 각각 "Hello", "HelloJava"를 가리킨다.<br>
만약 concat()으로 s를 변경하고 싶다면 다음과 같이 하면 된다.<br>


```java
s = s.concat("Java");
```


이러면 s는 s.concat("Java"); 가 리턴한<br>
새로운 문자열 "HelloJava"를 가리킨다.<br>


아래는 String 클래스의 주요 메소드들이다.<br>


### 1. char charAt(int index)

index 인덱스에 있는 문자 값을 리턴한다.<br>


### 2. int compareTo(String anotherString)

두 String을 사전적 순서를 기준으로 비교한다.<br>
두 String이 같으면 0,<br>
현재 String이 anotherString보다 먼저 나오면 음수,<br>
반대의 경우 양수를 리턴한다.<br>


### 3. String concat(String str)

str String을 현재 String에 덧붙인 새로운 String을 리턴한다.<br>


### 4. boolean contains(CharSequence s)

s에 지정된 문자들을 포함하고 있으면 true를 리턴한다.<br>


### 5. int length()

String의 길이(문자 개수)를 리턴한다.<br>


### 6. String replace(CharSequence target, CharSequence replacement)

target이 지정하는 일련의 문자들을<br>
replacement가 지정하는 문자들로 변경한 String을 리턴한다.<br>


### 7. String[] split(String regex)

정규식 regex에 일치하는 부분을 중심으로<br>
String을 분리하고, 배열에 저장하여 리턴한다.<br>


### 8. String substring(int beginIndex)

beginIndex 인덱스부터 시작하는 서브 String을 리턴한다.<br>


### 9. String toLowerCase()

소문자로 변경한 String을 리턴한다.<br>


### 10. String toUpperCase()

대문자로 변경한 String을 리턴한다.<br>


### 11. String trim()

String 앞뒤의 공백 문자들을 제거한 String을 리턴한다.<br>


눈여겨볼 부분은 String 비교 시 == 연산자를 사용하면 안 된다는 점이다.<br>
대신 compareTo() 메소드와 equals() 메소드를 사용한다.<br>
equals() 메소드는 String이 같으면 true, 아니면 false를 리턴한다.<br>


다음은 다양한 String 클래스 메소드들의 사용 예시이다.<br>


```java
public class StringEx {
    public static void main(String[] args) {
		String a = new String(" Hello@");   // 문자열 길이(문자 개수)
		String b = new String("Java");  // 문자열의 포함 관계

		System.out.println(a + "의 길이는 " + a.length());
		System.out.println(a.contains("@"));

		a = a.concat(b);    // 문자열 연결
		System.out.println(a);

		a = a.trim();   // 문자열 앞뒤 공백 제거
		System.out.println(a);

		a = a.replace("Java", "World"); // 문자열 대치
		System.out.println(a);

		String s[] = a.split("@");  // 문자열 분리
		for (int i = 0; i < s.length; i++) {
			System.out.println("분리된 문자열" + i + ":" + s[i]);
		}

		a = a.substring(6); // 인덱스 6부터 끝까지 서브 String 리턴
		System.out.println(a);

		char c = a.charAt(2);   // 인덱스 2의 문자 리턴
		System.out.println(c);
	}
}
```


실행 결과는 다음과 같다.<br>


```java
 Hello@의 길이는 7
true
 Hello@Java
Hello@Java
Hello@World
분리된 문자열0:Hello
분리된 문자열1:World
World
r
```


### StringBuffer 클래스


StringBuffer 클래스는 문자열을 다루는 클래스로서,<br>
내부에 가변 크기의 버퍼를 가지고 문자의 개수에 따라<br>
버퍼 크기를 자동으로 조절한다.<br>


그러므로 String 객체와 달리, 생성된 String의 수정이 가능하다.<br>
StringBuffer 클래스의 객체는 다음과 같이 생성한다.<br>


```java
StringBuffer sb = new StringBuffer("Java"); 
```


문자열이 길거나 문자열 작업이 많은 경우,<br>
String 클래스보다 StringBuffer 클래스를 이용하는 것이 적합하다.<br>
다음은 StringBuffer 클래스의 활용 예시이다.<br>


```java
public class StringBufferEx {
    public static void main(String[] args) {
		StringBuffer sb = new StringBuffer("Hello");
		sb.append(" World!");
		System.out.println(sb);
		sb.insert(5, "@");
		System.out.println(sb);
		sb.replace(6, 12,"Java");
		System.out.println(sb);
	}
}
```


실행 결과는 다음과 같다.<br>


```java
Hello World!
Hello@ World!
Hello@Java!
```






## 8. StringTokenizer 클래스


StringTokenizer 클래스는 문자열을 분리하기 위해 사용된다.<br>
문자열을 분리할 때 사용되는 기준 문자를 구분 문자(delimiter)라고 한다.<br>
그리고 구분 문자로 분리된 문자열을 토큰(token)이라고 한다.<br>


아래는 StringTokenizer 클래스의 주요 메소드들이다.<br>


### 1. StringTokenizer(String str)

str String으로 파싱한 StringTokenizer를 생성한다.<br>


### 2. int countTokens()

StringTokenizer에 포함된 토큰의 개수를 리턴한다.<br>


### 3. boolean hasMoreTokens()

StringTokenizer에 다음 토큰이 있으면 true를 리턴한다.<br>


### 4. String nextToken()

다음 토큰을 리턴한다.<br>


다음은 StringTokenizer 클래스의 활용 예시이다.


```java
public class StringTokenizerEx {
    public static void main(String[] args) {
		String query = "name=jaeseo&addr=yongin&age=25";
		StringTokenizer st = new StringTokenizer(query, "&");
		
		int n = st.countTokens();   // 분리된 토큰 개수
		System.out.println("토큰 개수 = " + n);
		
		while(st.hasMoreTokens()) { // 토큰이 남아있는 동안 반복, for(int i = 0; i < n; i++)과 동일
			String token = st.nextToken();  // 토큰 얻기
			System.out.println(token);  // 토큰 출력
		}
	}
}
```


실행 결과는 다음과 같다.<br>


```java
토큰 개수 = 3
name=jaeseo
addr=yongin
age=25
```






## 9. Math 클래스


Math 클래스는 기본적인 산술 연산을 수행하는<br>
메소드를 제공하는 클래스이다.<br>
모든 메소드가 static 타입이기 때문에<br>
'Math.메소드' 형태로 사용할 수 있다.<br>


아래는 Math 클래스의 주요 메소드들이다.<br>


### 1. static double abs(double a)

실수 a의 절댓값을 리턴한다.<br>


### 2. static double exp(double a)

e의 a제곱 값을 리턴한다.<br>


### 3. static double sin(double a)

실수 a의 sine 값을 리턴한다.<br>


### 4. static double random()

0.0보다 크거나 같고 1.0보다 작은 임의의 실수를 리턴한다.<br>
Math.random()은 중복 값을 허용하기 때문에,<br>
중복이 없어야 하는 경우 추가 처리가 필요하다.<br>


### 5. static long round(double a)

실수 a를 소수 첫째 자리에서 반올림한 정수를 long 타입으로 반환한다.<br>


### 6. static double sqrt(double a)

실수 a의 제곱근을 리턴한다.<br>


다음은 Math 클래스의 활용 예시이다.<br>


```java
public class MathEx {
    public static void main(String[] args) {
		System.out.println(Math.abs(-3.14));	// 절댓값 구하기
		System.out.println(Math.sqrt(9.0));		// 제곱근
		System.out.println(Math.exp(2));		// e의 2제곱
		System.out.println(Math.round(3.14));	// 반올림
		
		
		System.out.println("이번주 행운의 번호는 ");
		
		for(int i = 0; i < 7; i++) {
			System.out.print((int)(Math.random() * 45 + 1) + " ");	// 난수 발생
		}
	}
}
```


실행 결과는 다음과 같다.<br>


```java
3.14
3.0
7.38905609893065
3
이번주 행운의 번호는 
43 34 30 42 10 17 3 
```


-----------------------------------------------------------------------<br>


지금까지 자바의 모듈과 패키지에 대해 공부해 보았다.<br>
다음 글에서는 자바의 컬렉션과 제네릭에 대해서 공부해 보겠다.<br>


---
※ 본 글은 개인 학습을 목적으로 「명품 자바 에센셜」(황기태 지음, 생능출판)을 참고하여 작성하였습니다.