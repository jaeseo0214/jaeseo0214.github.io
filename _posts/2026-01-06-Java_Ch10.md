---
layout: single
title: "Java Chapter 10 – 자바 GUI 스윙"
date: 2026-01-06
categories:
  - Java
  - java_grammer
tags: [Java, 문법]
author_profile: true
read_time: true
comments: true
share: true
related: true
sidebar:
  nav: "categories_sidebar"
---


# 자바의 GUI


GUI(Graphical User Interface)란,<br>
이미지 혹은 그래픽으로 그린<br>
버튼, 메뉴 등을 가진 화면에<br>
마우스와 같은 편리한 입력 도구를 이용하여<br>
사용자가 편리하게 입출력할 수 있도록 만든<br>
사용자 인터페이스이다.<br>

자바는 GUI 프로그램을 작성할 수 있도록<br>
표준 라이브러리를 제공한다.<br>






## 1. AWT와 Swing 패키지


자바는 GUI 기반의 응용 프로그램 작성을 위해<br>
다양한 GUI 컴포넌트(GUI component)를 제공한다.<br>

자바의 GUI 컴포넌트는<br>
AWT 컴포넌트와 Swing 컴포넌트로 구분되며,<br>
각각 java.awt 패키지와 javax.swing 패키지를 통해 제공된다.<br>


### AWT(Abstract Windowing Toolkit)


AWT는 자바 초기부터 제공된 GUI 패키지이다.<br>
AWT 컴포넌트는 각 운영체제에서 제공하는<br> 
네이티브 GUI 컴포넌트에 의존하여 구현된다.<br>
이러한 특성으로 인해 AWT 컴포넌트는<br>
중량 컴포넌트(Heavyweight component)라고 불린다.<br>


### Swing


Swing은 AWT를 기반으로 만들어진 GUI 툴킷이다.<br>

Swing 컴포넌트는<br>
운영체제의 네이티브 GUI 컴포넌트에 직접 의존하지 않고<br>
자바 코드로 구현되어 있으며,<br>
이로 인해 경량 컴포넌트(Lightweight component)라고 불린다.<br>

Swing은 AWT보다<br>
더 많은 GUI 컴포넌트와 기능을 제공한다.<br>

Swing 컴포넌트는<br>
AWT 컴포넌트와 구별하기 위해<br>
컴포넌트 이름이 모두 J로 시작한다.<br>

Swing은 AWT를 기반으로 하여 구현되었기 때문에<br>
AWT 패키지를 사용한다.<br>






## 2. 자바의 GUI 패키지


모든 GUI 컴포넌트들은<br>
java.awt.Component 클래스를 상속받은 클래스이다.<br>
그 중 대부분의 스윙 컴포넌트의 클래스 이름은 J로 시작한다.<br>


### 컨테이너(Container)


컨테이너란 컴포넌트를 포함할 수 있는<br>
특별한 GUI 컴포넌트이다.<br>

컨테이너는 java.awt.Container 클래스를 상속받은 클래스이다.<br>
Container 클래스는 java.awt.Component를<br>
상속받기 때문에, 컨테이너 또한 컴포넌트이다.<br>

그러므로 컨테이너는 다른 컨테이너에<br>
컴포넌트로 포함될 수 있다.<br>

컨테이너 클래스는 다음과 같다.<br>


```java
Frame, Panel, Dialog, Window  // AWT 컨테이너
JFrame, JPanel, JDialog, JWindow // 스윙 컨테이너
```


### 컴포넌트(Component)


컴포넌트는 화면에 출력될 수 있는 GUI 요소이며,<br>
이 중 컨테이너가 아닌 컴포넌트는<br>
다른 컴포넌트를 포함할 수 없고<br>
컨테이너에 포함되어야만 화면에 표시될 수 있다.<br>

AWT나 스윙의 모든 컴포넌트들은 java.awt.Component를 상속받기 때문에,<br>
Component 클래스는 모든 컴포넌트들의 공통적인 요소들을 구현하고 있다.<br>

최상위 컨테이너를 제외한<br>
대부분의 스윙 컴포넌트들은<br>
javax.swing.JComponent를 상속받는다.<br>
JComponent는 스윙 컴포넌트들의 공통적인 기능을 구현하고 있다.<br>


### 최상위 컨테이너(Top Level Container)


컨테이너 중에서 다른 컨테이너에 속하지 않고도<br>
독립적으로 존재하여 출력될 수 있는 컨테이너를<br>
최상위 컨테이너라고 한다.<br>






## 3. 스윙 GUI 프로그램 만들기


스윙으로 GUI 응용프로그램을 만들 때<br>
일반적으로 다음과 같은 과정을 거친다.<br>


1. 스윙 프레임 작성<br>

2. main() 메소드 작성<br>

3. 프레임에 스윙 컴포넌트 붙이기<br>


### 스윙 패키지 import


스윙 컴포넌트들을 사용하기 위해서는<br>
관련 패키지를 import 해야 한다.<br>


```java
import javax.swing.*;
```


GUI 프로그램은 이미지나 도형을 다루는 클래스와<br>
이벤트 처리를 위한 클래스를 사용하기 때문에,<br>
다음 import 문이 필요한 경우가 많다.<br>


```java
import java.awt.*;  // 그래픽 처리를 위한 클래스들의 경로명
import java.awt.event.*;  // AWT 이벤트 사용을 위한 경로명
import javax.swing.*; // 스윙 컴포넌트 클래스들의 경로명
import javax.swing.event.*; // 스윙 이벤트를 위한 경로명
```


### 스윙 프레임과 컨텐트팬


JFrame은 스윙에서 사용되는<br>
대표적인 최상위 컨테이너 중 하나이다.<br>

프레임이 출력될 때,<br>
프레임 내에 부착된 모든 컴포넌트들이 화면에 출력된다.<br>

컴포넌트들은 프레임 없이 독립적으로 화면에 출력될 수 없으므로,<br>
프레임이 닫히면 프레임 내의 모든 컴포넌트들도 함께 사라진다.<br>

스윙 컴포넌트들은 Content Pane에 부착되며,<br>
메뉴는 JMenuBar를 통해 프레임에 설정된다.<br>






## 4. JFrame을 상속하여 프레임 만들기


스윙 응용프로그램의 프레임은<br>
JFrame을 상속받아 만든다.<br>

다음 예제는 JFrame을 상속받아<br>
3개의 버튼이 달린 스윙 프레임을 만드는 코드이다.<br>


```java
public class MyFrame extends JFrame {

	public MyFrame() {
		setTitle("스윙 프레임 만들기"); // 프레임 제목 설정
		// super("스윙 프레임 만들기"); // 프레임 제목 설정 방법 2
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 프레임 윈도우를 닫으면 프로그램 종료

		Container contentPane = getContentPane(); // 컨텐트팬 알아내기
		contentPane.setBackground(Color.BLACK); // 배경색 설정
		contentPane.setLayout(new FlowLayout()); // FlowLayout 배치 관리자 달기

		// 컨텐트팬에 버튼 달기
		contentPane.add(new JButton("Open"));
		contentPane.add(new JButton("Close"));
		contentPane.add(new JButton("Ignore"));

		setSize(500, 500); // 사이즈 설정(픽셀)
		setVisible(true); // 프레임 화면에 표시, false -> 프레임 숨겨짐
	}

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		MyFrame frame = new MyFrame();
	}

}
```


실행 결과는 다음과 같다.<br>


![스윙 프레임 예시](/assets/images/스윙%20프레임%20예시.PNG)<br>


### 컨텐트 팬(ContentPane)


스윙에서 JFrame 객체가 생성될 때,<br> 
컨텐트팬(ContentPane)은 자동으로 생성된다.<br>
그러므로 프레임에 붙어있는 컨텐트팬을 얻은 후,<br>
그 위에 스윙 컴포넌트들을 부착하면 된다.<br>

참고로 Java 5 이후부터는<br> 
JFrame의 add() 메소드를 사용하면<br>
내부적으로 컨텐트팬에 컴포넌트가 추가되므로,<br>
getContentPane() 메소드를 직접 호출하지 않아도 된다.<br>
다만 학습 목적이나 명확한 구조 이해를 위해<br>
컨텐트팬을 명시적으로 사용하는 것도 좋다.<br>


### 프레임 종료 버튼과 기본 동작


사용자가 프레임 윈도우의 오른쪽 상단에 있는<br>
프레임 종료버튼(X)을 누를 경우,<br>
기본적으로는 프레임 윈도우만 닫힐 뿐<br>
스윙 응용프로그램은 종료되지 않는다.<br>

이는 JFrame의 기본 종료 동작이<br>
HIDE_ON_CLOSE로 설정되어 있기 때문이다.<br>


### main() 메소드와 스윙 프로그램의 실행 상태


스윙 응용프로그램에서<br>
main() 메소드의 기능은 최소화 하는 것이 좋다.<br>

main() 메소드는 스윙 프레임을 생성한 뒤<br>
곧바로 종료되지만,<br>
이후에도 스윙 프로그램은 계속 실행 상태로 남아 있다.<br>

그 이유는 스윙 프레임이 생성될 때<br>
AWT/Swing 시스템에 의해<br>
이벤트 디스패치 스레드(Event Dispatch Thread, EDT)가
생성되어 실행되기 때문이다.<br>

이 이벤트 디스패치 스레드는<br>
키보드 입력과 마우스 움직임과 같은 사용자 이벤트를<br>
GUI 컴포넌트에 전달하는 역할을 하며,<br>
해당 스레드가 실행 중인 한 자바 프로그램은 종료되지 않는다.<br>


### 프로그램 종료 설정


따라서 프레임 윈도우가 닫힐 때<br>
스윙 응용프로그램도 함께 종료되도록 하려면,<br>
다음과 같이 종료 동작을 설정해야 한다.<br>


```java
setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
```


이 설정을 통해 프레임이 닫히는 순간<br>
스윙 응용프로그램이 정상적으로 종료된다.<br>






## 5. 컨테이너(Container)와 배치(Layout)


컨테이너에 부착되는 컴포넌트의 위치와 크기는<br>
컨테이너 내부에 있는 배치관리자(Layout Manager)에 의해 결정된다.<br>

AWT나 스윙의 컨테이너는 다음과 같은 특징을 가진다.<br>

1. 컨테이너는 하나의 배치관리자를 가진다.<br>

2. 컨테이너에 컴포넌트가 부착되면,<br>
배치관리자는 적절한 시점에 컴포넌트의 위치와 크기를 결정한다.<br>

3. 컨테이너의 크기가 변경되면 배치관리자는<br> 
컨테이너의 모든 컴포넌트들의 위치와 크기를 재조정한다.<br>


자바는 여러 종류의 배치관리자를 지원한다.<br>
배치관리자는 java.awt 패키지의 클래스들이며,<br>
사용을 위해선 다음과 같이 import 해야 한다.<br>


```java
import java.awt.*;
```


### 배치관리자 - FlowLayout


컨테이너 내부에 삽입되는 순서대로<br>
왼쪽에서 오른쪽으로 컴포넌트를 배치한다.<br>
만약 오른쪽에 더 이상 배치 공간이 남아있지 않으면,<br>
내려와서 다시 왼쪽에서 오른쪽으로 배치한다.<br>
컴포넌트의 크기는 화면에 출력될 수 있는 적당한 크기로 설정한다.<br>

Panel, JPanel 의 디폴트 배치관리자이다.<br>


### 배치관리자 - BorderLayout


컨테이너의 공간을 동, 서, 남, 북, 중앙의 5개 영역으로 나눈다.<br>
응용프로그램에서 지정한 영역에 컴포넌트를 배치하며,<br>
컴포넌트의 크기는 영역의 크기와 동일하게 설정한다.<br>
중앙(CENTER) 영역은 나머지 영역을 제외한 모든 공간을 차지한다.<br>

Window, JWindow, Frame, JFrame, Dialog, JDialog 의<br>
디폴트 배치관리자이다.<br>


### 배치관리자 - GridLayout


컨테이너의 공간을 응용프로그램에서 설정한<br>
동일한 크기의 2차원 그리드로 나누고,<br>
컴포넌트가 들어오는 순서대로 좌에서 우로,<br>
다시 위에서 아래로 순서대로 배치한다.<br>
컴포넌트의 크기는 셀의 크기와 일치시킨다.<br>


### 배치관리자 - CardLayout


컨테이너의 공간에 카드를 쌓아 놓은 듯이<br>
컴포넌트들을 포개어 배치한다.<br>
컴포넌트의 크기는 컨테이너의 크기와 일치시킨다.<br>


### 컨테이너에 새로운 배치관리자 설정


Container 클래스의 setLayout() 메소드를 호출하면,<br>
컨테이너에 새로운 배치관리자를 설정할 수 있다.<br>


```java
JPanel p = new JPanel();
p.setLayout(new BorderLayout());
```


```java
Container c = frame.getContentPane();
c.setLayout(new FlowLayout());
```






## 6. FlowLayout 배치관리자


FlowLayout 배치관리자는<br>
컴포넌트를 왼쪽에서 오른쪽으로 배치하고,<br>
오른쪽 공간이 없으면 아래로 내려와서 배치한다.<br>


FlowLayout의 생성자에<br>
컴포넌트 사이의 간격과 정렬 방식을 지정할 수 있다.<br>


```java
FlowLayout()
FlowLayout(int align, int hGap, int vGap)
```

[

  * align: 컴포넌트를 정렬하는 방법 지정.<br>
  왼쪽 정렬(FlowLayout.LEFT),<br>
  오른쪽 정렬(FlowLayout.RIGHT),<br>
  중앙 정렬(FlowLayout.CENTER(디폴트))<br>

  * hGap: 좌우 두 컴포넌트 사이의 수평 간격, 픽셀 단위. 디폴트는 5<br>

  * vGap: 상하 두 컴포넌트 사이의 수직 간격, 픽셀 단위. 디폴트는 5<br>

]


다음은 FlowLayout 배치관리자의 활용 예시이다.<br>


```java
public class FlowLayoutEx extends JFrame {

	public FlowLayoutEx() {
		setTitle("FlowLayout 배치관리자");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		Container contentPane = getContentPane(); // 컨텐트팬 알아내기

		// 왼쪽 정렬, 수평 간격 30, 수직 간격 50 픽셀로 배치하는 FlowLayout 생성
		contentPane.setLayout(new FlowLayout(FlowLayout.LEFT, 30, 50));

		contentPane.add(new JButton("add"));
		contentPane.add(new JButton("sub"));
		contentPane.add(new JButton("mul"));
		contentPane.add(new JButton("div"));
		contentPane.add(new JButton("Calculate"));

		setSize(300, 300); // 프레임 크기 설정
		setVisible(true);
	}

	public static void main(String[] args) {
		new FlowLayoutEx();
	}

}
```


실행 결과는 다음과 같다.<br>


![FlowLayout 배치관리자](/assets/images/FlowLayout%20배치관리자.PNG)






## 7. BorderLayout 배치관리자


BorderLayout 배치관리자는<br>
컨테이너 공간을 동, 서, 남, 북, 중앙의<br>
5개의 영역으로 분할하여 배치한다.<br>


BorderLayout 배치관리자는 다른 단순 배치관리자와 달리,<br>
컴포넌트를 추가할 때 위치 정보를 함께 지정해야 한다.<br>


```java
void add(Component comp, Object constraints)
```


[

  * comp: 컨테이너에 삽입되는 컴포넌트

  * constraints: 컴포넌트가 배치될 영역

  `동: BorderLayout.EAST` --- `서: BorderLayout.WEST`<br>

  `남: BorderLayout.SOUTH` --- `북: BorderLayout.NORTH`<br>

  `중앙: BorderLayout.CENTER`

]


BorderLayout의 생성자를 이용하여<br>
컴포넌트 사이의 간격을 조정할 수 있다.<br>


```java
BorderLayout()
BorderLayout(int hGap, int vGap)
```


[
  
  * hGap: 좌우 두 컴포넌트 사이의 수평 간격, 픽셀 단위. 디폴트는 0

  * vGap: 상하 두 컴포넌트 사이의 수직 간격, 픽셀 단위. 디폴트는 0


]


다음은 BorderLayout 배치관리자의 활용 예시이다.<br>


```java
public class BorderLayoutEx extends JFrame {

	public BorderLayoutEx() {
		setTitle("BorderLayout 배치관리자");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		Container contentPane = getContentPane(); // 컨텐트팬 알아내기

		// 컨텐트팬에 BorderLayout 배치관리자 설정
		contentPane.setLayout(new BorderLayout(30, 30)); // 수평 간격 30, 수직 간격 30

		contentPane.add(new JButton("Calculate"), BorderLayout.CENTER);
		contentPane.add(new JButton("add"), BorderLayout.NORTH);
		contentPane.add(new JButton("sub"), BorderLayout.SOUTH);
		contentPane.add(new JButton("mul"), BorderLayout.EAST);
		contentPane.add(new JButton("div"), BorderLayout.WEST);

		setSize(300, 300); // 프레임 크기 설정
		setVisible(true);
	}

	public static void main(String[] args) {
		new BorderLayoutEx();
	}

}
```


실행 결과는 다음과 같다.<br>


![BorderLayout 배치관리자](/assets/images/BorderLayout%20배치관리자.PNG)


BorderLayout 컨테이너에 5개 이상의 컴포넌트를 부착하고자 하면,<br>
동서남북중앙 중 한 영역에 JPanel을 부착하고<br>
여기에 여러 컴포넌트를 부착하면 된다.<br>






## 8. GridLayout 배치관리자


GridLayout은 컨테이너 공간을 그리드(격자) 모양으로 분할하여<br>
각 셀에 하나씩 컴포넌트를 배치하는 방법이다.<br>
GridLayout은 컴포넌트가 부착되는 순서대로 셀에 배치한다.<br>
또한 GridLayout은 모든 컴포넌트를 동일한 크기로 배치한다.<br>

컴포넌트 삽입 방법은 마찬가지로 add() 메소드를 사용한다.<br>


GridLayout의 생성자로 격자 분할과 간격을 설정할 수 있다.<br>


```java
GridLayout()
GridLayout(int rows, int cols)
GridLayout(int rows, int cols, int hGap, int vGap)
```


[

  * rows: 그리드의 행 수, 디폴트는 1

  * cols: 그리드의 열 수, 디폴트는 0

  * hGap: 좌우 두 컴포넌트 사이의 수평 간격, 픽셀 단위. 디폴트는 0

  * vGap: 상하 두 컴포넌트 사이의 수직 간격, 픽셀 단위. 디폴트는 0

]


격자의 셀 수보다 많은 컴포넌트가 추가되면,<br>
생성자에서 지정한 행 수와 열 수가 지켜지지 않으며,<br>
모든 컴포넌트를 수용하도록 행과 열의 수가 적당히 변형된다.<br>


다음은 GridLayout 배치관리자의 활용 예시이다.<br>


```java
public class GridLayoutEx extends JFrame {

	public GridLayoutEx() {
		super("GridLayout 배치관리자"); // JFrame 의 생성자를 호출하여 타이틀 설정
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		Container contentPane = getContentPane(); // 컨텐트팬 알아내기

		contentPane.setLayout(new GridLayout(1, 10)); // 1X10 의 GridLayout 배치관리자

		for (int i = 0; i < 10; i++) {
			String text = Integer.toString(i); // 정수 i 를 문자열로 변환
			JButton button = new JButton(text); // 버튼 컴포넌트 생성
			contentPane.add(button); // 컨텐트팬에 버튼 부착
		}

		setSize(500, 300); // 프레임 크기 설정
		setVisible(true);
	}

	public static void main(String[] args) {
		new GridLayoutEx();
	}

}
```


실행 결과는 다음과 같다.<br>


![GridLayout 배치관리자](/assets/images/GridLayout%20배치관리자.PNG)






## 9. 배치관리자가 없는 컨테이너


모든 컨테이너는 기본적으로 배치관리자를 가지고 있으며,<br>
배치관리자에 의해 컴포넌트의 위치와 크기가<br>
자동으로 결정되는 것이 자바 GUI의 기본 방식이다.<br>

배치관리자는 컴포넌트를 절대 좌표가 아닌<br>
다른 컴포넌트와의 상대적인 위치를 기준으로 배치한다.<br>

따라서 컨테이너의 크기가 변경되면,<br>
컴포넌트의 위치와 크기 역시 함께 변경된다.<br>

이처럼 배치관리자를 사용하면<br>
컴포넌트의 위치를 직접 계산하지 않아도 되는 장점이 있지만,<br>
컴포넌트의 위치와 크기를 정확히 제어해야 하는 경우에는<br>
오히려 불편할 수 있다.<br>

이럴 때는 컨테이너의 배치관리자를 제거하고,<br>
응용프로그램에서 컴포넌트의 위치와 크기를<br>
직접 지정하도록 설정할 수 있다.<br>

배치관리자는 Container 클래스의<br>
setLayout() 메소드를 이용해 제거할 수 있다.<br>


```java
JPanel p = new JPanel();
p.setLayout(null);  // 배치관리자 삭제
```


이 경우 패널 p에는 배치관리자가 없으므로,<br>
컴포넌트를 추가하더라도 기본 크기가 설정되지 않아<br>
화면에 보이지 않을 수 있다.<br>

따라서 배치관리자가 없는 컨테이너에<br>
컴포넌트를 삽입할 때는,<br>
응용프로그램에서 컴포넌트의 위치와 크기를<br>
반드시 직접 설정해야 한다.<br>

컴포넌트의 절대 위치와 크기를 설정하기 위해서는<br>
다음 메소드들을 사용한다.<br>


```java
void setSize(int width, int height) // 컴포넌트를 width x height 크기로 설정
void setLocation(int x, int y)  // 컴포넌트 왼쪽 상단 모서리 좌표를 (x, y) 로 설정
void setBounds(int x, int y, int width, int height) // 크기와 위치 동시 설정
```


CardLayout을 제외한 대부분의 배치관리자는<br>
컴포넌트들이 서로 겹치지 않도록 배치한다.<br>

반면 배치관리자가 없는 컨테이너에서는<br>
컴포넌트를 절대 위치와 절대 크기로 배치할 수 있기 때문에,<br>
컴포넌트들이 서로 겹치도록 배치하는 것도 가능하다.<br>

하지만 배치관리자를 사용하지 않는 방식(null layout)은<br>
창 크기 변경이나 다양한 해상도 환경에 대응하기 어렵기 때문에,<br>
특별한 경우를 제외하고는 권장되지 않는다.<br>


다음은 배치관리자가 없는 컨테이너의 활용 예시이다.<br>


```java
public class NullContainerEx extends JFrame {

	public NullContainerEx() {
		setTitle("배치관리자가 없는 컨테이너");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		Container contentPane = getContentPane(); // 컨텐트팬 알아내기

		contentPane.setLayout(null); // 컨텐트팬의 배치관리자 제거

		// JLabel 컴포넌트를 생성하고, 절대 위치와 크기를 직접 지정
		JLabel la = new JLabel("Hello, Press Buttons!");
		la.setLocation(130, 50); // la 를 (130, 50) 위치로 지정
		la.setSize(200, 30); // la 를 200x30 크기로 지정
		contentPane.add(la); // 컨텐트팬에 la 부착

		// 9개의 버튼 컴포넌트를 생성하고, 동일한 크기로 설정
		// 위치는 서로 겹치게 설정
		for (int i = 1; i <= 9; i++) {
			JButton b = new JButton(Integer.toString(i)); // 버튼 생성
			b.setLocation(i * 15, i * 15); // 버튼 위치 설정
			b.setSize(50, 30); // 버튼 크기는 모두 동일 50x30
			contentPane.add(b); // 컨텐트팬에 b 부착
		}

		setSize(300, 300); // 프레임 크기 설정
		setVisible(true);
	}

	public static void main(String[] args) {
		new NullContainerEx();
	}

}
```


실행 결과는 다음과 같다.<br>


![배치관리자가 없는 컨테이너](/assets/images/배치관리자가%20없는%20컨테이너.PNG)


-----------------------------------------------------------------------<br>


지금까지 자바의 GUI 스윙에 대해 공부해 보았다.<br>
다음 글에서는 자바의 이벤트 처리에 대해서 공부해 보겠다.<br>


---
※ 본 글은 개인 학습을 목적으로 「명품 자바 에센셜」(황기태 지음, 생능출판)을 참고하여 작성하였습니다.