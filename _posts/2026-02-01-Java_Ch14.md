---
layout: single
title: "Java Chapter 14 – 스레드 기초"
date: 2026-02-01
categories:
  - Java
  - java_grammer
tags: [Java, 문법]
author_profile: true
read_time: true
comments: true
share: true
related: true
sidebar:
  nav: "categories_sidebar"
---


# 자바 스레드 기초





## 1. 자바 스레드 기초


### [프로세스와 스레드]


프로세스(process)는 운영체제에서 실행 중인 하나의 프로그램이다.<br>
각 프로세스는 독립된 메모리 공간을 가지며,<br> 
다른 프로세스와 메모리를 직접 공유하지 않는다.<br>

스레드(thread)는 하나의 프로세스 내부에서<br> 
실행되는 독립적인 실행 흐름(execution path) 이다.<br>
하나의 프로세스는 하나 이상의 스레드를 가질 수 있으며,<br>
같은 프로세스에 속한 스레드들은 메모리 공간을 공유한다.<br>


---


### [자바 프로그램과 JVM]


자바 프로그램은 운영체제 상에서 하나의 프로세스로 실행된다.<br>
이 프로세스 내부에서 JVM(Java Virtual Machine) 이 동작한다.<br>

JVM은 자바 바이트코드를 실행하는 가상 머신으로,<br>
메모리 관리, 스레드 관리, 가비지 컬렉션 등의 기능을 제공한다.<br>

일반적인 Java SE 환경에서<br>
하나의 JVM은 하나의 자바 애플리케이션을 실행하며,<br>
애플리케이션이 종료되면 JVM도 함께 종료된다.<br>


---


### [자바 스레드]


자바 스레드는 JVM에 의해 생성되고 관리되는 실행 단위이다.<br>
각 스레드는 Thread 클래스 또는<br> 
Runnable 인터페이스를 통해 생성되며,<br>
run() 메소드에 정의된 코드를 실행한다.<br>


---


### [스레드의 주요 구성 요소]


자바 스레드는 다음과 같은 속성을 가진다.<br>

* 실행 코드 (run() 메소드)

* 스레드 ID

* 스레드 이름(Name)

* 우선순위(Priority)

* 상태(State)

* 스택(Stack)

* 데몬 스레드 여부(Daemon)

이러한 정보는 JVM과 운영체제에 의해 관리된다.<br>


---


### [멀티스레딩]


멀티스레딩(multi-threading)이란<br>
하나의 프로세스 내에서 여러 스레드를<br> 
동시에 실행하는 프로그래밍 기법이다.<br>

자바는 JVM 차원에서 멀티스레딩을 지원하며,<br>
자바 애플리케이션은 하나 이상의 스레드를 생성하여<br>
병렬 처리 또는 동시 처리를 수행할 수 있다.<br>


---


### [핵심 정리]


* 자바 프로그램은 운영체제에서 프로세스로 실행된다.

* JVM은 운영체제가 아니라, 운영체제 위에서 동작하는 가상 머신이다.

* 자바 스레드는 프로세스 내부의 실행 흐름이다.

* JVM은 스레드를 관리하지만, 실제 스케줄링은 운영체제가 담당한다.

* 멀티스레딩을 통해 자바 애플리케이션은 동시에 여러 작업을 수행할 수 있다.






## 2. 자바 스레드 만들기


사용자는 다음과 같은 방법으로<br>
스레드를 만들 수 있다.<br>


1. Thread 클래스 이용<br>

2. Runnable 인터페이스 이용<br>


---


### [Thread 클래스로 스레드 만들기]


Thread 클래스의 경로명은 java.lang.Thread이며,<br>
Thread 클래스를 상속받아 새로운 스레드를 만들 수 있다.<br>

다음은 Thread 클래스의 주요 메소드를 정리한 표이다.<br>


![Thread 클래스 주요 메소드](/assets/images/Thread%20클래스%20주요%20메소드.png)


다음은 Thread 클래스를 상속받아 스레드를 만드는 예제이다.<br>


```java
class TimerThread extends Thread {
	private JLabel timerLabel; // 타이머 값이 출력되는 레이블

	public TimerThread(JLabel timerLabel) {
		this.timerLabel = timerLabel; // 타이머 카운트를 출력할 레이블
	}

	// 스레드 코드. run() 이 종료하면 스레드 종료
	@Override
	public void run() {
		int n = 0; // 타이머 카운트 값

		while (true) {
			timerLabel.setText(Integer.toString(n)); // 레이블에 카운트 값 출력
			n++; // 카운트 값 증가

			try {
				Thread.sleep(1000); // 1초 동안 잠을 잠.
			} catch (InterruptedException e) {
				return; // 예외가 발생하면 스레드 종료
			}
		}
	}
}

public class ThreadTimerEx extends JFrame {

	public ThreadTimerEx() {
		setTitle("ThreadTimer 예제");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		Container c = getContentPane();
		c.setLayout(new FlowLayout());

		// 타이머 값을 출력할 레이블 생성
		JLabel timerLabel = new JLabel();
		timerLabel.setFont(new Font("Gothic", Font.ITALIC, 80));
		c.add(timerLabel);

		// 타이머 스레드 객체 생성. 타이머 값을 출력할 레이블을 생성자에 전달
		TimerThread th = new TimerThread(timerLabel);

		setSize(250, 150);
		setVisible(true);

		th.start(); // 타이머 스레드 실행 시작 -> TimerThread 의 run() 메소드가 실행 시작
	}

	public static void main(String[] args) {
		new ThreadTimerEx();
	}
}
```


Thread.sleep() 메소드는 현재 실행 중인 스레드를<br>
일정 시간 동안 잠시 멈추게 하는 메소드이다.<br>

하지만 스레드가 잠들어 있는 동안<br>
다른 스레드가 interrupt()를 호출하면<br>
잠을 즉시 깨우기 위해 InterruptedException이 발생한다.<br>

자바에서는 이 예외를 반드시 처리하도록 되어 있으므로,<br>
sleep()을 사용하는 코드는<br>
try–catch 블록으로 InterruptedException을 처리해야 한다.<br>

이 예제에서는<br>
인터럽트가 발생하면 타이머를 계속 실행할 필요가 없기 때문에,<br>
catch 블록에서 run() 메소드를 종료하여<br>
스레드를 정상적으로 끝내도록 하였다.<br>


실행 결과는 다음과 같다.<br>


![ThreadTimer 예제](/assets/images/ThreadTimer%20예제.PNG)


---


### [Runnable 인터페이스로 스레드 만들기]


Runnable 인터페이스의 경로명은 java.lang.Runnable이며,<br>
다음과 같이 추상 메소드 run()만 가지고 있는 인터페이스이다.<br>


```java
interface Runnable {
  public void run();
}
```


그러므로 인터페이스 Runnable의 run()을<br>
구현하여 스레드에서 실행할 작업 클래스를 만든다.<br>

다음은 앞에서 만든 스레드 타이머를<br>
인터페이스를 이용해 구현하는 예제이다.<br>


```java
class TimerRunnable implements Runnable {

	private JLabel timerLabel; // 타이머 값이 출력될 레이블

	public TimerRunnable(JLabel timerLabel) {
		this.timerLabel = timerLabel; // 초 카운트를 출력할 레이블
	}

	// 스레드 코드. run() 이 종료하면 스레드 종료
	@Override
	public void run() {
		int n = 0; // 타이머 카운트 값

		while (true) {
			timerLabel.setText(Integer.toString(n)); // 레이블에 카운트 값 출력
			n++; // 카운트 값 증가

			try {
				Thread.sleep(1000); // 1초 동안 잠을 잠.
			} catch (InterruptedException e) {
				return; // 예외가 발생하면 스레드 종료
			}
		}
	}
}

public class RunnableTimerEx extends JFrame {

	public RunnableTimerEx() {
		setTitle("RunnableTimer 예제");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		Container c = getContentPane();
		c.setLayout(new FlowLayout());

		// 타이머 값을 출력할 레이블 생성
		JLabel timerLabel = new JLabel();
		timerLabel.setFont(new Font("Gothic", Font.ITALIC, 80));
		c.add(timerLabel);

		// 타이머 스레드 객체 생성. 타이머 값을 출력할 레이블을 생성자에 전달
		TimerRunnable runnable = new TimerRunnable(timerLabel);
		Thread th = new Thread(runnable);

		setSize(250, 150);
		setVisible(true);

		th.start(); // 타이머 스레드 실행 시작 -> TimerRunnable 의 run() 메소드가 실행 시작
	}

	public static void main(String[] args) {
		new RunnableTimerEx();
	}
}
```


실행 결과는 클래스를 상속받아 만들었던 예제와 동일하다.<br>


---


### [두 방법의 차이점]


1️⃣ Thread 상속 (extends Thread)<br>

* 클래스 자체가 스레드 객체가 됨

* run() 메소드 안에 스레드가 실행할 코드 작성

* 스레드 시작: start() 호출 → JVM이 별도 스레드에서 run() 실행

* 특징:

  * 스레드 기능과 작업 코드가 하나로 결합

  * 다른 클래스를 상속할 수 없음 (단일 상속 제한)

* 장점: 구조 단순, 학습용으로 이해하기 쉬움

* 단점: 작업 재사용성과 확장성 낮음


2️⃣ Runnable 구현 (implements Runnable)<br>

* 클래스는 스레드가 실행할 작업(task)만 정의

* 실제 스레드는 new Thread(runnable) 객체 생성 후 start() 호출

* 특징:

  * 작업 코드와 스레드 객체가 분리됨

  * 다른 클래스를 자유롭게 상속 가능

  * 하나의 Runnable 객체를 여러 Thread에서 실행 가능

* 장점: 재사용성 높고 실무에서 권장

* 단점: Thread 객체를 별도로 생성해야 함


---


### [main 스레드]


JVM은 자바 응용프로그램을 실행하기 직전<br>
스레드를 하나 생성하고,<br>
이 스레드로 하여금 main() 메소드를 실행하도록 한다.<br>

이 스레드가 바로 메인 스레드이고,<br>
메인 스레드의 실행 시작 주소는 main() 메소드의 첫 코드이다.<br>






## 3. 스레드 종료


자바 스레드를 종료하는 방법은<br>
run()을 끝내서 스스로 종료하거나,<br>

interrupt()로 종료 요청을 보내고<br> 
run()에서 이를 처리해 종료하는 방식이 있다.<br>

단, interrupt() 자체가 스레드를 강제 종료하지는 않는다.<br>


다음은 Runnable 인터페이스를 구현한 다음,<br>
interrupt()를 이용해 스레드에 종료 요청을 보내고<br> 
run()에서 이를 처리하여 스레드를 종료하는 예제이다.<br>


```java
public class VibratingFrameEx extends JFrame implements Runnable { // Runnable 인터페이스 구현. 프레임에 run() 메소드 반드시 구현

	private Thread th; // 진동하는 스레드
	private boolean paused = false; // 마우스를 클릭 중인지, 놓았는지를 위한 필드

	public VibratingFrameEx() {
		setTitle("RunnableTimer 예제");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		setSize(300, 300);
		setLocation(300, 300); // 프레임의 위치를 스크린의 (300,300) 에 설정
		setVisible(true);

		getContentPane().addMouseListener(new MouseAdapter() { // 마우스 클릭 시 진동을 멈추기 위한 익명 이벤트 리스너

			@Override
			public void mousePressed(MouseEvent e) {
				paused = true; // 누르는 동안 일시정지
			}

			@Override
			public void mouseReleased(MouseEvent e) {
				paused = false; // 놓으면 진동
			}
		});

		th = new Thread(this); // 진동 스레드 객체 생성, 프레임 객체가 Runnable 인터페이스를 구현한 객체이므로 this 가능

		th.start(); // 스레드 시작
	}

	@Override
	public void run() { // 프레임 진동을 위해 20ms 마다 프레임 위치를 랜덤하게 이동

		Random r = new Random(); // 진동할 위치를 랜덤하게 발생시킬 랜덤 객체 생성

		while (true) {

			try {
				Thread.sleep(20); // 20ms 잠자기
			} catch (InterruptedException e) {
				return;
			}

			if (!paused) { // paused 가 false 일 경우

				int x = getX() + r.nextInt(5) - 2; // 새 위치 x, getX() 는 프레임의 현재 위치 x 값
				int y = getY() + r.nextInt(5) - 2; // 새 위치 y

				setLocation(x, y); // 프레임의 위치 이동 -> 진동 효과
			}
		}
	}

	public static void main(String[] args) {
		new VibratingFrameEx();
	}
}
```


이 예제는 프레임이 진동하다가<br> 
마우스를 누르고 있는 동안은 멈추고,<br>
마우스를 놓으면 다시 진동하는 프로그램이다.<br>






## 4. 스레드 동기화


스레드 동기화(thread synchronization)란,<br>
멀티스레드 프로그램에서<br>
여러 스레드가 같은 데이터를 동시에 사용하려고 할 때<br>
발생할 수 있는 문제를 막기 위한 기술이다.<br>

동기화를 하지 않으면,<br>
데이터 값이 엉키거나 예상과 다른 결과가 나올 수 있다.<br>

자바는 다음과 같은 방법으로 스레드를 동기화할 수 있다.<br>

1. synchronized 키워드로 동기화 영역 지정<br>

2. wait() / notify() 메소드로 스레드 실행 순서 제어<br>


---


### [synchronized로 동기화 블록 지정]


이 방법은 한 스레드가 공유 데이터를 사용하고 있을 때,<br>
다른 스레드가 동시에 접근하지 못하도록 막는 방법이다.<br>

synchronized 키워드를 사용하며,<br>
메소드 전체에 동기화를 설정하는 방법과<br>
특정 코드 블록에만 동기화를 설정하는 방법이 있다.<br>


* 메소드에 동기화 설정<br>


메소드 선언부에 synchronized를 붙이면,<br>
한 번에 하나의 스레드만 해당 메소드를 실행할 수 있다.<br>


```java
// 동기화 메소드
synchronized void print(String text) {
	for(int i = 0; i < text.length(); i++) {
		System.out.print(text.charAt(i));
	}
}
```


위와 같이 선언하면,<br>
어떤 스레드가 이 메소드를 실행 중일 때<br>
다른 스레드는 메소드가 끝날 때까지 기다리게 된다.<br>


* 코드 블록에 동기화 설정


메소드 전체가 아니라,<br>
필요한 부분만 동기화하고 싶을 때는<br>
synchronized 블록을 사용할 수 있다.<br>


```java
void execute(String text) {
	// 동기화 코드 블록
	synchronized(this) {
		for(int i = 0; i < text.length(); i++) {
		System.out.print(text.charAt(i));
		}
	}
}
```


다음은 두 개의 스레드가 하나의 공유 프린터를<br>
동시에 사용하여 출력하는 경우의 예제이다.<br>


```java
public class SynchronizedEx {

	public static void main(String[] args) {
		SharedPrinter p = new SharedPrinter();

		String[] engText = { "Hello Java Thread", "Synchronized Example", "Multithreading Test" };

		String[] korText = { "자바 스레드 테스트", "동기화 예제 출력", "멀티스레드 연습" };

		Thread th1 = new WorkerThread(p, engText);
		Thread th2 = new WorkerThread(p, korText);

		th1.start();
		th2.start();
	}

}

// 두 스레드에 의해 동시 접근되는 공유 프린터
class SharedPrinter {

	synchronized void print(String text) {
		// Thread.yield() -> 사용 시 스레드 스케줄을 다시 실행 -> synchronized 생략 시 더 많은 충돌 발생 가능
		for (int i = 0; i < text.length(); i++) {
			System.out.print(text.charAt(i));
		}
		System.out.println();
	}
}

class WorkerThread extends Thread {

	private SharedPrinter p; // 공유 프린터 주소
	private String[] text;

	public WorkerThread(SharedPrinter p, String[] text) { // 공유 프린터 주소와 텍스트를 전달 받음
		this.p = p;
		this.text = text;
	}

	@Override
	public void run() {
		for (int i = 0; i < text.length; i++) {
			p.print(text[i]);
		}
	}
}
```


이 경우 `synchronized` 키워드를 사용했기 때문에,<br>
한 번에 하나의 스레드만 프린터에 접근할 수 있으며<br>
다음과 같은 정상적인 출력 결과가 나온다.<br>


![Synchronized 예제](/assets/images/Synchronized%20예제1.jpg)


하지만 `synchronized` 키워드를 생략할 경우,<br>
여러 스레드가 동시에 출력하면서<br>
다음과 같이 출력이 섞이는 문제가 발생한다.<br>


![Synchronized 예제2](/assets/images/Synchronized%20예제2.jpg)


---


### [wait()-notify()를 이용한 스레드 동기화]


이 방법은 여러 스레드가 조건에 따라<br> 
실행 순서를 조절할 때 사용하는 방법이다.<br>

* wait()
-> 현재 스레드를 멈추고 기다리게 한다<br>

* notify()
-> 기다리고 있는 스레드 중 하나를 깨운다<br>

이 메소드들은<br>
반드시 synchronized 안에서만 사용해야 한다.<br>


예를 들어, 비디오 플레이어에는 공유되는 비디오 버퍼가 하나 있다.<br>

1️⃣ 입력 스레드

* 네트워크나 파일에서 영상 데이터를 받아온다

* 받아온 데이터를 버퍼에 저장한다

* 데이터가 들어오면 notify()를 호출해 재생 스레드를 깨운다

2️⃣ 재생 스레드

* 버퍼에서 영상 데이터를 꺼내 화면에 출력한다

* 버퍼가 비어 있으면 출력할 데이터가 없기 때문에
wait()을 호출해 잠시 멈춘다


이 비디오 플레이어는 결국 다음의 동작 흐름을 가진다.<br>

1. 재생 스레드가 실행됨

2. 버퍼가 비어 있음

3. 재생 스레드 -> wait() (대기)

4. 입력 스레드가 데이터 입력

5. 입력 스레드 -> notify() 호출

6. 재생 스레드가 깨어나 다시 재생 시작


다음은 wait()-notify()를 이용한 스레드 동기화 예제이다.<br>


```java
class MyLabel extends JLabel {

	private int barSize = 0; // 바의 크기
	private int maxBarSize;

	public MyLabel(int maxBarSize) {
		this.maxBarSize = maxBarSize;
	}

	@Override
	public void paintComponent(Graphics g) {
		super.paintComponent(g);
		g.setColor(Color.MAGENTA);

		int width = (int) (((double) (getWidth())) / maxBarSize * barSize);

		if (width == 0) {
			return; // 크기가 0 이기 때문에 바를 그릴 필요 없음
		}

		g.fillRect(0, 0, width, this.getHeight()); // width 만큼 MAGENTA 색으로 칠함
	}

	synchronized void fill() {
		while (barSize == maxBarSize) {
			try {
				wait(); // barSize가 줄어들어 조건이 만족될 때까지 대기
			} catch (InterruptedException e) {
				return;
			}
		}
		barSize++;
		repaint();
		notify(); // wait 중인 스레드 하나를 깨움
	}

	synchronized void consume() {
		while (barSize == 0) {
			try {
				wait(); // 바의 크기가 0 이면 바의 크기가 0 보다 커질 때까지 대기
			} catch (InterruptedException e) {
				return;
			}
		}
		barSize--;
		repaint(); // 바 다시 그리기
		notify(); // wait 중인 스레드 하나를 깨움
	}
}

class ConsumerThread extends Thread {

	private MyLabel bar;

	public ConsumerThread(MyLabel bar) {
		this.bar = bar;
	}

	@Override
	public void run() {
		while (true) {
			try {
				sleep(100); // 0.1 초 잠을 잠
				bar.consume(); // 0.1 초마다 바를 1씩 줄임
			} catch (InterruptedException e) {
				return;
			}
		}
	}
}

public class TabAndThreadEx extends JFrame {

	private MyLabel bar = new MyLabel(100); // 바의 최대 크기를 100으로 설정

	public TabAndThreadEx(String title) {
		super(title);
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		Container c = getContentPane();
		c.setLayout(null);

		bar.setBackground(Color.ORANGE);
		bar.setOpaque(true);
		bar.setLocation(20, 50);
		bar.setSize(300, 20);

		c.add(bar);

		// 컨텐트팬에 키 이벤트 리스너 등록
		c.addKeyListener(new KeyAdapter() {
			public void keyPressed(KeyEvent e) {
				bar.fill(); // 키를 누를 때마다 바가 1씩 증가
			}
		});

		setSize(350, 200);
		setVisible(true);

		c.setFocusable(true);
		c.requestFocus(); // 컨텐트팬이 포커스를 받을 수 있도록 설정
		ConsumerThread th = new ConsumerThread(bar); // 스레드 생성

		th.start(); // 스레드 시작
	}

	public static void main(String[] args) {
		new TabAndThreadEx("아무 키나 빨리 눌러 바를 채우기");
	}
}
```


위 프로그램은 사용자가 아무 키를 빠르게 누를 때마다 바가 채워지고,<br>
키를 누르지 않으면 바가 감소하도록 구현되어 있다.<br>
이 프로그램의 동작 과정은 다음과 같다.<br>


[프로그램 시작]


```java
public static void main(String[] args) {
    new TabAndThreadEx("아무 키나 빨리 눌러 바를 채우기");
}
```


[프레임 & 바 초기화]


```java
private MyLabel bar = new MyLabel(100);
```

* barSize = 0

* maxBarSize = 100

* 바는 비어 있는 상태로 시작


```java
bar.setOpaque(true);
bar.setSize(300, 20);
```


* 바의 외형 설정

* 아직 색칠되는 부분 없음 (barSize == 0)


[키 이벤트 준비]


```java
c.addKeyListener(new KeyAdapter() {
    public void keyPressed(KeyEvent e) {
        bar.fill();
    }
});
```


* 아무 키나 누르면 fill() 호출


```java
c.setFocusable(true);
c.requestFocus();
```


* 컨텐트팬이 키 입력을 받을 수 있게 준비


[소비자 스레드 시작]


```java
ConsumerThread th = new ConsumerThread(bar);
th.start();
```


* 새로운 스레드 생성 -> ConsumerThread


[ConsumerThread 동작 흐름]


```java
while (true) {
    sleep(100);
    bar.consume();
}
```


반복 동작<br>

* 0.1초 대기

* consume() 호출

* 바를 1만큼 줄이려고 시도


[처음 consume() 호출]


```java
synchronized void consume() {
    while (barSize == 0) {
        wait();
    }
    barSize--;
}
```


* barSize == 0

* while 조건 참

* ConsumerThread -> wait()

* MyLabel 객체의 락을 풀고 대기 상태

* 이제 ConsumerThread는 멈춤


[사용자 키 입력 발생]


```java
keyPressed -> bar.fill();
```


* 사용자가 키 누름


[fill() 내부 동작]


```java
while (barSize == maxBarSize) { wait(); }
barSize++;
repaint();
notify();
```


* barSize != maxBarSize

* barSize++ -> 0 -> 1

* repaint() -> 다시 그리기 요청

* notify() -> 대기 중인 스레드 하나 깨움

* ConsumerThread가 깨어날 준비


[ConsumerThread 깨어남]


* wait()에서 깨어남

* while (barSize == 0) 재검사 -> X

* barSize-- -> 1 -> 0

* repaint() 호출

* notify() 실행

* 바가 다시 줄어듦


[이후 반복 구조]


사용자가 빠르게 키를 누르면<br>

* fill()이 연속 실행

* barSize 증가

* 바가 채워짐

키 입력이 없으면<br>

* ConsumerThread가 0.1초마다 감소

* 결국 다시 barSize == 0

* wait() 상태로 진입


실행 결과는 다음과 같다.<br>


![wait()-notify() 예제](/assets/images/wait()-notify()%20예제.PNG)


-----------------------------------------------------------------------<br>


지금까지 자바의 스레드 기초에 대해 공부해 보았다.<br>
다음 글에서는 자바의 입출력에 대해서 공부해 보겠다.<br>


---
※ 본 글은 개인 학습을 목적으로 「명품 자바 에센셜」(황기태 지음, 생능출판)을 참고하여 작성하였습니다.