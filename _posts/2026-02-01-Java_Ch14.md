---
layout: single
title: "Java Chapter 14 – 스레드 기초"
date: 2026-02-01
categories:
  - Java
  - java_grammer
tags: [Java, 문법]
author_profile: true
read_time: true
comments: true
share: true
related: true
sidebar:
  nav: "categories_sidebar"
---


# 자바 스레드 기초





## 1. 자바 스레드 기초


### [프로세스와 스레드]


프로세스(process)는 운영체제에서 실행 중인 하나의 프로그램이다.<br>
각 프로세스는 독립된 메모리 공간을 가지며,<br> 
다른 프로세스와 메모리를 직접 공유하지 않는다.<br>

스레드(thread)는 하나의 프로세스 내부에서<br> 
실행되는 독립적인 실행 흐름(execution path) 이다.<br>
하나의 프로세스는 하나 이상의 스레드를 가질 수 있으며,<br>
같은 프로세스에 속한 스레드들은 메모리 공간을 공유한다.<br>


---


### [자바 프로그램과 JVM]


자바 프로그램은 운영체제 상에서 하나의 프로세스로 실행된다.<br>
이 프로세스 내부에서 JVM(Java Virtual Machine) 이 동작한다.<br>

JVM은 자바 바이트코드를 실행하는 가상 머신으로,<br>
메모리 관리, 스레드 관리, 가비지 컬렉션 등의 기능을 제공한다.<br>

일반적인 Java SE 환경에서<br>
하나의 JVM은 하나의 자바 애플리케이션을 실행하며,<br>
애플리케이션이 종료되면 JVM도 함께 종료된다.<br>


---


### [자바 스레드]


자바 스레드는 JVM에 의해 생성되고 관리되는 실행 단위이다.<br>
각 스레드는 Thread 클래스 또는<br> 
Runnable 인터페이스를 통해 생성되며,<br>
run() 메소드에 정의된 코드를 실행한다.<br>


---


### [스레드의 주요 구성 요소]


자바 스레드는 다음과 같은 속성을 가진다.<br>

* 실행 코드 (run() 메소드)

* 스레드 ID

* 스레드 이름(Name)

* 우선순위(Priority)

* 상태(State)

* 스택(Stack)

* 데몬 스레드 여부(Daemon)

이러한 정보는 JVM과 운영체제에 의해 관리된다.<br>


---


### [멀티스레딩]


멀티스레딩(multi-threading)이란<br>
하나의 프로세스 내에서 여러 스레드를<br> 
동시에 실행하는 프로그래밍 기법이다.<br>

자바는 JVM 차원에서 멀티스레딩을 지원하며,<br>
자바 애플리케이션은 하나 이상의 스레드를 생성하여<br>
병렬 처리 또는 동시 처리를 수행할 수 있다.<br>


---


### [핵심 정리]


* 자바 프로그램은 운영체제에서 프로세스로 실행된다.

* JVM은 운영체제가 아니라, 운영체제 위에서 동작하는 가상 머신이다.

* 자바 스레드는 프로세스 내부의 실행 흐름이다.

* JVM은 스레드를 관리하지만, 실제 스케줄링은 운영체제가 담당한다.

* 멀티스레딩을 통해 자바 애플리케이션은 동시에 여러 작업을 수행할 수 있다.






## 2. 자바 스레드 만들기


사용자는 다음과 같은 방법으로<br>
스레드를 만들 수 있다.<br>


1. Thread 클래스 이용<br>

2. Runnable 인터페이스 이용<br>


---


### [Thread 클래스로 스레드 만들기]


Thread 클래스의 경로명은 java.lang.Thread이며,<br>
Thread 클래스를 상속받아 새로운 스레드를 만들 수 있다.<br>

다음은 Thread 클래스의 주요 메소드를 정리한 표이다.<br>


![Thread 클래스 주요 메소드](/assets/images/Thread%20클래스%20주요%20메소드.png)


다음은 Thread 클래스를 상속받아 스레드를 만드는 예제이다.<br>


```java
class TimerThread extends Thread {
	private JLabel timerLabel; // 타이머 값이 출력되는 레이블

	public TimerThread(JLabel timerLabel) {
		this.timerLabel = timerLabel; // 타이머 카운트를 출력할 레이블
	}

	// 스레드 코드. run() 이 종료하면 스레드 종료
	@Override
	public void run() {
		int n = 0; // 타이머 카운트 값

		while (true) {
			timerLabel.setText(Integer.toString(n)); // 레이블에 카운트 값 출력
			n++; // 카운트 값 증가

			try {
				Thread.sleep(1000); // 1초 동안 잠을 잠.
			} catch (InterruptedException e) {
				return; // 예외가 발생하면 스레드 종료
			}
		}
	}
}

public class ThreadTimerEx extends JFrame {

	public ThreadTimerEx() {
		setTitle("ThreadTimer 예제");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		Container c = getContentPane();
		c.setLayout(new FlowLayout());

		// 타이머 값을 출력할 레이블 생성
		JLabel timerLabel = new JLabel();
		timerLabel.setFont(new Font("Gothic", Font.ITALIC, 80));
		c.add(timerLabel);

		// 타이머 스레드 객체 생성. 타이머 값을 출력할 레이블을 생성자에 전달
		TimerThread th = new TimerThread(timerLabel);

		setSize(250, 150);
		setVisible(true);

		th.start(); // 타이머 스레드 실행 시작 -> TimerThread 의 run() 메소드가 실행 시작
	}

	public static void main(String[] args) {
		new ThreadTimerEx();
	}
}
```


Thread.sleep() 메소드는 현재 실행 중인 스레드를<br>
일정 시간 동안 잠시 멈추게 하는 메소드이다.<br>

하지만 스레드가 잠들어 있는 동안<br>
다른 스레드가 interrupt()를 호출하면<br>
잠을 즉시 깨우기 위해 InterruptedException이 발생한다.<br>

자바에서는 이 예외를 반드시 처리하도록 되어 있으므로,<br>
sleep()을 사용하는 코드는<br>
try–catch 블록으로 InterruptedException을 처리해야 한다.<br>

이 예제에서는<br>
인터럽트가 발생하면 타이머를 계속 실행할 필요가 없기 때문에,<br>
catch 블록에서 run() 메소드를 종료하여<br>
스레드를 정상적으로 끝내도록 하였다.<br>


실행 결과는 다음과 같다.<br>


![ThreadTimer 예제](/assets/images/ThreadTimer%20예제.PNG)


---


### [Runnable 인터페이스로 스레드 만들기]


Runnable 인터페이스의 경로명은 java.lang.Runnable이며,<br>
다음과 같이 추상 메소드 run()만 가지고 있는 인터페이스이다.<br>


```java
interface Runnable {
  public void run();
}
```


그러므로 인터페이스 Runnable의 run()을<br>
구현하여 스레드에서 실행할 작업 클래스를 만든다.<br>

다음은 앞에서 만든 스레드 타이머를<br>
인터페이스를 이용해 구현하는 예제이다.<br>


```java
class TimerRunnable implements Runnable {

	private JLabel timerLabel; // 타이머 값이 출력될 레이블

	public TimerRunnable(JLabel timerLabel) {
		this.timerLabel = timerLabel; // 초 카운트를 출력할 레이블
	}

	// 스레드 코드. run() 이 종료하면 스레드 종료
	@Override
	public void run() {
		int n = 0; // 타이머 카운트 값

		while (true) {
			timerLabel.setText(Integer.toString(n)); // 레이블에 카운트 값 출력
			n++; // 카운트 값 증가

			try {
				Thread.sleep(1000); // 1초 동안 잠을 잠.
			} catch (InterruptedException e) {
				return; // 예외가 발생하면 스레드 종료
			}
		}
	}
}

public class RunnableTimerEx extends JFrame {

	public RunnableTimerEx() {
		setTitle("RunnableTimer 예제");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		Container c = getContentPane();
		c.setLayout(new FlowLayout());

		// 타이머 값을 출력할 레이블 생성
		JLabel timerLabel = new JLabel();
		timerLabel.setFont(new Font("Gothic", Font.ITALIC, 80));
		c.add(timerLabel);

		// 타이머 스레드 객체 생성. 타이머 값을 출력할 레이블을 생성자에 전달
		TimerRunnable runnable = new TimerRunnable(timerLabel);
		Thread th = new Thread(runnable);

		setSize(250, 150);
		setVisible(true);

		th.start(); // 타이머 스레드 실행 시작 -> TimerRunnable 의 run() 메소드가 실행 시작
	}

	public static void main(String[] args) {
		new RunnableTimerEx();
	}
}
```


실행 결과는 클래스를 상속받아 만들었던 예제와 동일하다.<br>


---


### [두 방법의 차이점]


1️⃣ Thread 상속 (extends Thread)<br>

* 클래스 자체가 스레드 객체가 됨

* run() 메소드 안에 스레드가 실행할 코드 작성

* 스레드 시작: start() 호출 → JVM이 별도 스레드에서 run() 실행

* 특징:

  * 스레드 기능과 작업 코드가 하나로 결합

  * 다른 클래스를 상속할 수 없음 (단일 상속 제한)

* 장점: 구조 단순, 학습용으로 이해하기 쉬움

* 단점: 작업 재사용성과 확장성 낮음


2️⃣ Runnable 구현 (implements Runnable)<br>

* 클래스는 스레드가 실행할 작업(task)만 정의

* 실제 스레드는 new Thread(runnable) 객체 생성 후 start() 호출

* 특징:

  * 작업 코드와 스레드 객체가 분리됨

  * 다른 클래스를 자유롭게 상속 가능

  * 하나의 Runnable 객체를 여러 Thread에서 실행 가능

* 장점: 재사용성 높고 실무에서 권장

* 단점: Thread 객체를 별도로 생성해야 함


---


### [main 스레드]


JVM은 자바 응용프로그램을 실행하기 직전<br>
스레드를 하나 생성하고,<br>
이 스레드로 하여금 main() 메소드를 실행하도록 한다.<br>

이 스레드가 바로 메인 스레드이고,<br>
메인 스레드의 실행 시작 주소는 main() 메소드의 첫 코드이다.<br>






## 3. 스레드 종료


자바 스레드를 종료하는 방법은<br>
run()을 끝내서 스스로 종료하거나,<br>

interrupt()로 종료 요청을 보내고<br> 
run()에서 이를 처리해 종료하는 방식이 있다.<br>

단, interrupt() 자체가 스레드를 강제 종료하지는 않는다.<br>


다음은 Runnable 인터페이스를 구현한 다음,<br>
interrupt()를 이용해 스레드에 종료 요청을 보내고<br> 
run()에서 이를 처리하여 스레드를 종료하는 예제이다.<br>


```java
public class VibratingFrameEx extends JFrame implements Runnable { // Runnable 인터페이스 구현. 프레임에 run() 메소드 반드시 구현

	private Thread th; // 진동하는 스레드
	private boolean paused = false; // 마우스를 클릭 중인지, 놓았는지를 위한 필드

	public VibratingFrameEx() {
		setTitle("RunnableTimer 예제");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		setSize(300, 300);
		setLocation(300, 300); // 프레임의 위치를 스크린의 (300,300) 에 설정
		setVisible(true);

		getContentPane().addMouseListener(new MouseAdapter() { // 마우스 클릭 시 진동을 멈추기 위한 익명 이벤트 리스너

			@Override
			public void mousePressed(MouseEvent e) {
				paused = true; // 누르는 동안 일시정지
			}

			@Override
			public void mouseReleased(MouseEvent e) {
				paused = false; // 놓으면 진동
			}
		});

		th = new Thread(this); // 진동 스레드 객체 생성, 프레임 객체가 Runnable 인터페이스를 구현한 객체이므로 this 가능

		th.start(); // 스레드 시작
	}

	@Override
	public void run() { // 프레임 진동을 위해 20ms 마다 프레임 위치를 랜덤하게 이동

		Random r = new Random(); // 진동할 위치를 랜덤하게 발생시킬 랜덤 객체 생성

		while (true) {

			try {
				Thread.sleep(20); // 20ms 잠자기
			} catch (InterruptedException e) {
				return;
			}

			if (!paused) { // paused 가 false 일 경우

				int x = getX() + r.nextInt(5) - 2; // 새 위치 x, getX() 는 프레임의 현재 위치 x 값
				int y = getY() + r.nextInt(5) - 2; // 새 위치 y

				setLocation(x, y); // 프레임의 위치 이동 -> 진동 효과
			}
		}
	}

	public static void main(String[] args) {
		new VibratingFrameEx();
	}
}
```


이 예제는 프레임이 진동하다가 마우스를 누르고 있는 동안 멈추고,<br>
마우스를 놓으면 다시 진동하는 프로그램이다.<br>