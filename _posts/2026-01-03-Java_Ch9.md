---
layout: single
title: "Java Chapter 9 – 컬렉션과 제네릭"
date: 2026-01-03
categories:
  - Java
  - java_grammer
tags: [Java, 문법]
author_profile: true
read_time: true
comments: true
share: true
related: true
sidebar:
  nav: "categories_sidebar"
---


# 컬렉션과 제네릭


자바의 JDK는 프로그램 개발에 필요한 표준 자료구조들을<br> 
컬렉션 프레임워크(Collection Framework) 형태로 제공한다.<br>
컬렉션은 제네릭(Generics) 기법을 사용하여 구현되어 있으며,<br> 
이를 통해 컴파일 시점에 타입 안정성을 보장한다.<br>






## 1. 컬렉션의 중요성과 개념


컬렉션은 고정 크기의 배열이 가지는 크기 제한, 데이터 추가 및 삭제의 불편함,<br> 
기능 확장의 어려움 등의 단점을 극복하기 위해 설계되었다.<br>
또한 컬렉션은 요소(Element)라고 불리는 객체들을 저장하며,<br> 
삽입, 삭제, 검색 등의 기능을 지원하는 가변 크기의 컨테이너이다.<br>


java.util 패키지는 컬렉션의 개념을 구현한<br> 
다양한 컬렉션 인터페이스와 컬렉션 클래스를 제공한다.<br>
아래는 핵심적인 컬렉션 인터페이스와 클래스들이다.<br>


![컬렉션 인터페이스와 클래스](/assets/images/컬렉션%20인터페이스와%20클래스.PNG)<br>


`Vector<E>`와 `ArrayList<E>`는 가변 크기의 배열을 구현하며,<br>
`LinkedList<E>`는 링크드 리스트를 구현한다.<br>
`Stack<E>`는 스택을 구현하며,<br>
`HashSet<E>`는 집합을 구현한다.<br>
이들은 `Collection<E>`를 상속받으며,<br>
단일 클래스의 원소 객체를 삽입, 삭제하는 공통점이 있다.<br>
이와 달리 `HashMap<K, V>`는 키(K)와 값(V)의 쌍으로 이루어지는<br> 
데이터를 저장하고 검색하는 컬렉션이다.<br>






## 2. 컬렉션의 특징


다음은 컬렉션의 중요한 특징이다.<br>


첫째, 컬렉션은 제네릭(Generics) 이라는 기법으로 구현되어 있다.<br>
컬렉션 인터페이스나 클래스에는 `<E>, <K>, <V>`와 같은
타입 매개변수(Type Parameter)가 사용된다.<br>


이들은 컬렉션의 요소(element)를 일반화하여 표현한 타입이다.<br>
이 타입 매개변수는 컬렉션에 저장될 요소의 타입을 미리 일반화해 두고,<br>
사용 시 Integer, String과 같은 구체적인 타입으로 지정할 수 있도록 한다.<br>


```java
Vector<Integer>는 정수 값만 저장하는 컬렉션
Vector<String>은 문자열만 저장하는 컬렉션
```


이처럼 실제 타입을 지정하여 생성된 컬렉션 객체를
제네릭 타입 인스턴스라고 한다.<br>
(즉, 타입이 확정된 컬렉션 객체를 의미한다.)<br>


둘째, 컬렉션에는 객체 타입의 요소만 저장할 수 있다.<br>
int, char, double과 같은 기본 타입은<br>
컬렉션의 요소로 직접 사용할 수 없다.<br>


```java
Vector<int> v = new Vector<int>();  // 컴파일 오류 > 기본 타입 사용 불가
Vector<Integer> v = new Vector<Integer>();  // 정상
```


그리고 기본 타입의 값이 삽입되면 자동 박싱(auto boxing)에 의해<br>
Wrapper 클래스로 변환되어 객체 형태로 저장된다<br>






## 3. 제네릭의 개념


제네릭(Generics)은 JDK 1.5 버전에 도입되었다.<br>
제네릭은 모든 종류의 타입을 다룰 수 있도록,<br> 
클래스나 메소드를 일반화된 타입 매개 변수(Generic Type)를<br>
이용하여 선언하는 기법이다.<br>
즉, 메소드나 클래스 코드를 여러 타입에 재사용할 수 있도록 일반화하는 도구이다.<br>


예를 들어, 다음과 같은 제네릭 스택이 있다고 해보자.<br>


```java
class Stack<E> {
  ...
  void push(E element) {
    ...
  }

  E pop() {
    ...
  }
}
```


여기에서 `<E>`에 구체적인 타입을 다음과 같이 지정해주면<br>


```java
Stack<Integer> stack = new Stack<>();
```


이 스택 객체는 Integer 타입만을 다룰 수 있게 구체화된다.<br>


추가로, 컬렉션 클래스에서 타입 매개 변수로 사용하는 문자는<br>
다른 변수와 혼동을 피하기 위해서 일반적으로 하나의 대문자를 사용한다.<br>
관례적으로 많이 사용하는 문자는 다음과 같다.<br>


`1. E: Element를 의미하며 컬렉션에서 요소를 표시할 때 사용한다.`<br>

`2. T: Type을 의미한다.`<br>

`3. V: Value를 의미한다.`<br>

`4. K: Key를 의미한다.`<br>






## 4. 제네릭 컬렉션 활용 - `Vector<E>`


`Vector<E>`는 배열을 가변 크기로 다룰 수 있게 하고,<br>
객체의 삽입, 삭제, 이동이 용이하도록 구성한 컬렉션 클래스이다.<br>
벡터는 삽입되는 요소의 개수에 따라 자동으로 크기를 조절하고,<br>
요소의 삽입과 삭제에 따라 자동으로 요소들의 자리를 이동한다.<br>


다음은 벡터의 주요 메소드들이다.<br>


![Vector 메소드](/assets/images/Vector%20메소드.png)<br>


다음은 벡터 객체의 생성과 활용 예시이다.<br>


```java
public class VectorEx {
  public static void main(String[] args) {
		// 정수 값만을 다루는 제네릭 벡터 객체 생성
		Vector<Integer> v = new Vector<>();

		// 벡터에 값 삽입
		v.add(5);
		v.add(3);
		v.add(-1);

		// 벡터 중간에 값 삽입
		v.add(2, 101); // 3과 -1 사이에 정수 101 삽입

		System.out.println("벡터 내의 요소 개수: " + v.size()); // 벡터의 크기
		System.out.println("벡터의 현재 용량: " + v.capacity()); // 벡터의 기본 용량: 10

		// 모든 요소 정수 출력
		for (int i = 0; i < v.size(); i++) {
			int n = v.get(i); // 벡터의 i 번째 정수
			System.out.println(n);
		}

		// 벡터에 저장된 모든 정수의 합 구하기
		int sum = 0;

		for (int i = 0; i < v.size(); i++) {
			int n = v.elementAt(i); // 벡터의 i 번째 정수
			sum += n;
		}

		System.out.println("벡터 내의 정수의 합: " + sum);
	}
}
```


실행 결과는 다음과 같다.<br>


```java
벡터 내의 요소 개수: 4
벡터의 현재 용량: 10
5
3
101
-1
벡터 내의 정수의 합: 108
```


주의할 점은 앞에서 말했듯 Integer 타입의 벡터 객체이기 때문에,<br>
이 객체는 다른 타입은 다룰 수 없다.<br>


또한 자동 박싱에 의해 int 타입의 정수는<br>
자동으로 Integer 객체로 변환되어 삽입된다.<br>


벡터에는 null도 삽입이 가능하기 때문에,<br>
벡터를 검색할 때 null이 있을 수 있음을 염두에 두어야 한다.<br>


### 자동 박싱/언박싱


컬렉션은 객체들만 요소(elements)로 다루므로,<br>
기본 타입의 값은 Wrapper 클래스로 객체화하여<br>
삽입하는 것이 정상이다.<br>


```java
Vector<Integer> v = new Vector<Integer>();
v.add(Integer.valueOf(4));
```


하지만 자동 박싱(auto boxing) 기능을 이용하면<br>
다음과 같이 간단히 작성해도 된다.<br>


```java
v.add(4); // 정수 4가 Integer(4)로 자동 박싱됨
```


또한 컬렉션으로부터 값을 얻어내는 과정도<br>
자동 언박싱(auto unboxing)을 활용하면<br>
다음과 같이 간단히 작성할 수 있다.<br>


```java
int k = v.get(0);
```


### 컬렉션 생성 문법과 타입 추론의 진화


```java
Vector<Integer> v = new Vector<Integer>();  // Java 7 이전
```


```java
Vector<Integer> v = new Vector<>(); // Java 7부터
```


Java 7부터는 다이아몬드 연산자(<>)가 도입되어,<br>
객체 생성 시 타입 매개 변수를 생략하면<br>
컴파일러가 좌변의 제네릭 타입을 기준으로 추론하게 되었다.<br>


```java
var v = new Vector<Integer>();  // Java 10부터
```


Java 10에서는 지역 변수 타입 추론을 위한 var 키워드가 도입되어,<br>
선언문으로부터 변수의 타입을 컴파일러가 추론할 수 있게 되었다.<br>

(var는 지역 변수에 한해 사용 가능하며,<br>
컴파일 시점에만 타입 추론이 이루어지고<br>
실행 시에는 명확한 타입이 존재한다.)<br>


마지막으로 Vector는 모든 메소드가 동기화(synchronized)되어 있어,<br>
멀티 스레드 환경에서는 안전하지만 성능은 상대적으로 떨어진다.<br>






## 5. 제네릭 컬렉션 활용 - `ArrayList<E>`