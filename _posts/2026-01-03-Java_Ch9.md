---
layout: single
title: "Java Chapter 9 – 컬렉션과 제네릭"
date: 2026-01-03
categories:
  - Java
  - java_grammer
tags: [Java, 문법]
author_profile: true
read_time: true
comments: true
share: true
related: true
sidebar:
  nav: "categories_sidebar"
---


# 컬렉션과 제네릭


자바의 JDK는 프로그램 개발에 필요한 표준 자료구조들을<br> 
컬렉션 프레임워크(Collection Framework) 형태로 제공한다.<br>
컬렉션은 제네릭(Generics) 기법을 사용하여 구현되어 있으며,<br> 
이를 통해 컴파일 시점에 타입 안정성을 보장한다.<br>






## 1. 컬렉션의 중요성과 개념


컬렉션은 고정 크기의 배열이 가지는 크기 제한, 데이터 추가 및 삭제의 불편함,<br> 
기능 확장의 어려움 등의 단점을 극복하기 위해 설계되었다.<br>
또한 컬렉션은 요소(Element)라고 불리는 객체들을 저장하며,<br> 
삽입, 삭제, 검색 등의 기능을 지원하는 가변 크기의 컨테이너이다.<br>


java.util 패키지는 컬렉션의 개념을 구현한<br> 
다양한 컬렉션 인터페이스와 컬렉션 클래스를 제공한다.<br>
아래는 핵심적인 컬렉션 인터페이스와 클래스들이다.<br>


![컬렉션 인터페이스와 클래스](/assets/images/컬렉션%20인터페이스와%20클래스.PNG)<br>


`Vector<E>`와 `ArrayList<E>`는 가변 크기의 배열을 구현하며,<br>
`LinkedList<E>`는 링크드 리스트를 구현한다.<br>
`Stack<E>`는 스택을 구현하며,<br>
`HashSet<E>`는 집합을 구현한다.<br>
이들은 `Collection<E>`를 상속받으며,<br>
단일 클래스의 원소 객체를 삽입, 삭제하는 공통점이 있다.<br>
이와 달리 `HashMap<K, V>`는 키(K)와 값(V)의 쌍으로 이루어지는<br> 
데이터를 저장하고 검색하는 컬렉션이다.<br>






## 2. 컬렉션의 특징


다음은 컬렉션의 중요한 특징이다.<br>


첫째, 컬렉션은 제네릭(Generics) 이라는 기법으로 구현되어 있다.<br>
컬렉션 인터페이스나 클래스에는 `<E>, <K>, <V>`와 같은
타입 매개변수(Type Parameter)가 사용된다.<br>


이들은 컬렉션의 요소(element)를 일반화하여 표현한 타입이다.<br>
이 타입 매개변수는 컬렉션에 저장될 요소의 타입을 미리 일반화해 두고,<br>
사용 시 Integer, String과 같은 구체적인 타입으로 지정할 수 있도록 한다.<br>


```java
Vector<Integer>는 정수 값만 저장하는 컬렉션
Vector<String>은 문자열만 저장하는 컬렉션
```


이처럼 실제 타입을 지정하여 생성된 컬렉션 객체를
제네릭 타입 인스턴스라고 한다.<br>
(즉, 타입이 확정된 컬렉션 객체를 의미한다.)<br>


둘째, 컬렉션에는 객체 타입의 요소만 저장할 수 있다.<br>
int, char, double과 같은 기본 타입은<br>
컬렉션의 요소로 직접 사용할 수 없다.<br>


```java
Vector<int> v = new Vector<int>();  // 컴파일 오류 > 기본 타입 사용 불가
Vector<Integer> v = new Vector<Integer>();  // 정상
```


그리고 기본 타입의 값이 삽입되면 자동 박싱(auto boxing)에 의해<br>
Wrapper 클래스로 변환되어 객체 형태로 저장된다<br>






## 3. 제네릭의 개념


제네릭(Generics)은 JDK 1.5 버전에 도입되었다.<br>
제네릭은 모든 종류의 타입을 다룰 수 있도록,<br> 
클래스나 메소드를 일반화된 타입 매개 변수(Generic Type)를<br>
이용하여 선언하는 기법이다.<br>
즉, 메소드나 클래스 코드를 여러 타입에 재사용할 수 있도록 일반화하는 도구이다.<br>


예를 들어, 다음과 같은 제네릭 스택이 있다고 해보자.<br>


```java
class Stack<E> {
  ...
  void push(E element) {
    ...
  }

  E pop() {
    ...
  }
}
```


여기에서 `<E>`에 구체적인 타입을 다음과 같이 지정해주면<br>


```java
Stack<Integer> stack = new Stack<>();
```


이 스택 객체는 Integer 타입만을 다룰 수 있게 구체화된다.<br>


추가로, 컬렉션 클래스에서 타입 매개 변수로 사용하는 문자는<br>
다른 변수와 혼동을 피하기 위해서 일반적으로 하나의 대문자를 사용한다.<br>
관례적으로 많이 사용하는 문자는 다음과 같다.<br>


`1. E: Element를 의미하며 컬렉션에서 요소를 표시할 때 사용한다.`<br>

`2. T: Type을 의미한다.`<br>

`3. V: Value를 의미한다.`<br>

`4. K: Key를 의미한다.`<br>






## 4. 제네릭 컬렉션 활용 - `Vector<E>`


`Vector<E>`는 배열을 가변 크기로 다룰 수 있게 하고,<br>
객체의 삽입, 삭제, 이동이 용이하도록 구성한 컬렉션 클래스이다.<br>
벡터는 삽입되는 요소의 개수에 따라 자동으로 크기를 조절하고,<br>
요소의 삽입과 삭제에 따라 자동으로 요소들의 자리를 이동한다.<br>


다음은 벡터의 주요 메소드들이다.<br>


![Vector 메소드](/assets/images/Vector%20메소드.png)<br>


다음은 벡터 객체의 생성과 활용 예시이다.<br>


```java
public class VectorEx {
  public static void main(String[] args) {
		// 정수 값만을 다루는 제네릭 벡터 객체 생성
		Vector<Integer> v = new Vector<>();

		// 벡터에 값 삽입
		v.add(5);
		v.add(3);
		v.add(-1);

		// 벡터 중간에 값 삽입
		v.add(2, 101); // 3과 -1 사이에 정수 101 삽입

		System.out.println("벡터 내의 요소 개수: " + v.size()); // 벡터의 크기
		System.out.println("벡터의 현재 용량: " + v.capacity()); // 벡터의 기본 용량: 10

		// 모든 요소 정수 출력
		for (int i = 0; i < v.size(); i++) {
			int n = v.get(i); // 벡터의 i 번째 정수
			System.out.println(n);
		}

		// 벡터에 저장된 모든 정수의 합 구하기
		int sum = 0;

		for (int i = 0; i < v.size(); i++) {
			int n = v.elementAt(i); // 벡터의 i 번째 정수
			sum += n;
		}

		System.out.println("벡터 내의 정수의 합: " + sum);
	}
}
```


실행 결과는 다음과 같다.<br>


```java
벡터 내의 요소 개수: 4
벡터의 현재 용량: 10
5
3
101
-1
벡터 내의 정수의 합: 108
```


주의할 점은 앞에서 말했듯 Integer 타입의 벡터 객체이기 때문에,<br>
이 객체는 다른 타입은 다룰 수 없다.<br>


또한 자동 박싱에 의해 int 타입의 정수는<br>
자동으로 Integer 객체로 변환되어 삽입된다.<br>


벡터에는 null도 삽입이 가능하기 때문에,<br>
벡터를 검색할 때 null이 있을 수 있음을 염두에 두어야 한다.<br>


### 자동 박싱/언박싱


컬렉션은 객체들만 요소(elements)로 다루므로,<br>
기본 타입의 값은 Wrapper 클래스로 객체화하여<br>
삽입하는 것이 정상이다.<br>


```java
Vector<Integer> v = new Vector<Integer>();
v.add(Integer.valueOf(4));
```


하지만 자동 박싱(auto boxing) 기능을 이용하면<br>
다음과 같이 간단히 작성해도 된다.<br>


```java
v.add(4); // 정수 4가 Integer(4)로 자동 박싱됨
```


또한 컬렉션으로부터 값을 얻어내는 과정도<br>
자동 언박싱(auto unboxing)을 활용하면<br>
다음과 같이 간단히 작성할 수 있다.<br>


```java
int k = v.get(0);
```


### 컬렉션 생성 문법과 타입 추론의 진화


```java
Vector<Integer> v = new Vector<Integer>();  // Java 7 이전
```


```java
Vector<Integer> v = new Vector<>(); // Java 7부터
```


Java 7부터는 다이아몬드 연산자(<>)가 도입되어,<br>
객체 생성 시 타입 매개 변수를 생략하면<br>
컴파일러가 좌변의 제네릭 타입을 기준으로 추론하게 되었다.<br>


```java
var v = new Vector<Integer>();  // Java 10부터
```


Java 10에서는 지역 변수 타입 추론을 위한 var 키워드가 도입되어,<br>
선언문으로부터 변수의 타입을 컴파일러가 추론할 수 있게 되었다.<br>

(var는 지역 변수에 한해 사용 가능하며,<br>
컴파일 시점에만 타입 추론이 이루어지고<br>
실행 시에는 명확한 타입이 존재한다.)<br>


마지막으로 Vector는 모든 메소드가 동기화(synchronized)되어 있어,<br>
멀티 스레드 환경에서는 안전하지만 성능은 상대적으로 떨어진다.<br>






## 5. 제네릭 컬렉션 활용 - `ArrayList<E>`


`ArrayList<E>`는 가변 크기의 배열을 구현한 컬렉션으로서,<br>
Vector와 거의 동일하다.<br>
크게 다른 점은 ArrayList는 스레드 간 동기화를 지원하지 않으므로,<br>
다수의 스레드가 동시에 ArrayList에 요소를 삽입하거나 삭제할 때<br>
충돌이 발생할 가능성이 있다.<br>
따라서 ArrayList를 멀티스레드 환경에서 사용할 경우,<br>
동기화를 사용자가 직접 구현해야 한다.<br>


다음은 ArrayList의 주요 메소드들이다.<br>


![ArrayList 메소드](/assets/images/ArrayList%20메소드.png)<br>


다음은 ArrayList 객체 생성과 활용 예시이다.<br>


```java
public class ArrayListEx {
  public static void main(String[] args) {
		// 문자열만 다루는 ArrayList 객체 생성
		ArrayList<String> a = new ArrayList<String>();

		// 키보드로부터 4개의 이름을 입력받아 ArrayList에 삽입
		Scanner sc = new Scanner(System.in);
		for (int i = 0; i < 4; i++) {
			System.out.print("이름 입력 >>>");
			String s = sc.next();
			a.add(s);
		}

		// ArrayList에 들어있는 모든 이름 출력
		for (int i = 0; i < a.size(); i++) {
			String name = a.get(i); // ArrayList의 i 번째 문자열 가져오기
			System.out.println(name);
		}

		// 가장 긴 이름 출력
		int longestIndex = 0; // 현재 가장 긴 이름이 있는 인덱스
		for (int i = 1; i < a.size(); i++) {  // 이름 길이 비교
			if (a.get(longestIndex).length() < a.get(i).length()) {
				longestIndex = i; // i 번째 이름이 더 긴 이름임
			}
		}
		System.out.println("가장 긴 이름은 >>> " + a.get(longestIndex));
		sc.close();
	}
}
```


실행 결과는 다음과 같다.<br>


```java
이름 입력 >>>Mike
이름 입력 >>>Jane
이름 입력 >>>Ashley
이름 입력 >>>Helen
Mike 
Jane 
Ashley 
Helen 
가장 긴 이름은 >>> Ashley
```






## 6. 제네릭 컬렉션 활용 - `Iterator<E>`


Vector, ArrayList, LinkedList, Set 컬렉션에서<br>
순차적으로 요소를 검색할 때,<br> 
`Iterator<E>` 인터페이스를 사용하면 편리하다.<br>
`Iterator<E>`를 사용할 때는 `<E>`에<br>
컬렉션의 제네릭 타입과 동일한 타입을 설정해야 한다.<br>


다음은 Iterator의 주요 메소드들이다.<br>


![Iterator 메소드](/assets/images/Iterator%20메소드.png)<br>


다음은 Iterator 객체 생성과 활용 예시이다.<br>


```java
public class IteratorEx {
	public static void main(String[] args) {
		// 정수값만 다루는 벡터 객체 생성
		Vector<Integer> v = new Vector<Integer>();

		v.add(7);
		v.add(3);
		v.add(-1);
		v.add(2, 101);

		// Iterator 를 이용한 모든 정수 출력하기
		Iterator<Integer> it = v.iterator(); // Iterator 객체 가져오기

		while (it.hasNext()) {
			int n = it.next();
			System.out.println(n);
		}

		// Iterator 를 이용하여 모든 정수 더하기
		int sum = 0;
		it = v.iterator(); // Iterator 객체 가져오기

		while (it.hasNext()) {
			int n = it.next();
			sum += n;
		}
		System.out.println("벡터의 모든 정수의 합>>> " + sum);
	}
}
```


실행 결과는 다음과 같다.<br>


```java
7
3
101
-1
벡터의 모든 정수의 합>>> 110
```


여기서 주의할 점은<br>
위 코드에서 이미 한 번 생성하여 사용된 Iterator는<br>
이미 벡터의 끝까지 순회하였기 때문에 다음 요소가 없다.<br>
Iterator는 한 방향으로만 순회 가능한 일회성 객체이기 때문에<br>
사용할 때마다 새로운 Iterator를 받아와야 한다.<br>


또한, Iterator는 이전 위치로 되돌아가거나<br>
처음부터 다시 순회하는 기능을 제공하지 않는다.<br>






## 7. 제네릭 컬렉션 활용 - `HashMap<K, V>`


`HashMap<K, V>` 컬렉션은 '키(key)'와 '값(value)'의<br>
쌍으로 구성되는 요소를 다룬다.<br>
`K`는 '키'로 사용될 데이터 타입을,<br>
`V`는 '값'으로 사용될 데이터 타입을 나타내는 타입 매개 변수이다.<br>


해시맵(HashMap)은 내부에 '키'와 '값'을 저장하는 자료구조를 가지고,<br>
put()과 get() 메소드를 이용하여 요소를 삽입하거나 검색한다.<br>


put(key, value)은 key를 기반으로 해시 함수(hash function)를 실행하여<br>
해시맵 내의 저장 위치를 결정하고, 해당 위치에 key와 value를 저장한다.<br>

get(key)는 key를 기반으로 동일한 해시 함수를 실행하여<br>
value가 저장된 위치를 알아내어 리턴한다.<br> 


해시맵은 해시 함수를 통해 '키'와 '값'이 저장되는<br>
위치를 결정하므로, 사용자는 그 위치를 알 수 없다.<br>
또한 삽입되는 순서와 들어 있는 위치는 관계가 없다.<br>
그러므로 해시맵은 요소의 위치나 순서가 중요하지 않은<br>
상황에서 사용된다.<br>


다음은 해시맵의 주요 메소드들이다.<br>


![HashMap 메소드](/assets/images/HashMap%20메소드.png)<br>


다음은 해시맵 생성과 활용 예시이다.<br>


```java
public class HashMapEx {
	public static void main(String[] args) {
		// 영어 단어와 한글 단어의 쌍을 저장하는 HashMap 컬렉션 생성
		HashMap<String, String> animal = new HashMap<String, String>();

		// 3개의 (key, value) 쌍을 animal 에 저장
		animal.put("tiger", "호랑이");
		animal.put("lion", "사자");
		animal.put("wolf", "늑대");

		// animal 해시맵에 들어있는 모든 (key, value) 쌍 출력
		Set<String> keys = animal.keySet(); // 모든 키를 Set 컬렉션에 받아옴
		Iterator<String> it = keys.iterator(); // Set 을 순회할 Iterator 받아옴

		while (it.hasNext()) {
			String key = it.next(); // 키(key)
			String value = animal.get(key); // 값(value)

			System.out.println("(" + key + "," + value + ")");
		}

		// 사용자로부터 영어 단어를 입력 받고 한글 단어 검색
		Scanner sc = new Scanner(System.in);

		for (int i = 0; i < 3; i++) {
			System.out.print("찾고 싶은 동물(영어 입력)>>>");

			String eng = sc.next();

			// 해시맵에서 '키' eng 의 '값' kor 검색
			String kor = animal.get(eng); // eng 가 해시맵에 없으면 null 리턴

			if (kor == null) {
				System.out.println(eng + "는 없는 동물 이름입니다.");
			} else {
				System.out.println(kor);
			}
		}
		sc.close();
	}
}
```


실행 결과는 다음과 같다.<br>


```java
(wolf,늑대)
(tiger,호랑이)
(lion,사자)
찾고 싶은 동물(영어 입력)>>>wolf
늑대
찾고 싶은 동물(영어 입력)>>>tiger
호랑이
찾고 싶은 동물(영어 입력)>>>lion
사자
```





## 8. 제네릭 컬렉션 활용 - 나의 제네릭 클래스 만들기


이번엔 나만의 제네릭 클래스를 만들어 보자.<br>
제네릭 클래스의 선언 방법은 기존 클래스 선언 방법과 유사하다.<br>
차이점은 클래스 이름 다음에 타입 매개변수(Type Parameter)를<br>
`<`와 `>` 사이에 선언한다는 점이다.<br>


```java
class MyClass<T> { // 제네릭 클래스, 타입 매개 변수 T
	T val; // 변수 val 의 타입은 T

	void set(T a) {
		val = a; // T 타입의 값 a 를 val 에 지정
	}

	T get() {
		return val; // T 타입의 값 val 리턴
	}
}

public class MyClassEx {
	public static void main(String[] args) {
		// 문자열을 다루도록 구체화
		MyClass<String> s = new MyClass<String>();

		s.set("hello");
		System.out.println(s.get());

		// 정수값을 다루도록 구체화
		MyClass<Integer> n = new MyClass<Integer>();

		n.set(7);
		System.out.println(n.get());
	}
}
```


실행 결과는 다음과 같다.<br>


```java
hello
7
```


이처럼 제네릭 클래스를 사용하면 get() 메소드의 반환값을<br>
명시적인 형 변환 없이 안전하게 사용할 수 있다.<br>


-----------------------------------------------------------------------<br>


지금까지 자바의 컬렉션과 제네릭에 대해 공부해 보았다.<br>
다음 글에서는 자바의 GUI 스윙에 대해서 공부해 보겠다.<br>


---
※ 본 글은 개인 학습을 목적으로 「명품 자바 에센셜」(황기태 지음, 생능출판)을 참고하여 작성하였습니다.