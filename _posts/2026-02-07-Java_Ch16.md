---
layout: single
title: "Java Chapter 16 – 소켓 프로그래밍"
date: 2026-02-07
categories:
  - Java
  - java_grammer
tags: [Java, 문법]
author_profile: true
read_time: true
comments: true
share: true
related: true
sidebar:
  nav: "categories_sidebar"
---


# 자바 소켓 프로그래밍


자바의 소켓 프로그래밍을 공부하기 위해서는<br>
먼저 TCP/IP를 가볍게 알고 넘어가야 할 필요가 있다.<br>






## 1. TCP/IP 기초


TCP/IP는 Transmission Control Protocol/Internet Protocol의 약자로,<br>
서로 다른 컴퓨터가 네트워크를 통해<br>
데이터를 주고받기 위한 통신 규약들의 집합이다.<br>

TCP는 어떻게 안전하게 보낼지(전송 방식),<br>
IP는 어디로 보낼지(주소)를 담당한다.<br>

자바 소켓은 TCP/IP 프로토콜 중<br>
주로 TCP 위에서 작동한다.<br>


---


### [TCP]


자바 소켓에서 기본으로 사용하는 통신 방식은 TCP이다.<br>

TCP는 다음과 같은 특징들을 가지고 있다.<br>


1. 연결 지향
-> 통신 전에 먼저 연결을 맺는다.<br>


2. 신뢰성 보장
-> 데이터가 순서대로 손실 없이, 중복 없이 전달된다.<br>

3. 스트림 기반
-> 데이터를 연속된 바이트 흐름으로 처리한다.<br>


그렇기 때문에 자바에선<br>
InputStream/OutputStream으로 데이터를 주고받는다.<br>


---


### [IP]


IP 주소는 네트워크 상의 컴퓨터를 식별하는 고유 번호이다.<br>
예를 들어 192.168.0.10 와 같은 숫자의 조합이 IP주소이다.<br>

IP 주소만으로는<br>
해당 컴퓨터에서 어떤 프로그램과 통신해야 하는지 알 수 없기 때문에,<br>
포트 번호가 필요하다.<br>


---


### [포트 번호]


포트(port)는 한 컴퓨터 안에서 실행중인 프로그램을 구분하는 번호이다.<br>
범위는 0에서 65535로,<br>
통신 대상은 IP + 포트 번호로 정확히 결정된다.<br>


---


### [TCP 연결 과정]


TCP의 연결 과정을 정리하자면 다음과 같다.<br>


1. 서버가 특정 포트에서 대기

2. 클라이언트의 연결 요청

3. 연결 성립

4. 데이터 송수신

5. 연결 종료








## 2. 소켓 프로그래밍


### [소켓(socket)]


소켓 통신은 개발자가 TCP/IP 프로토콜을 이용하여<br>
네트워크 통신 프로그램을 쉽게 작성할 수 있도록<br>
지원하는 기술이다.<br>

소켓(socket)은 두 응용프로그램 간의<br>
통신 연결 끝점(endpoint)으로,<br>
TCP/IP 기반 통신에서 데이터를 송수신하기 위한<br>
추상화된 통신 인터페이스이다.<br>

응용프로그램은 직접 상대방과 통신하지 않고,<br>
자신의 소켓을 통해 데이터를 보내거나<br>
소켓으로부터 데이터를 입력받는다.<br>

소켓은 IP 주소와 포트 번호의 조합으로 식별되며,<br>
이를 통해 통신할 상대방의 응용프로그램이 결정된다.<br>

자바의 Socket 클래스는<br>
TCP 프로토콜의 신뢰성 있는 데이터 전송 기능을 이용하여,<br>
데이터가 순서대로 손실 없이 전달되도록 한다.<br>


---


### [소켓과 서버 클라이언트 통신]


소켓 통신에서는 응용프로그램이<br>
서버와 클라이언트의 역할로 구분된다.<br>
일반적으로 정보를 제공하는 쪽이 서버이고,<br>
이를 요청하여 이용하는 쪽이 클라이언트이다.<br>

서버는 특정 포트에서 클라이언트의 접속 요청을 기다리며,<br>
클라이언트가 서버에 접속하면 통신이 시작된다.<br>


---


### [서버 소켓과 클라이언트 소켓]


자바에서는 서버 소켓과<br>
클라이언트 소켓을 사용하여<br>
서버-클라이언트 통신을 구현한다.<br>

서버 소켓은 클라이언트의 연결 요청을 수락하는 역할을 하며,<br>
연결이 성립되면 통신을 담당할 클라이언트 소켓을 생성한다.<br>

클라이언트는 클라이언트 소켓을 이용해 서버에 접속하고,<br>
실제 데이터 송수신은 이 클라이언트 소켓을 통해 이루어진다.<br>

즉, 서버 소켓은 연결을 기다리고,<br>
클라이언트 소켓은 데이터 통신을 담당한다.<br>
(서버 측에서 생성된 소켓과 클라이언트 측에서 생성된 소켓은<br>
서로 다른 객체이지만, 하나의 연결로 서로 통신한다.)<br>






## 3. 서버 클라이언트 통신 프로그램 구성 - 클라이언트 소켓


Socket은 java.net 패키지에 포함된 클래스로,<br>
클라이언트 측에서 서버에 접속하기 위해 사용하는 소켓이다.<br>

클라이언트는 Socket 객체를 생성하여 서버와 연결하고,<br>
이를 통해 데이터를 송수신한다.<br>

* ※ 서버 측에서도 연결이 성립된 이후의 통신에는 Socket 객체가 사용된다.<br>


---


### [1] 클라이언트 소켓 생성 및 서버 접속


```java
Socket clientSocket = new Socket("128.12.1.1", 9999);
// IP 주소가 128.12.1.1 이고 포트 번호가 9999인 서버에 접속
```


Socket(String host, int port) 생성자는<br>
소켓 생성과 동시에 서버에 대한 연결을 수행한다.<br>

다음과 같이 연결되지 않은 소켓을 생성한 뒤,<br>
명시적으로 서버에 연결할 수도 있다.<br>


```java
Socket clientSocket = new Socket();   
// 연결되지 않은 소켓 생성

clientSocket.connect(new InetSocketAddress("128.12.1.1", 9999));
// IP 주소가 128.12.1.1 이고 포트 번호가 9999인 서버에 접속
```


connect() 호출 시 운영체제가 로컬 IP와 포트를 자동으로 할당한다.<br>


---


### [2] 네트워크 입출력 스트림 생성


소켓이 서버에 연결되면, Socket 클래스의<br>
getInputStream()과 getOutputStream() 메소드를 이용하여<br>
서버와 데이터를 주고받기 위한 스트림을 얻는다.<br>

일반적으로 문자 단위 통신을 위해<br>
바이트 스트림을 문자 스트림으로 변환한 뒤,<br>
버퍼 스트림에 연결한다.<br>


```java
BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));

// InputStream(바이트)
// -> InputStreamReader(문자 변환)
// -> BufferedReader(버퍼 + readLine)

BufferedWriter out = new BufferedWriter(new OutputStreamWriter(clientSocket.getOutputStream()));

// OutputStream(바이트)
// -> OutputStreamWriter(문자 변환)
// -> BufferedWriter(버퍼 + write)
```


* 문자 스트림을 사용하므로 문자 데이터만 주고받을 수 있다.<br>


---


### [3] 서버로 데이터 전송


다음은 버퍼 출력 스트림 out을 통해<br>
클라이언트가 서버로 문자열 데이터를 전송하는 코드이다.<br>


```java
out.write("hello"+"\n");
out.flush();
```


서버가 BufferedReader.readLine()으로 데이터를 수신하는 경우,<br>
줄 끝을 나타내는 개행 문자(\n 또는 \r\n)를 함께 전송해야 한다.<br>

BufferedWriter는 버퍼 스트림이므로<br>
flush()를 호출해야 버퍼에 저장된 데이터가 즉시 전송된다.<br>


---


### [4] 서버로부터 데이터 수신


다음은 서버가 전송한 문자 하나를 수신하는 코드이다.<br>


```java
int x = in.read();
```


문자 하나를 읽어 정수 값으로 반환하고,<br>
스트림의 끝에 도달하면 -1을 반환한다.<br>


다음은 서버가 전송한 한 줄의 문자열을 수신하는 코드이다.<br>


```java
String line = in.readLine();
```


개행 문자(\n 또는 \r\n)가 올 때까지 읽으며,<br>
반환되는 문자열에는 개행 문자가 포함되지 않는다.<br>
스트림이 종료되면 null을 반환한다.<br>


---


### [5] 데이터 송수신 종료


모든 데이터 송수신이 끝나면<br>
소켓 연결을 종료한다.<br>


```java
clientSocket.close();
```


close()를 호출하면<br>
해당 소켓에 연결된 입력 스트림과 출력 스트림도 함께 닫힌다.<br>
이후 해당 소켓과 스트림은 더 이상 사용할 수 없다.<br>


---


### [Socket 클래스의 생성자와 주요 메소드]


다음은 Socket 클래스의 생성자들이다.<br>


```java
Socket()
// 연결되지 않은 상태의 소켓 생성

Socket(InetAddress address, int port)
// 소켓을 생성하고, 지정한 IP 주소와 포트 번호의 서버에 즉시 연결

Socket(String host, int port)
// 소켓을 생성하고, 호스트 이름과 포트 번호의 서버에 즉시 연결
// host가 null인 경우 루프백(loopback) 주소로 간주
```


다음은 Socket 클래스의 주요 메소드들이다.<br>


```java
void bind(SocketAddress bindpoint)
// 소켓에 로컬 IP 주소와 로컬 포트 번호를 바인딩

void close()
// 소켓을 닫음

void connect(SocketAddress endpoint)
// 지정한 서버 주소로 소켓을 연결

InetAddress getInetAddress()
// 연결된 원격 서버의 IP 주소 반환

InputStream getInputStream()
// 소켓의 입력 스트림 반환
// 상대방이 보낸 데이터를 읽을 수 있음

InetAddress getLocalAddress()
// 소켓의 로컬 IP 주소 반환

int getLocalPort()
// 소켓의 로컬 포트 번호 반환

int getPort()
// 연결된 원격 서버의 포트 번호 반환

OutputStream getOutputStream()
// 이 스트림에 데이터를 쓰면 상대방에게 전송됨

boolean isBound()
// 소켓이 로컬 주소에 바인딩되어 있으면 true 반환

boolean isConnected()
// 소켓이 원격 서버에 연결되어 있으면 true 반환

boolean isClosed()
// 소켓이 닫혀 있으면 true 반환

void setSoTimeout(int timeout)
// 입력 스트림 타임아웃 시간(ms) 지정
// 0이면 타임아웃 해제
```






## 4. 서버 클라이언트 통신 프로그램 구성 - 서버 소켓


ServerSocket 클래스는 java.net 패키지에 포함된 클래스로,<br>
서버 소켓을 구현한다.<br>

ServerSocket은 클라이언트로부터<br>
연결 요청을 기다리는 목적으로만 사용되며,<br>
서버가 클라이언트의 연결 요청을 수락하면<br>
통신을 담당하는 Socket 객체를 반환한다.<br>

즉, ServerSocket은 데이터의 송수신에는 사용되지 않는다.<br>


---


### [1] 서버 소켓 생성


ServerSocket 생성자는 포트 번호를 인자로 받아<br>
해당 포트에서 클라이언트의 연결 요청을 대기하는<br>
서버 소켓을 생성한다.<br>

이 포트 번호는 클라이언트가 접속해 올<br>
서버 측 포트 번호이다.<br>
이미 사용 중인 포트 번호를 지정하면 오류가 발생한다.<br>

다음은 9999번 포트 번호를 사용하는<br>
서버 소켓을 생성하는 코드이다.<br>


```java
ServerSocket listener = new ServerSocket(9999);
```


---


### [2] 클라이언트로부터 접속 대기


ServerSocket 클래스의 accept() 메소드를 이용하여<br>
클라이언트로부터의 연결 요청을 기다린다.<br>


```java
Socket socket = listener.accept();
```

accept() 메소드가 연결 요청을 수락하면,<br>
클라이언트와 데이터 통신을 수행하기 위한<br>
Socket 객체를 별도로 생성하여 리턴한다.<br>

서버와 연결된 클라이언트와의 데이터 통신은<br>
이 Socket 객체를 이용한다.<br>

Socket 객체는 서버가 열어 둔 포트를 통해<br>
클라이언트와 데이터를 주고받는다.<br>


---


### [3] 네트워크 입출력 스트림 생성


클라이언트와 데이터를 주고받기 위한 스트림은<br>
socket 객체의 getInputStream(), getOutputStream() 메소드를 이용하여 생성한다.<br>
이 메소드들로 얻은 스트림을 버퍼 스트림에 연결하여 사용한다.<br>


```java
BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));

BufferedWriter out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));
```

버퍼 스트림인 in, out을 이용하여<br>
클라이언트와 데이터를 주고받는다.<br>


* 문자 스트림을 사용하므로 문자 데이터만 주고받을 수 있다.<br>


---


### [4] 클라이언트로부터 데이터 수신


다음은 클라이언트가 전송한 문자 하나를 수신하는 코드이다.<br>


```java
int x = in.read();
```


문자 하나를 읽어 정수 값으로 반환하고,<br>
스트림의 끝에 도달하면 -1을 반환한다.<br>


다음은 클라이언트가 전송한 한 줄의 문자열을 수신하는 코드이다.<br>


```java
String line = in.readLine();
```


개행 문자(\n 또는 \r\n)가 올 때까지 읽으며,<br>
반환되는 문자열에는 개행 문자가 포함되지 않는다.<br>
스트림이 종료되면 null을 반환한다.<br>


---


### [5] 클라이언트로 데이터 송신


다음은 버퍼 출력 스트림 out을 통해<br>
서버가 클라이언트로 문자열 데이터를 전송하는 코드이다.<br>


```java
out.write("Hello Client"+"\n");
out.flush();
```


클라이언트가 BufferedReader.readLine()으로 데이터를 수신하는 경우,<br>
줄 끝을 나타내는 개행 문자(\n 또는 \r\n)를 함께 전송해야 한다.<br>

BufferedWriter는 버퍼 스트림이므로<br>
flush()를 호출해야 버퍼에 저장된 데이터가 즉시 전송된다.<br>


---


### [6] 데이터 송수신 종료


데이터 송수신을 모두 수행하고<br>
소켓 연결을 끊고자 하면 다음과 같이 한다.<br>


```java
socket.close();
```


---


### [7] 서버 응용프로그램 종료


더 이상 클라이언트의 접속을 받지 않고<br>
서버 응용프로그램을 종료하고자 하는 경우에는 다음과 같이 한다.<br>


```java
serverSocket.close();
```


---


### [SeverSocket 클래스의 생성자와 주요 메소드]


다음은 ServerSocket 클래스의 생성자들이다.<br>


```java
ServerSocket(int port)
// 지정한 포트 번호에 바인딩된 서버 소켓을 생성한다.
```


다음은 ServerSocket 클래스의 주요 메소드들이다.<br>


```java
Socket accept()
// 클라이언트로부터 연결 요청을 기다림
// 요청이 들어오면 수락
// 클라이언트와 데이터를 주고받을 새로운 Socket 객체 반환

void close()
// 서버 소켓을 닫음

InetAddress getInetAddress()
// 서버 소켓의 로컬 IP 주소 반환

int getLocalPort()
// 서버 소켓의 로컬 포트 번호 반환

boolean isBound()
// 서버 소켓이 로컬 주소와 포트에 바인딩되어 있으면 true를 반환

boolean isClosed()
// 서버 소켓이 닫혀있으면 true 반환

void setSoTimeout(int timeout)
// accept()가 대기하는 타임아웃 시간을 밀리초 단위로 지정
// 0이면 타임아웃이 해제되어 무한정 대기
```






## 5. 서버 - 클라이언트 채팅 프로그램 예제


이 프로그램은 ServerSocket과 Socket을 이용한<br>
1:1 채팅 프로그램으로,<br>
서버와 클라이언트가 각각 독립적인 Java Application으로 실행되며<br>
문자열 기반 스트림을 통해 한 줄 단위로 메시지를 주고받는다.<br>


먼저 다음은 서버 프로그램 클래스이다.<br>


```java
public class ServerEx {

	public static void main(String[] args) {

		BufferedReader in = null;
		BufferedWriter out = null;

		ServerSocket listener = null;

		Socket socket = null;

		Scanner sc = new Scanner(System.in);

		try {
			listener = new ServerSocket(9999); // 서버 소켓 생성
			System.out.println("연결 대기 중...");

			socket = listener.accept();
			System.out.println("***연결 완료***");
			System.out.println("***[서버 채팅방]***");

			in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
			out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));

			while (true) {
				String inputMsg = in.readLine(); // 클라이언트로부터 한 줄 읽기

				if (inputMsg.equalsIgnoreCase("bye")) {
					System.out.println("클라이언트 측에서 채팅을 종료하였습니다.");
					break;
				}
				System.out.println("클라이언트: " + inputMsg);

				System.out.print("보내기>>>");

				String outputMsg = sc.nextLine(); // 키보드에서 한 줄 읽기

				out.write(outputMsg + "\n");
				out.flush(); // 스트림 버퍼에 있는 모든 문자열 즉시 전송
			}
		} catch (IOException e) {
			System.out.println(e.getMessage());
		} finally {
			try {
				sc.close();
				socket.close();
				listener.close();
			} catch (IOException e) {
				System.out.println("채팅 중 오류 발생");
			}
		}
	}

}
```


다음은 클라이언트 프로그램 클래스이다.<br>


```java
public class ClientEx {

	public static void main(String[] args) {

		BufferedReader in = null;
		BufferedWriter out = null;

		Socket socket = null;

		Scanner sc = new Scanner(System.in);

		try {
			socket = new Socket("localhost", 9999); // 클라이언트 소켓 생성. 서버에 연결

			System.out.println("***서버에 연결되었습니다***");
			System.out.println("***[클라이언트 채팅방]***");

			in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
			out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));

			while (true) {
				System.out.print("보내기>>>");

				String outputMsg = sc.nextLine(); // 키보드에서 한 줄 읽기

				if (outputMsg.equalsIgnoreCase("bye")) {
					out.write(outputMsg + "\n");
					out.flush(); // 스트림 버퍼에 있는 모든 문자열 즉시 전송
					break;
				}

				out.write(outputMsg + "\n");
				out.flush();

				String inputMsg = in.readLine(); // 서버로부터 한 줄 읽기

				System.out.println("서버: " + inputMsg);
			}
		} catch (IOException e) {
			System.out.println(e.getMessage());
		} finally {
			try {
				sc.close();
				if (socket != null) {
					socket.close(); // 클라이언트 소켓 닫기
				}
			} catch (IOException e) {
				System.out.println("서버와 채팅 중 오류 발생");
			}
		}
	}

}
```


실행 결과는 다음과 같다.<br>


![서버-클라이언트 채팅 예제1](/assets/images/서버-클라이언트%20채팅%20예제1.PNG)


서버 프로그램을 먼저 실행한 후,<br>
클라이언트 프로그램을 실행하면<br>
서버와 클라이언트 간의 채팅이 준비된다.<br>

이후 클라이언트 측에서<br>
bye라는 문자열을 입력하면<br>
서버와의 연결이 종료되면서<br>
프로그램이 종료된다.<br>


![서버-클라이언트 채팅 예제2](/assets/images/서버-클라이언트%20채팅%20예제2.PNG)


-----------------------------------------------------------------------<br>


지금까지 자바 프로그래밍의 전반적인 내용을 공부해 보았다.<br>

기술은 나날이 발전하기 때문에<br>
책을 기반으로 학습하되,<br>
최신 공식 문서를 함께 참고하면서<br>
달라진 내용이나 잘못된 부분이 없는지 확인하였다.<br>
이 과정에서 공식 문서 해석이나 개념 이해에<br>
어려움이 있는 부분은<br>
AI 도구를 보조적으로 활용하여<br>
내용을 정리하고 이해를 보완하였다.<br>
그리고 그러한 부분이 있을 때마다<br>
직접 수정하거나 내용을 보완하며 공부해 보았다.<br>

이번 공부는 자바의 기초를 단단히 다지는 데에<br>
의미를 두고 진행하였다.<br>
앞으로는 이번에 학습한 내용을 바탕으로<br>
크고 작은 프로젝트를 만들어 보면서<br>
더 다양한 기술들도 함께 공부해 나갈 계획이다.<br>


---
※ 본 글은 개인 학습을 목적으로 「명품 자바 에센셜」(황기태 지음, 생능출판)을 참고하여 작성하였습니다.