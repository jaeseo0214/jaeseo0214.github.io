---
layout: single
title: "Java Chapter 15 – 입출력"
date: 2026-02-04
categories:
  - Java
  - java_grammer
tags: [Java, 문법]
author_profile: true
read_time: true
comments: true
share: true
related: true
sidebar:
  nav: "categories_sidebar"
---


# 자바 입출력 스트림과 파일 입출력







## 1. 자바의 입출력 스트림


자바에서 입출력 스트림은 <br>
응용 프로그램과 입출력 장치를 연결하는 통로 역할을 하며,<br>
데이터가 한쪽에서 다른 쪽으로 순서대로 전달되도록 한다.<br>

사용자는 키보드와 화면을 통해 프로그램과 상호작용하지만,<br> 
응용 프로그램의 코드는 키보드나 화면과 직접 입출력을 수행하지 않는다.<br>
대신 입출력 스트림 객체를 생성하고,<br> 
이를 통해 데이터를 읽고 출력한다.<br>

자바의 스트림은 입력 스트림과 출력 스트림으로 구분되며,<br>  
각 스트림은 한 방향으로만 데이터를 전송한다.<br>

스트림 입출력은 선입선출(FIFO) 방식으로 처리되며,<br> 
바이트 단위로 데이터를 처리하는 바이트 스트림과<br>
문자 단위로 데이터를 처리하는 문자 스트림이 존재한다.<br>


---


### [문자 스트림과 바이트 스트림]


자바에서 입출력 스트림은<br>
문자 스트림과 바이트 스트림 두 종류로 나뉜다.<br>

문자 스트림은 문자 단위로 데이터를 처리하며,<br>
문자 인코딩을 기준으로 데이터를 읽고 쓴다.<br>
따라서 문자 데이터가 아닌 이진 데이터를<br>
문자 스트림으로 출력하면<br>
문자가 깨지거나 의미 없는 기호가 출력될 수 있다.<br>

또한 문자 데이터가 아닌 정보를<br>
문자 입력 스트림으로 읽을 경우,<br> 
응용 프로그램에는 의도하지 않은 문자로 전달될 수 있다.<br>

바이트 스트림은 바이트 단위로 데이터를 처리하는 스트림으로,  
스트림을 통해 들어오고 나가는 정보를<br>
문자 해석 없이 순수한 이진 데이터로 다룬다.<br>
따라서 문자 데이터뿐만 아니라<br>
이미지, 오디오, 파일 등 모든 데이터를 처리할 수 있다.<br>

자바 플랫폼은 문자 스트림과 바이트 스트림을 이용한<br>
입출력을 지원하기 위해 다양한 클래스들을 제공하며,<br>
이들은 모두 java.io 패키지에 포함되어 있다.<br>

문자 스트림을 다루는 클래스는<br>
이름 뒤에 Reader 또는 Writer를 붙여 구분하며,<br>
바이트 스트림을 다루는 클래스는<br>
InputStream 또는 OutputStream 계열로 구분한다.<br>


---


### [스트림 연결]


스트림은 서로 연결하여 사용할 수 있으며,<br>  
이를 통해 바이트 스트림을 문자 스트림으로 변환할 수 있다.<br> 
다음은 바이트 스트림과 문자 스트림을 연결하는 예이다.<br>


```java
InputStreamReader rd = new InputStreamReader(System.in);
```


위 코드는 키보드 입력을 나타내는 바이트 스트림인<br>
System.in에 문자 스트림을 연결하여<br>
InputStreamReader 객체 rd를 생성한다.<br>

이렇게 하면 System.in은 사용자의 키 입력을<br>
바이트 단위로 입력받고,<br>
rd는 입력된 바이트 데이터를 문자 인코딩을 통해<br>
문자로 변환하여 응용 프로그램에 전달한다.<br>

자바 응용 프로그램은 다음과 같이<br>
입력된 키의 문자 값을 읽을 수 있다.<br>


```java
while(true) {
    int c = rd.read();  // 입력 스트림으로부터 키 입력. c는 입력된 키의 문자 값

    if(c == -1) {   // 입력 스트림의 끝을 만나는 경우
        break;  // 입력 종료
    }
}
```






## 2. 문자 스트림과 텍스트 파일 입출력


문자 스트림은 문자(character)를 단위로 다루는 스트림으로,<br>
바이너리 데이터를 그대로 처리하는 데에는 적합하지 않다.<br>

텍스트 파일은 문자로 구성된 파일이며,<br>
텍스트 파일을 읽고 쓰기 위해서는<br>
문자 스트림 기반의 입출력 시스템을 사용해야 한다.<br>


---


### [텍스트 파일 읽기]


* 파일 입력 스트림 생성(파일 열기)


파일을 읽기 위해서는 먼저<br>
파일 입력 스트림 객체를 생성하여<br>
파일과 연결해야 한다.<br>


```java
FileReader fin = new FileReader("c:\\test.txt");
```


FileReader의 생성자는<br>
스트림 객체를 생성한 후,<br>
지정된 파일을 찾아 열고 스트림과 연결한다.<br>


* 파일 읽기


fin.read()는 파일로부터 문자 하나를 읽어 int 타입으로 반환하며,<br>
파일의 끝(EOF)에 도달하면 -1을 반환한다.<br>

다음은 read()를 이용하여<br>
파일 전체를 읽어 화면에 출력하는 코드이다.<br>


```java
int c;

while ((c = fin.read()) != -1) {   // 문자 하나를 c에 읽어 들임. 파일 끝까지 반복
    System.out.print((char) c);    // 읽은 문자를 화면에 출력
}
```


파일의 크기가 큰 경우,<br>
한 번에 한 문자씩 읽으면 성능이 떨어질 수 있으므로,<br>
다음과 같이 배열을 이용해 여러 문자를<br> 
한 번에 읽는 방식을 사용할 수 있다.<br>


```java
char [] buf = new char [1024];

int n = fin.read(buf);  // 최대 1024개의 문자를 읽고, 실제 읽은 문자 수를 n에 반환
```


참고로 read()의 반환 타입이 char가 아닌 int인 이유는<br>
파일의 끝(EOF)을 나타내는 값 -1을 함께 표현하기 위해서이다.<br>

* 문자를 읽은 경우
-> 반환값은 0 ~ 65535 범위의 유니코드 값

* 파일의 끝에 도달한 경우
-> 반환값은 -1

즉, char로는 표현할 수 없는 -1 값을 반환해야 하므로,<br>
반환 타입이 int로 정의되어 있다.<br>

이 때문에 실제 문자를 사용할 때는<br>
다음과 같이 char 타입으로 형변환하여 사용한다.


```java
(char) c
```


* 스트림 닫기


스트림이 더 이상 필요 없게 된 경우 스트림을 닫아야 한다.<br>
스트림을 닫으면 사용 중이던 시스템 자원이 해제된다.<br>
닫힌 스트림으로부터는 더 이상 읽거나 쓸 수 없다.<br>


```java
fin.close();
```


다음은 FileReader의 생성자들이다.<br>


```java
FileReader(File file)   // file 에 지정된 파일로부터 읽는 FileReader 생성
FileReader(String name)   // name 이름의 파일로부터 읽는 FileReader 생성
```


---


다음은 FileReader의 주요 메소드들이다.<br>


```java
int read()  // 한 개의 문자를 읽어 정수형(char 값)으로 반환한다. 더 이상 읽을 문자가 없으면 -1을 반환한다.

int read(char[] cbuf)   // 최대 cbuf.length개의 문자를 읽어 배열에 저장한다.실제로 읽은 문자 수를 반환하며, 스트림의 끝(EOF)에 도달하여 더 이상 읽을 수 없으면 -1을 반환한다.

int read(char[] cbuf, int off, int len)   // 최대 len개의 문자를 읽어 cbuf 배열의 off 위치부터 저장한다. 실제로 읽은 문자 수를 반환하며, 스트림의 끝에 도달하면 -1을 반환한다.

String getEncoding()  // 이 스트림이 사용하는 문자 인코딩 이름을 반환한다.인코딩을 알 수 없는 경우 null을 반환할 수 있다.

void close()  // 입력 스트림을 닫고 관련된 시스템 자원을 해제한다. 닫힌 이후에는 스트림을 사용할 수 없다.
```


---


### [파일 입출력과 예외 처리]


다음과 같은 경우, 파일 입출력 실행 중 예외가 발생할 수 있다.<br>

* 파일의 경로명이 다르거나, 어떤 상황으로 인해 파일을 열 수 없는 경우

이 경우 FileReader 생성자는<br> 
`FileNotFoundException` 예외를 발생시킨다.<br>


* 파일을 읽거나 쓰거나 닫는 동안 디스크의 오작동, 파일 손상 등으로 인해 입출력 오류가 발생하는 경우


이 경우 read(), write(), close() 메소드는<br>
`IOException` 예외를 발생시킨다.<br>


그러므로 파일 입출력 코드는<br>
IOException 및 FileNotFoundException에 대한<br>
예외 처리가 필요하다.<br>

이 예외 처리는 try-catch 문으로 처리하거나,<br>
메소드 선언부에 throws로 위임할 수 있다.<br>

또한 try-with-resources 문을 사용하면<br>
스트림을 자동으로 닫으면서 예외를 처리할 수 있다.<br>


* try-catch로 직접 처리하는 경우


```java
try {
    FileReader fr = new FileReader("test.txt");
    int ch = fr.read();
    fr.close(); // close() 직접 호출
} catch (IOException e) {
    e.printStackTrace();  // 발생한 예외의 자세한 정보(에러 추적 경로)를 콘솔에 출력하는 메소드
}
```


* throws로 예외를 호출한 쪽으로 위임하는 경우


```java
public static void readFile() throws IOException {
    FileReader fr = new FileReader("test.txt");
    int ch = fr.read();
    fr.close();
}
```


* try-with-resources 사용 (자동 close)


```java
try (FileReader fr = new FileReader("test.txt")) {
    int ch = fr.read();
} catch (IOException e) {
    e.printStackTrace();
}   // close() 자동 실행
```


다음은 FileReader로 텍스트 파일을 읽는 예제이다.<br>


```java
public class FileReaderEx {
	public static void main(String[] args) {
		FileReader fr = null;

		try {
			fr = new FileReader("C:\\Users\\User\\Desktop\\javatxt.txt"); // 문자 입력 스트림 생성

			int c;

			while ((c = fr.read()) != -1) { // 한 문자씩 파일 끝까지 읽기
				System.out.print((char) c);
			}
			fr.close();
		} catch (IOException e) {
			System.out.println("입출력 오류");
		}
	}
}
```


실행 결과는 다음과 같다.<br>


![FileReader 예제](/assets/images/FileReader%20예제.PNG)


---


### [텍스트 파일 쓰기]


FileWriter는 파일에 데이터를 쓰기 위한 문자 기반 출력 스트림이다.<br>


* 파일 출력 스트림 생성


다음 코드는 c:\Temp\test.txt 파일에<br>
텍스트를 쓰는 출력 스트림을 생성한다.<br>


```java
FileWriter fout = new FileWriter("c:\\Temp\\test.txt");
```


FileWriter 생성자는 스트림 객체 생성 후,<br>
파일을 열어 스트림과 연결한다.<br>

파일이 없는 경우 빈 파일을 생성하고,<br>
이미 파일이 있는 경우 기본적으로 파일 내용을 지우고<br>
파일의 처음부터 쓰기가 진행된다.<br>


* 파일 쓰기


다음 코드는 문자 하나를 파일에 쓴다.<br>


```java
fout.write('A');
```


배열을 만들어 한 번에 한 블록씩 쓰는 것도 가능하다.<br>


```java
char [] buf = new char [1024];

fout.write(buf, 0, buf.length);   // buf[0] 부터 buf 크기만큼 쓰기
```


* 스트림 닫기


쓰기를 완료했다면 close()를 호출하여 스트림을 닫는다.<br>
스트림을 닫으면 연결된 파일도 닫힌다.<br>


```java
fout.close();
```


---


다음은 FileWriter의 생성자들이다.<br>


```java
FileWriter(File file)  // file 에 데이터를 저장할 FileWriter 생성

FileWriter(String name)   // name 파일에 데이터를 저장할 FileWriter 생성

FileWriter(File file, boolean append)   // FileWriter 를 생성하며, append가 true이면 파일 끝에 이어쓰기

FileWriter(String name, boolean append)   // FileWriter 를 생성하며, append가 true이면 파일 끝에 이어쓰기
```


다음은 FileWriter의 주요 메소드들이다.<br>


```java
void write(int c)   // c 를 char 로 변환하여 한 개의 문자 출력

void write(String str)   // 문자열 str 출력

void write(String str, int off, int len)  // 인덱스 off 부터 len 개의 문자를 str 문자열에서 출력

void write(char [] cbuf, int off, int len)  // 인덱스 off 부터 len 개의 문자를 배열 cbuf 에서 출력

void flush()  // 스트림에 남아 있는 데이터를 모두 출력

String getEncoding()  // 스트림이 사용하는 문자 집합의 이름 리턴

void close()  // 출력 스트림을 닫고 관련 시스템 자원 해제
```


다음은 FileWriter를 이용하여 텍스트 파일을 쓰는 예제이다.<br>


```java
public class FileWriterEx {
	public static void main(String[] args) {
		InputStreamReader in = new InputStreamReader(System.in); // 키보드로부터 읽는 문자 입력 스트림 생성

		FileWriter fw = null;

		int c;

		try {
			fw = new FileWriter("C:\\Users\\User\\Desktop\\javatxt.txt");

			while ((c = in.read()) != -1) { // ctrl - z 키(EOF) 가 입력될 때까지 반복
				fw.write(c);
			}
			in.close();
			fw.close();
		} catch (IOException e) {
			System.out.println("입출력 오류");
		}

	}
}
```


실행 결과는 다음과 같다.<br>


![FileWriter 예제](/assets/images/FileWriter%20예제.PNG)






## 3. 바이트 스트림과 바이너리 파일 입출력


바이트 스트림(byte stream)은<br>
바이트(byte) 단위로 데이터를 입출력하는 스트림이다.<br>
문자 인코딩과 무관하게 이진(binary) 데이터를 그대로 처리한다.<br>

주로 이미지, 오디오, 동영상과 같은
바이너리 파일을 읽고 쓰는 데 사용된다.<br>

바이너리 파일 입출력을 위한 대표적인 바이트 스트림 클래스는<br>
FileInputStream과 FileOutputStream이다.<br>


---


### [바이너리 파일 쓰기]


프로그램 내부의 변수나 배열에 저장된
바이너리 데이터를 변형 없이 파일에 그대로 저장해야 하는 경우가 있다.<br>

예를 들어,<br>
이미지 버퍼에 저장된 바이트 데이터를<br> 
그대로 이미지 파일로 저장하는 경우가 이에 해당한다.<br>

이처럼 변수의 바이너리 값이 그대로 기록된 파일은<br>
텍스트 파일과 달리 사람이 직접 읽거나 쉽게 해석할 수 없다.<br>


* 파일 출력 스트림 생성


다음은 c:\Temp\test.out 파일에<br>
바이너리 데이터를 기록하기 위한 출력 스트림을 생성하는 코드이다.<br>


```java
FileOutputStream fout = new FileOutputStream("c:\\Temp\\test.out");
```


FileOutputStream 생성자는<br>
스트림 객체를 생성하면서 지정한 파일을 열어 스트림에 연결한다.<br>

파일이 존재하지 않으면 새 파일을 생성하고,<br>
파일이 이미 존재하면 기존 내용을 모두 삭제한 후 스트림에 연결한다.


* 파일 쓰기


파일에 데이터를 쓰기 위해서는<br>
write() 메소드를 사용한다.<br>

다음은 바이트 배열의 각 요소를<br>
하나씩 파일에 기록하는 코드이다.<br>


```java
byte[] b = { 3, 7, 11, 13, 17 };

for(int i = 0; i < b.length; i++) {
	fout.write(b[i]); 	// 배열 b 의 바이트를 바이너리 그대로 기록
}
```


또는 다음과 같이<br>
반복문 없이 한 번에 바이트 배열 전체를 기록할 수도 있다.<br>


```java
fout.write(b); 	// 배열 b에 저장된 모든 바이트를 한 번에 기록
```


---


다음은 FileOutputStream의 생성자들이다.<br>


```java
FileOutputStream(File file)  
// file이 지정하는 파일에 출력하는 FileOutputStream 생성

FileOutputStream(String name)  
// name이 지정하는 파일에 출력하는 FileOutputStream 생성

FileOutputStream(File file, boolean append)  
// append가 true이면 file이 지정하는 파일의 끝에 데이터를 이어서 저장

FileOutputStream(String name, boolean append)  
// append가 true이면 name이 지정하는 파일의 끝에 데이터를 이어서 저장
```


다음은 FileOutputStream의 주요 메소드들이다.<br>


```java
void write(int b)  
// int 값의 하위 8비트를 출력 스트림으로 출력

void write(byte[] b)  
// 배열 b에 저장된 모든 바이트를 출력 스트림으로 출력

void write(byte[] b, int off, int len)  
// 배열 b의 off 위치부터 len개의 바이트를 출력 스트림으로 출력

void flush()  
// 출력 스트림에 남아 있는 데이터를 모두 출력

void close()  
// 출력 스트림을 닫고 관련된 시스템 자원을 해제
```


다음은 FileOutputStream을 이용해 바이너리 파일을 쓰는 예제이다.<br>


```java
public class FileOutputStreamEx {

	public static void main(String[] args) {

		byte[] b = { 3, 7, 11, 13, 17 };

		try {
			FileOutputStream fo = new FileOutputStream("C:\\Users\\dsk98\\OneDrive\\Desktop\\javatxt.txt");

			for (int i = 0; i < b.length; i++) {
				fo.write(b[i]);
			}
			fo.close();
		} catch (IOException e) {
			System.out.println("오류 발생");
		}
		System.out.println("파일을 저장하였습니다.");
	}
}
```


실행 결과는 다음과 같다.<br>


![FileOutputStream 예제](/assets/images/FileOutputStream%20예제.jpg)


참고로, 저장된 데이터는 바이너리 데이터이기 때문에<br>
메모장에서 열어보면 사람이 읽을 수 있는 형태가 아니며,<br>
이상한 기호로 깨져 보인다.<br>


---


### [바이너리 파일 읽기]


바이트 스트림으로 파일을 읽는 스트림 클래스는 FileInputStream이다.<br>

다음은 파일에서 한 바이트씩 읽어<br>
배열 b에 저장하는 코드이다.<br>


```java
int n = 0;
int c;

while((c = fin.read()) != -1) {
	b[n] = (byte)c; 	// 읽은 바이트를 배열에 저장. read()는 int를 리턴하므로 byte로 형변환

	n++;
}
```


또한 다음과 같이 한 번에 배열로 읽어들이는 것도 가능하다.<br>
이 경우 실제로 읽은 바이트 수는 read()의 리턴값으로 확인할 수 있다.<br>


```java
fin.read(b);
```


---


다음은 FileInputStream의 생성자들이다.<br>


```java
FileInputStream(File file)
// file이 지정하는 파일로부터 읽는 FileInputStream 생성

FileInputStream(String name)
// name이 지정하는 파일로부터 읽는 FileInputStream 생성
```


다음은 FileInputStream의 주요 메소드들이다.<br>


```java
int read()
// 입력 스트림에서 한 바이트를 읽어 0~255 범위의 int 값으로 리턴, EOF이면 -1 리턴

int read(byte[] b)
// 최대 b.length 바이트를 읽어 배열 b에 저장하고, 실제로 읽은 바이트 수를 리턴

int read(byte[] b, int off, int len)
// 최대 len개의 바이트를 읽어 b 배열의 off 위치부터 저장하고 실제로 읽은 바이트 수를 리턴

int available()
// 입력 스트림에서 현재 읽을 수 있는 바이트 수 리턴

void close()
// 입력 스트림을 닫고 관련된 시스템 자원 해제
```


다음은 FileInputStream을 이용하여 바이너리 파일을 읽는 예제이다.<br>


```java
public class FileInputStreamEx {

	public static void main(String[] args) {

		byte[] b = new byte[5];

		try {
			FileInputStream fi = new FileInputStream("C:\\Users\\dsk98\\OneDrive\\Desktop\\javatxt.txt");

			int n = 0;
			int c;

			while ((c = fi.read()) != -1) {
				b[n] = (byte) c; // 읽은 바이트를 배열에 저장
				n++;
			}

			// 배열 b 의 바이트 값을 모두 화면에 출력
			System.out.println("파일에서 읽은 데이터를 출력합니다.");

			int i = 0;
			while (i < b.length) {
				System.out.print(b[i] + " ");
				i++;
			}
			System.out.println();
			fi.close();
		} catch (IOException e) {
			System.out.println("오류 발생");
		}
	}
}
```


실행 결과는 다음과 같다.<br>


![FileInputStream 예제](/assets/images/FileInputStream%20예제.jpg)






## 4. File 클래스


File 클래스는 파일이나 디렉터리에 대해,<br>
속성 정보 제공 및 파일 관리 작업을 지원한다.<br>

File 클래스 자체에는 파일 입출력 기능이 없기 때문에,<br>
앞에서 공부한 파일 입출력 클래스를 이용해야 한다.<br>


---


다음은 File 클래스의 생성자들이다.<br>


```java
File(File parent, String child)
// parent 디렉터리에 child 이름의 서브 디렉터리나 파일을 나타내는 File 객체 생성

File(String pathname)
// pathname이 나타내는 파일이나 디렉터리에 대한 File 객체 생성

File(String parent, String child)
// parent 디렉터리에 child 이름의 서브 디렉터리나 파일을 나타내는 File 객체 생성

File(URI uri)
// URI를 추상 경로명으로 변환하여 File 객체 생성
```


다음은 File 클래스의 주요 메소드들이다.<br>


```java
boolean mkdir()
// 새로운 디렉터리를 생성 (부모 디렉터리가 존재해야 함)

String[] list()
// 디렉터리 내의 파일과 서브 디렉터리 리스트를 문자열 배열로 리턴

File[] listFiles()
// 디렉터리 내의 파일과 서브 디렉터리 리스트를 File 배열로 리턴

boolean renameTo(File dest)
// dest가 지정하는 경로명으로 파일이나 디렉터리의 이름 변경 또는 이동

boolean delete()
// 파일 또는 빈 디렉터리를 삭제

long length()
// 파일의 크기를 바이트 단위로 리턴

String getPath()
// 파일이나 디렉터리의 경로명을 문자열로 리턴

String getParent()
// 파일이나 디렉터리의 부모 디렉터리 이름을 문자열로 리턴

String getName()
// 파일 또는 디렉터리 이름을 문자열로 리턴

boolean isFile()
// 일반 파일이면 true 리턴

boolean isDirectory()
// 디렉터리이면 true 리턴

long lastModified()
// 파일이 마지막으로 변경된 시간 리턴

boolean exists()
// 파일 또는 디렉터리가 존재하면 true 리턴
```


다음은 File 클래스를 이용하여 파일을 관리하는 예제이다.<br>


```java
public class FileClassEx {

	public static void listDirectory(File dir) {
		System.out.println("-------" + dir.getPath() + "의 서브 리스트-------");

		File[] subFiles = dir.listFiles(); // 디렉터리에 포함된 파일과 디렉터리 이름의 리스트 얻기

		for (int i = 0; i < subFiles.length; i++) {
			File f = subFiles[i];

			long t = f.lastModified(); // 마지막으로 수정한 시간

			System.out.print(f.getName());
			System.out.print("\t 파일 크기: " + f.length());
			System.out.printf("\t 수정한 시간: %tb %td %ta %tT\n", t, t, t, t);
		}
	}

	public static void main(String[] args) {

		File f1 = new File("c:\\windows\\system.ini");

		System.out.println(f1.getPath() + ", " + f1.getParent() + ", " + f1.getName());

		String res = "";

		if (f1.isFile()) {
			res = "파일";
		} else if (f1.isDirectory()) {
			res = "디렉터리";
		}

		System.out.println(f1.getPath() + "은 " + res + "입니다.");

		File f2 = new File("c:\\Temp\\java_sample");

		// f2 디렉터리가 존재하는지 검사
		if (!f2.exists()) {
			f2.mkdir();
			System.out.println("파일 생성 성공");
		}

		listDirectory(new File("c:\\Temp")); // 경로명에 있는 파일 리스트 출력

		f2.renameTo(new File("c:\\tmp\\javasample")); // 디렉터리 이동 및 이름 변경

		listDirectory(new File("c:\\Temp"));
	}

}
```


실행 결과는 다음과 같다.<br>


![FileClass 예제](/assets/images/FileClass%20예제.jpg)






## 5. 파일 복사 응용프로그램 작성


파일을 복사할 때,<br>
바이너리 파일은 바이트 스트림을 사용해야<br>
정확하게 복사할 수 있다.<br>

텍스트 파일은 문자 스트림이나<br>
바이트 스트림을 모두 사용하여 복사할 수 있다.<br>


---


### [텍스트 파일 복사]


다음은 문자 스트림을 이용하여<br>
텍스트 파일을 복사하는 예제이다.<br>

이 예제는 문자 스트림을 사용하므로,<br>
텍스트 파일만 올바르게 복사할 수 있다.<br>


```java
public class TextCopyEx {

	public static void main(String[] args) {

		File src = new File("c:\\windows\\system.ini"); // 원본 파일 경로명

		File dest = new File("c:\\Temp\\system.txt"); // 복사 파일 경로명

		int c;

		try {
			FileReader fr = new FileReader(src); // 파일 입력 문자 스트림 생성 (외부 -> 프로그램)

			FileWriter fw = new FileWriter(dest); // 파일 출력 문자 스트림 생성 (프로그램 -> 외부)

			while ((c = fr.read()) != -1) {
				fw.write((char) c);
			}
			fr.close();
			fw.close();

			System.out.println("파일 복사 완료");
		} catch (IOException e) {
			System.out.println("파일 복사 오류");
		}
	}

}
```


---


### [바이너리 파일 복사]


다음은 바이트 스트림을 이용하여 바이너리 파일을 복사하는 예제이다.<br>


```java
public class BinaryCopyEx {

	public static void main(String[] args) {
		File src = new File("c:\\Temp\\dog.jpeg"); // 원본 파일 경로명

		File dest = new File("c:\\tmp\\dog_copy.jpeg"); // 복사 파일 경로명

		int c;

		try {
			FileInputStream fi = new FileInputStream(src);

			FileOutputStream fo = new FileOutputStream(dest);

			while ((c = fi.read()) != -1) {
				fo.write((byte) c);
			}

			fi.close();
			fo.close();

			System.out.println("파일 복사 완료");
		} catch (IOException e) {
			System.out.println("파일 복사 오류");
		}
	}

}
```


이 예제는 파일의 각 바이트를 바이너리로 취급하므로,<br>
텍스트 뿐만 아니라 여러 가지 파일도 복사가 가능하다.<br>


---


### [고속 파일 복사]


하지만 위 예제들은 한 바이트씩 읽고 쓰기 때문에<br>
파일이 큰 경우 속도가 느려진다.<br>

다음과 같이 수정하면 블록 단위로 복사하기 때문에 속도가 빨라진다.<br>

이 예제는 바이트 스트림을 사용하므로,<br>
텍스트 파일뿐만 아니라 다양한 바이너리 파일도 복사가 가능하다.<br>


```java
public class BlockCopyEx {

	public static void main(String[] args) {
		File src = new File("c:\\windows\\system.ini"); // 원본 파일 경로명

		File dest = new File("c:\\Temp\\system.txt"); // 복사 파일 경로명

		try {
			FileInputStream fi = new FileInputStream(src); // 파일 입력 바이트 스트림 생성

			FileOutputStream fo = new FileOutputStream(dest); // 파일 출력 바이트 스트림 생성

			byte[] buf = new byte[1024 * 10]; // 10KB 버퍼

			int n;

			while ((n = fi.read(buf)) != -1) {
				fo.write(buf, 0, n);
			}

			fi.close();
			fo.close();

			System.out.println("파일 복사 완료");
		} catch (IOException e) {
			System.out.println("파일 복사 오류");
		}
	}

}
```






## 6. 정리


자바의 입출력 스트림은 다음 두 가지만 구분하면 된다.<br>

1. 문자 vs 바이트<br>

2. 입력 vs 출력<br>


---


### [스트림 이름으로 바로 구분하는 법]


[Reader / Writer]<br>

-> 문자 단위로 처리<br>

-> 텍스트 파일 전용 (.txt, 소스 코드 등)<br>

-> FileReader, FileWriter<br>


[InputStream / OutputStream]<br>

-> 바이트 단위로 처리<br>

-> 모든 파일 처리 가능 (텍스트, 이미지, 영상 등)<br>

-> FileInputStream, FileOutputStream<br>


---


### [파일 처리 기준으로 정리]


글자의 의미가 중요한 텍스트 파일 -> Reader / Writer<br>

파일 형식이 중요한 데이터 -> Stream 계열<br>
(이미지, mp3, zip 등)<br>


---


### [이름이 헷갈릴 때 기억할 공식]

Reader/Writer = 문자<br>
Stream = 바이트<br>


-----------------------------------------------------------------------<br>


지금까지 자바의 입출력에 대해 공부해 보았다.<br>
다음 글에서는 자바의 소켓 프로그래밍에 대해서 공부해 보겠다.<br>


---
※ 본 글은 개인 학습을 목적으로 「명품 자바 에센셜」(황기태 지음, 생능출판)을 참고하여 작성하였습니다.