---
layout: single
title: "Java Chapter 6 – 클래스와 객체"
date: 2025-10-02
categories:
  - Java
  - java_grammer
tags: [Java, 문법]
author_profile: true
read_time: true
comments: true
share: true
related: true
sidebar:
  nav: "categories_sidebar"
---


# Java의 클래스와 객체


자바는 객체 지향 언어이다.<br>
그럼 여기서 말하는 객체는 무엇일까?<br>
사전에서는 객체를 '의사나 행위가 미치는 대상' 또는 '작용의 대상이 되는 쪽'으로 정의한다.<br>
우리가 사는 세계에서 주변에서 찾아볼 수 있는 모든 것이 객체라고 할 수 있다.<br>
컴퓨터, 책, 책상, 의자... 더 나아가 사람 또한 객체이다.<br>
객체들은 자신만의 고유한 특성과 행동을 가지며, 다른 객체들에게 행동을 요구하거나<br>
정보를 주고받는 등 상호작용하며 살아간다.<br>


## 1. 자바의 객체 지향 특성


객체 지향 언어는 실세계의 객체를 프로그램 내에 표현하기 위해 클래스와 객체를 도입했다.<br>
객체 지향 언어는 다음과 같은 특성을 가진다.<br>


### 캡슐화(encapsulation)


'캡슐화'란 객체를 하나의 캡슐처럼 묶어,<br> 
외부의 직접적인 접근으로부터 내부 데이터를 보호하는 특성이다.<br>
하지만 외부와의 상호작용을 위해 필요한 일부 기능은 공개적으로 제공한다.<br>
예를 들어 TV의 전원 버튼, 채널 버튼, 음량 조절 버튼 등이 이에 해당한다.<br>


자바에서 클래스(class)는 객체의 모양을 선언한 틀이며,<br>
클래스 모양 그대로 생성된 실체(instance)가 객체이다.<br>


```java
class Animal{
    String name;
    int age;
    void eat(){...};
    void speak(){...};
}
```


자바는 위와 같이 클래스 내에 필드(field)와 메소드(method)를 모두 구현한다.<br>
(****여기서 필드(field)는 클래스 내에 속한 변수로, 객체의 상태(데이터)를 저장하고,<br>
메소드(method)는 클래스 내에 속한 함수로, 객체의 행동을 정의한다.****)<br>
그리고 이렇게 만들어진 클래스는 캡슐화를 통해 외부로부터의 직접적인 접근이 제한된다.<br>




### 상속(inheritance)


'상속'은 상위 개체의 속성이 하위 개체에게 물려져서,<br>
하위 개체가 상위 개체의 속성을 모두 가지는 개념이다.<br>


![상속 예시](/assets/images/상속%20예시.png)<br>


위 사진은 생물 분류에서 상속 예시를 도식화 한 사진이다.<br>
각 하위 개체들은 상위 개체들의 속성을 모두 포함한다.<br>


이처럼 자바의 상속 또한 자식 클래스가 부모 클래스의 속성을 물려받아,<br>
부모 클래스의 기능을 확장하는 개념이다.<br>
또 부모 클래스는 슈퍼 클래스, 자식 클래스는 서브 클래스라고 부른다.<br>


상속은 슈퍼 클래스의 필드와 메소드를 재사용함으로써 코드의 중복 작성을 방지한다.<br>
코드의 재사용으로 인해 시간과 비용을 줄일 수 있는 것이다.<br>


```java
class Animal{
    String name;
    int age;
    void eat(){...};
    void speak(){...};
}

class Human extends Animal{
    String hobby;
    String job;
    void work(){...};
    void laugh(){...};
}
```


Human 클래스는 Animal 클래스를 상속받았기 때문에<br>
Animal 클래스의 필드와 메서드를 다시 선언할 필요가 없다.<br>


```java
//Animal의 객체
String name;
int age;
------------
void eat();
void speak();


//Human의 객체
String name;
int age;
------------
void eat();
void speak();
------------
String hobby;
String job;
------------
void work();
void laugh();
```


위와 같이 객체가 형성되는 것이다.<br>




### 다형성(polymorphism)


'다형성'은 같은 이름의 메소드가 클래스 또는 객체에 따라 다르게 구성되는 것이다.<br>
예를 들어 동물의 울음소리(speak())가 고양이, 강아지, 새 등 객체마다 다르기 때문에,<br>
각 동물들의 클래스는 Animal 클래스를 상속받고, speak() 메소드는 각 동물의 특징에 맞게 다르게 구현되어야 한다.<br>


다형성은 '메소드 오버라이딩'과 '메소드 오버로딩'의 두 가지 형태로 나뉜다.<br>

**메소드 오버라이딩(Method Overriding)**<br>
●슈퍼클래스(부모 클래스) 에 이미 정의된 메서드를<br>
서브클래스(자식 클래스) 가 같은 이름, 같은 매개변수, 같은 반환 타입 으로 다시 정의한다.<br>
●부모의 기능을 자식 클래스의 특성에 맞게 재정의할 때 사용된다.<br>


```java
class Animal{
    void speak(){
        System.out.println("동물이 소리를 냅니다.");
    }
}

class Dog extends Animal{
    @Override
    void speak(){
        System.out.println("멍멍!");
    }
}
```


**메소드 오버로딩(Method Overloading)**<br>
●같은 클래스 내에서 메서드 이름은 같지만,<br>
매개변수의 개수나 타입 을 다르게 하여 여러 메서드를 정의한다.<br>
●같은 기능을 다양한 입력 형태로 처리할 수 있게 해준다.<br>


```java
class Calculator{
    int add(int a, int b){
        return a+b;
    }
    double add(double a, double b){
        return a+b;
    }
}
```


---------------------------------------------------------------------------------


객체 지향 언어(Object-Oriented Language) 는 앞서 살펴본 캡슐화, 상속, 다형성 등의 기법을 통해 유지보수성과 재사용성이 높은 소프트웨어를 제작할 수 있는 장점을 가진다.<br>






## 2. 자바 클래스


자바 클래스는 class로 선언한다. 클래스의 구성 요소를 멤버라고 부르며,<br>
멤버는 필드(멤버 변수)와 메소드(멤버 함수) 두 가지로 나뉜다.<br>
아래 사진은 클래스의 구성 예시이다.<br>


![클래스 구성 예시](/assets/images/클래스%20구성.png)<br>


### 클래스의 구성


클래스는 사진에서 볼 수 있듯 class 키워드와 클래스 이름으로 선언하고,<br>
중괄호({}) 안에 필드와 메소드를 모두 작성한다. 외부에는 절대 둘 수 없다.<br>




### 클래스 멤버




클래스 멤버는 필드(멤버 변수)와 메소드(멤버 함수)로,<br>
필드에는 객체의 상태값(데이터)를 저장하고 메소드는 객체의 행위를 구현한다.<br>
위 사진에서 필드에는 이름과 반지름 값이 저장되고, 메소드는 면적을 계산해 리턴한다.<br>




### 접근 지정자




접근 지정자는 클래스에 대한 접근 범위를 지정하는 역할을 한다.<br>
위 사진의 Circle 클래스는 접근 지정자가 public으로, 다른 클래스에서<br>
마음대로 접근 및 호출이 가능하도록 공개된다.<br>




### 객체 생성과 활용


클래스를 선언하는 방법을 알았으니 객체를 생성하고 활용하는 연습을 해보겠다.<br>


```java
public class Circle {
	String name;    //원의 이름 필드
	int radius;     //원의 반지름 필드
	
	public double getArea() {           //원의 면적을 구하는 메소드
		return 3.14 * radius * radius;
	}
	public static void main(String[] args) {
		Circle one;         //객체에 대한 레퍼런스 변수 선언
		one = new Circle(); //Circle 객체 생성
		one.name = "첫번째 원"; //이름 설정
		one.radius = 3;        //반지름 설정
		double area = one.getArea();  //면적 알아내기
		System.out.println("첫번째 원의 면적: " + area);
		
		Circle two;         //객체에 대한 레퍼런스 변수 선언
		two = new Circle(); //Circle 객체 생성
		two.name = "두번째 원"; //이름 설정
		two.radius = 7;        //반지름 설정
		area = two.getArea();  //면적 알아내기
		System.out.println("두번째 원의 면적: " + area);
	}
}

```


1. 레퍼런스 변수 선언<br>


객체를 생성하기 전, 객체를 가리킬 레퍼런스 변수(객체 이름) 선언이 필요하다.<br>
Circle one; 이 부분이다.<br>
하지만 이 선언은 객체가 생성되는 부분이 아니다.<br>


2. new 연산자로 객체 생성<br>


자바에서 객체 생성 시에는 반드시 new 연산자를 사용한다.<br>
one = new Circle(); 이 부분이다.<br>
new 연산자 객체를 생성하는 방법은 그럼 무엇일까?<br>
new 연산자는 Circle 타입 크기의 메모리를 할당받고, 메모리에 대한 주소를 리턴한다.<br>
이 주소값은 변수 one에 대입된다. 단 이 때 필드 값들은 초기화되지 않은 상태이다.<br>


참고로 다음과 같이 레퍼런스 변수 선언과 동시에 객체 생성도 가능하다.<br>

```java
Circle one = new Circle();
```


3. 객체 멤버 접근<br>


객체의 필드나 메소드에 접근하기 위해서는 점(.) 연산자를 사용한다.<br>
one.name = "첫번째 원"; , one.radius = 3; , double area = one.getArea();<br>
이 부분들이 그 예시들이다.<br>






## 3. 생성자


### 생성자의 개념과 목적


생성자는 객체 생성 시에 초기화를 위해 실행되는 메소드이다.<br>
생성자는 객체가 생성되는 순간에 자동으로 호출된다.<br>


```java
public class Circle {
	String name;
	int radius;
	
	public Circle() {
		name = "";
		radius = 1;
	}
	
	public Circle(String n, int r) {
		name = n;
		radius = r;
	}
	
	public double getArea() {
		return 3.14 * radius * radius;
	}
	
	public static void main(String[] args) {
		Circle one = new Circle();
		one.name = "첫번째 원";
		double area = one.getArea();
		System.out.println(one.name + " 의 면적: " + area);
		
		Circle two = new Circle("두번째 원", 7);
		area = two.getArea();
		System.out.println(two.name + " 의 면적: " + area);
	}
}
```


위 예시 코드는 Circle 클래스에 생성자를 추가한 코드이다.<br>
작동 방식은 다음 사진과 같다.<br>


![생성자 예시](/assets/images/생성자.png)<br>


매개 변수가 없는 생성자로 생성된 객체는 radius = 1, name = "" 상태로 생성된다.<br>
반면 매개 변수가 있는 생성자로 생성된 객체는 매개 변수로 넘겨 준 값들로 초기화 된다.<br>


생성자의 특징을 몇 가지 정리해 보자면 다음과 같다.<br>


★[생성자의 이름은 클래스의 이름과 동일하다.]<br>
  생성자는 반드시 클래스 이름과 동일하게 작성되어야 한다.<br>


★[생성자는 여러 개 작성이 가능하다.]<br>
  매개 변수의 개수와 타입만 다르다면 클래스 내에 생성자가 여러 개 존재할 수 있다.<br>


★[생성자는 객체 생성 시에 한 번만 호출된다.]<br>
  생성자는 객체를 생성할 때만 자동으로 호출되는 메소드로,<br>
  컴파일러는 new 문장이 실행될 때 적절한 생성자가 호출되도록 컴파일 한다.<br>


★[생성자에는 리턴 타입 지정이 불가하다.]<br>
  생성자에는 void, int, double 등 어떤 리턴 타입도 선언해서는 안된다.<br>


★[생성자의 목적은 객체 생성 시에 필요한 초기 작업을 위함이다.]<br>
  생성자는 객체가 생성될 때 필드 값을 설정하거나, 메모리 확보, 파일 열기 등<br>
  객체가 활동하기 전에 필요한 초기화를 하기 위한 목적을 가진다.<br>




### 기본 생성자


기본 생성자(defalut constructor)는 매개 변수, 실행 코드가 없는<br>
단순 리턴만 하는 생성자이다. 생성자가 없는 클래스는 존재할 수 없기 때문에,<br>
생성자가 하나도 작성되지 않은 클래스의 경우 컴파일러는 기본 생성자를 자동 생성한다.<br>
하지만 생성자가 하나라도 존재하는 경우, 기본 생성자의 자동 생성은 이루어지지 않는다.<br>