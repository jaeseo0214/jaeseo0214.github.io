---
layout: single
title: "Java Chapter 6 – 클래스와 객체"
date: 2025-11-06
categories:
  - Java
  - java_grammer
tags: [Java, 문법]
author_profile: true
read_time: true
comments: true
share: true
related: true
sidebar:
  nav: "categories_sidebar"
---


# Java의 클래스와 객체


자바는 객체 지향 언어이다.<br>
그럼 여기서 말하는 객체는 무엇일까?<br>
사전에서는 객체를 '의사나 행위가 미치는 대상' 또는 '작용의 대상이 되는 쪽'으로 정의한다.<br>
우리가 사는 세계에서 주변에서 찾아볼 수 있는 모든 것이 객체라고 할 수 있다.<br>
컴퓨터, 책, 책상, 의자... 더 나아가 사람 또한 객체이다.<br>
객체들은 자신만의 고유한 특성과 행동을 가지며, 다른 객체들에게 행동을 요구하거나<br>
정보를 주고받는 등 상호작용하며 살아간다.<br>


## 1. 자바의 객체 지향 특성


객체 지향 언어는 실세계의 객체를 프로그램 내에 표현하기 위해 클래스와 객체를 도입했다.<br>
객체 지향 언어는 다음과 같은 특성을 가진다.<br>


### 캡슐화(encapsulation)


'캡슐화'란 객체를 하나의 캡슐처럼 묶어,<br> 
외부의 직접적인 접근으로부터 내부 데이터를 보호하는 특성이다.<br>
하지만 외부와의 상호작용을 위해 필요한 일부 기능은 공개적으로 제공한다.<br>
예를 들어 TV의 전원 버튼, 채널 버튼, 음량 조절 버튼 등이 이에 해당한다.<br>


자바에서 클래스(class)는 객체의 모양을 선언한 틀이며,<br>
클래스 모양 그대로 생성된 실체(instance)가 객체이다.<br>


```java
class Animal{
    String name;
    int age;
    void eat(){...};
    void speak(){...};
}
```


자바는 위와 같이 클래스 내에 필드(field)와 메소드(method)를 모두 구현한다.<br>
(****여기서 필드(field)는 클래스 내에 속한 변수로, 객체의 상태(데이터)를 저장하고,<br>
메소드(method)는 클래스 내에 속한 함수로, 객체의 행동을 정의한다.****)<br>
그리고 이렇게 만들어진 클래스는 캡슐화를 통해 외부로부터의 직접적인 접근이 제한된다.<br>




### 상속(inheritance)


'상속'은 상위 개체의 속성이 하위 개체에게 물려져서,<br>
하위 개체가 상위 개체의 속성을 모두 가지는 개념이다.<br>


![상속 예시](/assets/images/상속%20예시.png)<br>


위 사진은 생물 분류에서 상속 예시를 도식화 한 사진이다.<br>
각 하위 개체들은 상위 개체들의 속성을 모두 포함한다.<br>


이처럼 자바의 상속 또한 자식 클래스가 부모 클래스의 속성을 물려받아,<br>
부모 클래스의 기능을 확장하는 개념이다.<br>
또 부모 클래스는 슈퍼 클래스, 자식 클래스는 서브 클래스라고 부른다.<br>


상속은 슈퍼 클래스의 필드와 메소드를 재사용함으로써 코드의 중복 작성을 방지한다.<br>
코드의 재사용으로 인해 시간과 비용을 줄일 수 있는 것이다.<br>


```java
class Animal{
    String name;
    int age;
    void eat(){...};
    void speak(){...};
}

class Human extends Animal{
    String hobby;
    String job;
    void work(){...};
    void laugh(){...};
}
```


Human 클래스는 Animal 클래스를 상속받았기 때문에<br>
Animal 클래스의 필드와 메서드를 다시 선언할 필요가 없다.<br>


```java
//Animal의 객체
String name;
int age;
------------
void eat();
void speak();


//Human의 객체
String name;
int age;
------------
void eat();
void speak();
------------
String hobby;
String job;
------------
void work();
void laugh();
```


위와 같이 객체가 형성되는 것이다.<br>




### 다형성(polymorphism)


'다형성'은 같은 이름의 메소드가 클래스 또는 객체에 따라 다르게 구성되는 것이다.<br>
예를 들어 동물의 울음소리(speak())가 고양이, 강아지, 새 등 객체마다 다르기 때문에,<br>
각 동물들의 클래스는 Animal 클래스를 상속받고, speak() 메소드는 각 동물의 특징에 맞게 다르게 구현되어야 한다.<br>


다형성은 '메소드 오버라이딩'과 '메소드 오버로딩'의 두 가지 형태로 나뉜다.<br>

**메소드 오버라이딩(Method Overriding)**<br>
●슈퍼클래스(부모 클래스) 에 이미 정의된 메서드를<br>
서브클래스(자식 클래스) 가 같은 이름, 같은 매개변수, 같은 반환 타입 으로 다시 정의한다.<br>
●부모의 기능을 자식 클래스의 특성에 맞게 재정의할 때 사용된다.<br>


```java
class Animal{
    void speak(){
        System.out.println("동물이 소리를 냅니다.");
    }
}

class Dog extends Animal{
    @Override
    void speak(){
        System.out.println("멍멍!");
    }
}
```


**메소드 오버로딩(Method Overloading)**<br>
●같은 클래스 내에서 메서드 이름은 같지만,<br>
매개변수의 개수나 타입 을 다르게 하여 여러 메서드를 정의한다.<br>
●같은 기능을 다양한 입력 형태로 처리할 수 있게 해준다.<br>


```java
class Calculator{
    int add(int a, int b){
        return a+b;
    }
    double add(double a, double b){
        return a+b;
    }
}
```


---------------------------------------------------------------------------------


객체 지향 언어(Object-Oriented Language) 는 앞서 살펴본 캡슐화, 상속, 다형성 등의 기법을 통해 유지보수성과 재사용성이 높은 소프트웨어를 제작할 수 있는 장점을 가진다.<br>






## 2. 자바 클래스


자바 클래스는 class로 선언한다. 클래스의 구성 요소를 멤버라고 부르며,<br>
멤버는 필드(멤버 변수)와 메소드(멤버 함수) 두 가지로 나뉜다.<br>
아래 사진은 클래스의 구성 예시이다.<br>


![클래스 구성 예시](/assets/images/클래스%20구성.png)<br>


### 클래스의 구성


클래스는 사진에서 볼 수 있듯 class 키워드와 클래스 이름으로 선언하고,<br>
중괄호({}) 안에 필드와 메소드를 모두 작성한다. 외부에는 절대 둘 수 없다.<br>




### 클래스 멤버




클래스 멤버는 필드(멤버 변수)와 메소드(멤버 함수)로,<br>
필드에는 객체의 상태값(데이터)를 저장하고 메소드는 객체의 행위를 구현한다.<br>
위 사진에서 필드에는 이름과 반지름 값이 저장되고, 메소드는 면적을 계산해 리턴한다.<br>




### 접근 지정자




접근 지정자는 클래스에 대한 접근 범위를 지정하는 역할을 한다.<br>
위 사진의 Circle 클래스는 접근 지정자가 public으로, 다른 클래스에서<br>
마음대로 접근 및 호출이 가능하도록 공개된다.<br>




### 객체 생성과 활용


클래스를 선언하는 방법을 알았으니 객체를 생성하고 활용하는 연습을 해보겠다.<br>


```java
public class Circle {
	String name;    //원의 이름 필드
	int radius;     //원의 반지름 필드
	
	public double getArea() {           //원의 면적을 구하는 메소드
		return 3.14 * radius * radius;
	}
	public static void main(String[] args) {
		Circle one;         //객체에 대한 레퍼런스 변수 선언
		one = new Circle(); //Circle 객체 생성
		one.name = "첫번째 원"; //이름 설정
		one.radius = 3;        //반지름 설정
		double area = one.getArea();  //면적 알아내기
		System.out.println("첫번째 원의 면적: " + area);
		
		Circle two;         //객체에 대한 레퍼런스 변수 선언
		two = new Circle(); //Circle 객체 생성
		two.name = "두번째 원"; //이름 설정
		two.radius = 7;        //반지름 설정
		area = two.getArea();  //면적 알아내기
		System.out.println("두번째 원의 면적: " + area);
	}
}

```


1. 레퍼런스 변수 선언<br>


객체를 생성하기 전, 객체를 가리킬 레퍼런스 변수(객체 이름) 선언이 필요하다.<br>
Circle one; 이 부분이다.<br>
하지만 이 선언은 객체가 생성되는 부분이 아니다.<br>


2. new 연산자로 객체 생성<br>


자바에서 객체 생성 시에는 반드시 new 연산자를 사용한다.<br>
one = new Circle(); 이 부분이다.<br>
new 연산자 객체를 생성하는 방법은 그럼 무엇일까?<br>
new 연산자는 Circle 타입 크기의 메모리를 할당받고, 메모리에 대한 주소를 리턴한다.<br>
이 주소값은 변수 one에 대입된다. 단 이 때 필드 값들은 초기화되지 않은 상태이다.<br>


참고로 다음과 같이 레퍼런스 변수 선언과 동시에 객체 생성도 가능하다.<br>

```java
Circle one = new Circle();
```


3. 객체 멤버 접근<br>


객체의 필드나 메소드에 접근하기 위해서는 점(.) 연산자를 사용한다.<br>
one.name = "첫번째 원"; , one.radius = 3; , double area = one.getArea();<br>
이 부분들이 그 예시들이다.<br>






## 3. 생성자


### 생성자의 개념과 목적


생성자는 객체 생성 시에 초기화를 위해 실행되는 메소드이다.<br>
생성자는 객체가 생성되는 순간에 자동으로 호출된다.<br>


```java
public class Circle {
	String name;
	int radius;
	
	public Circle() {
		name = "";
		radius = 1;
	}
	
	public Circle(String n, int r) {
		name = n;
		radius = r;
	}
	
	public double getArea() {
		return 3.14 * radius * radius;
	}
	
	public static void main(String[] args) {
		Circle one = new Circle();
		one.name = "첫번째 원";
		double area = one.getArea();
		System.out.println(one.name + " 의 면적: " + area);
		
		Circle two = new Circle("두번째 원", 7);
		area = two.getArea();
		System.out.println(two.name + " 의 면적: " + area);
	}
}
```


위 예시 코드는 Circle 클래스에 생성자를 추가한 코드이다.<br>
작동 방식은 다음 사진과 같다.<br>


![생성자 예시](/assets/images/생성자.png)<br>


매개 변수가 없는 생성자로 생성된 객체는 radius = 1, name = "" 상태로 생성된다.<br>
반면 매개 변수가 있는 생성자로 생성된 객체는 매개 변수로 넘겨 준 값들로 초기화 된다.<br>


생성자의 특징을 몇 가지 정리해 보자면 다음과 같다.<br>


★[생성자의 이름은 클래스의 이름과 동일하다.]<br>
  생성자는 반드시 클래스 이름과 동일하게 작성되어야 한다.<br>


★[생성자는 여러 개 작성이 가능하다.]<br>
  매개 변수의 개수와 타입만 다르다면 클래스 내에 생성자가 여러 개 존재할 수 있다.<br>


★[생성자는 객체 생성 시에 한 번만 호출된다.]<br>
  생성자는 객체를 생성할 때만 자동으로 호출되는 메소드로,<br>
  컴파일러는 new 문장이 실행될 때 적절한 생성자가 호출되도록 컴파일 한다.<br>


★[생성자에는 리턴 타입 지정이 불가하다.]<br>
  생성자에는 void, int, double 등 어떤 리턴 타입도 선언해서는 안된다.<br>


★[생성자의 목적은 객체 생성 시에 필요한 초기 작업을 위함이다.]<br>
  생성자는 객체가 생성될 때 필드 값을 설정하거나, 메모리 확보, 파일 열기 등<br>
  객체가 활동하기 전에 필요한 초기화를 하기 위한 목적을 가진다.<br>




### 기본 생성자


기본 생성자(defalut constructor)는 매개 변수, 실행 코드가 없는<br>
단순 리턴만 하는 생성자이다. 생성자가 없는 클래스는 존재할 수 없기 때문에,<br>
생성자가 하나도 작성되지 않은 클래스의 경우 컴파일러는 기본 생성자를 자동 생성한다.<br>
하지만 생성자가 하나라도 존재하는 경우, 기본 생성자의 자동 생성은 이루어지지 않는다.<br>






## 4. this 레퍼런스


### this


this는 객체 자신에 대한 레퍼런스로, 메소드 안에서 사용된다.<br>
컴파일러에 의해 관리되므로 단순 사용만 하면 된다.<br>


```java
public class Circle {
	int radius;
	public Circle() { this.radius = 1; }
	public CIrcle(int r) { this.radius = r; } //멤버와 매개변수
	public double getArea(){ return 3.14 * this.radius * this.radius; }
}
```


참고로 this는 현재 객체에 대한 레퍼런스이므로 객체가 있어야 this 또한 의미가 있다.<br>


### this()


this()는 클래스 내에서 생성자가 다른 생성자를 호출할 때 사용한다.<br>


```java
public class Book() {
	String title;
	String author;

	public Book() {
		this("", "");
	}

	public Book(String t) {
		this(t, "작자 미상");
	}

	public Book(String t, String a) {
		this.title = t;
		this.author = a;
	}

	public static void main(String [] args) {
		Book loveStory = new Book("춘향전");
		Book emptyBook = new Book();
	}
}
```


이 예시 프로그램에서 각 객체가 생성되는 과정을 알아보겠다.<br>
먼저 loveStory 객체를 생성할 때, 매개변수 한 개짜리(제목) 생성자를 이용했다.<br>
하지만 그 생성자는 this()로 다른 생성자를 호출하고 있기 때문에<br>
최종적으로 호출되는 생성자는 매개변수 두 개짜리(제목, 작가) 생성자가 호출되고,<br>
title = "춘향전" , author = "작자 미상" 이 되는 것이다.<br>


이런 this()를 사용할 때의 주의점이 있다.<br>

1. this()는 생성자에서만 사용된다<br>

2. this()는 반드시 같은 클래스의 다른 생성자를 호출할 때 사용된다.<br>

3. this()는 반드시 생성자의 첫 번째 문장으로 사용되어야 한다.<br>


마지막 주의사항에 대해 좀 더 설명해 보자면,<br>


```java
public Book() {
	System.out.println("생성자 호출됨.");
	this("", "");
}
```


이런 식으로 사용하면 컴파일 오류가 난다는 뜻이다.<br>
올바르게 사용하려면 아래와 같이 사용해야 한다.<br>


```java
public Book() {
	this("", "");
	System.out.println("생성자 호출됨.");
}
```






## 5. 객체 배열


다른 자료형과 마찬가지로 객체 또한 배열을 만들 수 있다.<br>
객체 배열은 객체에 대한 레퍼런스를 원소로 갖는 배열이다.<br>


객체 배열을 만들고 사용하는 방법은 아래와 같다.


```java
Circle [] c; 		//1. Circle 클래스에 대한 레퍼런스 변수 선언
c = new Circle[5];  //2. 레퍼런스 배열 5개 생성


for(int i = 0; i < c.length; i++) {
	c[i] = new Circle(i);
}					//3. 배열의 크기만큼 객체 생성

for(int i = 0; i < c.length; i++) {
	System.out.println((int)(c[i].getArea()) + " ");
}					//4. 배열의 각 원소 객체에 접근해 면적 출력
```


여기서 주의할 점은 1번 단계에서 Circle [5] c; 와 같이 크기를 지정하면 안된다.<br>
선언문은 레퍼런스의 변수를 선언할 뿐이지 배열을 생성하는 것이 아니기 때문이다.<br>






## 6. 메소드 활용과 객체 치환


자바의 메소드 형식은 아래와 같다.<br>

![메소드 예시](/assets/images/메소드%20구성.png)<br>


### 접근 지정자


자바에서 메소드는 반드시 접근 지정자와 함께 선언되어야 한다.<br>
접근 지정자는 'public'(클래스 내/외부 모두 호출 가능),<br>
'private'(클래스 멤버들만 호출 가능),<br>
'protected'(동일 패키지의 클래스들과 상속받은 서브 클래스에서 호출 가능)<br>
가 있고, 접근 지정자가 생략된 디폴트 접근 지정의 경우 동일 패키지의 모든<br>
클래스에서 호출 가능하다.<br>


### 리턴 타입


리턴 타입은 메소드가 호출자에게 리턴할 값의 타입이다.<br>
위의 getSum 함수는 int형 자료 sum을 리턴하기 때문에 리턴 타입은 int이다.<br>
만약 아무런 값을 리턴하지 않을 경우 void로 선언한다.<br>


### 인자 전달


메소드 호출 시에 인자 전달의 경우, 실인자의 값이 매개변수에 복사되어 전달된다.<br>
그렇기에 메소드 종료 시 메인 메소드에 선언된 지역 변수의 값은 변경하지 못한다.<br>


만약 메소드의 매개변수가 클래스 타입인 경우, 객체의 레퍼런스 값이 전달된다.<br>
이 경우 매개변수가 객체를 가리키게 되고, 메소드가 끝나도 변경값이 유지된다.<br>
단, 메소드 호출 시 객체가 전달되는 경우, 객체가 통째로 복사되는 것이 아니다.<br>
객체에 대한 레퍼런스만 전달된다.<br>


배열이 전달되는 경우도 객체와 동일하게 배열에 대한 레퍼런스만 전달된다.<br>


이 객체에 대한 레퍼런스, 배열에 대한 레퍼런스는<br> 
객체 또는 배열이 위치한 메모리를 가리키는 정보(일종의 주소값)라고 보면 된다.<br>


일반적인 자료형(int,double...)은 변수에 데이터값 자체가 저장되지만,<br>
배열이나 객체는 참조형이기에 데이터가 위치한 메모리를 가리키는 레퍼런스가 저장된다.<br>

```java
int a = 10;					//변수에 데이터 자체가 저장

int [] arr = new int[3];	//변수에 주소값이 저장

arr[0] = 1;					//arr의 첫번째 요소에 데이터 자체가 저장
```


위와 같이 정리할 수 있다.<br>






## 7. 메소드 오버로딩


자바에서는 다형성의 한 종류인 메소드 오버로딩이 가능하다.<br>
메소드 오버로딩은 클래스 내에 이름이 같지만 매개변수의 타입, 개수가 다른<br>
메소드를 여러 개 작성하는 것이다.<br>
주의할 점은 리턴 타입과 접근 지정자는 오버로딩과 관계가 없다.<br>






## 8. 객체 치환


Circle 이라는 객체를 3개 생성해 보자.<br>


```java
Circle c1 = new Circle(1);
Circle c2 = new Circle(2);
Circle c3;
```

여기서 만약 c3 = c2; , c1 = c2; 를 작성해 실행할 경우,<br>
c3 과 c1은 변수가 가리키는 객체 바뀜이 이루어져 c2 객체를 가리키게 된다.<br>
그렇게 되면 c1이 가리키던 객체는 아무도 가리키지 않게 되어,<br>
프로그램에서 접근할 수 없는 상태가 된다. 이 상태의 객체를 가비지(garbage)라고 한다.<br>






## 9. 객체의 소멸과 가비지 컬렉션


### 객체 소멸


자바에서는 객체를 생성하는 new 연산자는 있지만, 객체 소멸 연산자는 존재하지 않는다.<br>
자바에서는 응용프로그램에서 사용되지 않는 객체나 배열 메모리를 자바 가상 기계가<br>
알아서 회수하기 때문에, 메모리 해제를 신경쓰지 않아도 된다.<br>


### 가비지


할당받은 객체나 배열 메모리 중 더 이상 사용하지 않게 된 메모리를<br>
가비지(garbage)라고 한다.<br>
자바 플랫폼은 참조하는 레퍼런스가 하나도 없는 객체나 배열을 가비지로 본다.<br>


### 가비지 컬렉션


가비지가 많아지면 응용프로그램에 할당해 줄 수 있는 가용 메모리 양이 줄고,<br>
가용 메모리가 0이 되면 응용프로그램은 실행 불가 상태가 된다.<br>
이를 막기 위해 자바 가상 기계는 가비지를 자동으로 회수하여 가용 메모리 공간을 늘린다.<br>
이걸 가비지 컬렉션이라고 부른다.<br>


### 가비지 컬렉션 강제 수행


System 또는 Runtime 객체의 gc() 메소드를 호출하여<br>
자바 플랫폼에 가비지 컬렉션을 요청할 수 있다.<br>
하지만 호출한다고 무조건 실행되는 것이 아니다.<br>
이는 제안에 불과하고, 가비지 컬렉션은 자바 가상 기계가 전적으로 판단해 작동시킨다.<br>






## 10. 접근 지정자


자바는 관련이 있는 클래스들을 한 패키지에 묶어서 관리한다.<br>
패키지는 쉽게 말해 폴더의 개념이다.<br>
폴더 안에 관련이 있는 것들을 모아놓는 것이다.<br>


그럼 이렇게 만들어진 클래스나 클래스 안의 멤버들을 다른 곳에서도<br>
사용해도 되는지, 즉 접근 가능 여부를 선언하는 지시어가 필요한데,<br>
이 지시어가 바로 접근 지정자다.<br>


자바에서는 private, protected, public, 접근 지정자 생략(디폴트)의<br>
4가지 접근 지정자가 있다<br>


### 클래스 접근 지정


클래스 접근 지정은 public과 디폴트(접근 지정자 생략)로 나뉜다.<br>

```java
public class World{
	.......
}
```


클래스 앞에 public 지시어를 붙일 경우, 이 클래스는 패키지에 상관없이<br>
다른 어떤 클래스에서도 접근이 허용된다. 어느곳에서든 활용이 가능하다는 뜻이다.<br>


```java
class Local{
	.......
}
```


접근 지정자를 생략한 클래스는 같은 패키지 내의 클래스에서만 접근할 수 있다.<br>
클래스 자체에 접근할 수 없으면 내부 멤버에도 접근할 수 없으므로, 접근이 제한된다.<br>

주의할 점은 protected 와 private는 최상위 클래스 접근 지정에 사용할 수 없다.<br>
protected나 private를 최상위 클래스에 적용하면 외부에서 접근할 수 없어<br>
의미가 없기 때문에, 자바에서는 문법적으로 사용할 수 없다.<br>


```java
//최상위 클래스
public class A{
	private class Aa{}
	protected class Ab{}
	public class Ac{}
	class Ad{}
}
```


이렇게 최상위 클래스 내부에선 사용이 가능하지만,


```java
//최상위 클래스
protected class A{

}
```


또는


```java
//최상위 클래스
private class A{

}
```


와 같이 사용할 순 없다.<br>


### 멤버 접근 지정


멤버 접근 지정자는 private, protected, public, 접근 지정자 생략(디폴트)의<br>
4가지가 전부 사용 가능하다.


먼저 public 멤버는 어떤 패키지에서든 접근, 활용이 가능하다.


private 접근 지정자는 비공개를 의미하고, private 멤버는 같은 클래스 내의<br>
멤버들에게만 접근, 활용이 허용된다.


protected 접근 지정자는 보호된 공개를 의미하고, protected 멤버는<br>
같은 패키지 내의 모든 클래스들과 자식 클래스(상속)만이 접근, 활용이 허용된다.<br>


디폴트 멤버(접근 지정자 생략)의 경우 동일한 패키지 내의 클래스들만<br>
디폴트 멤버를 자유롭게 접근, 활용이 가능하다.<br>






## 11. static 멤버


클래스 멤버중에 static 키워드로 선언된 멤버를 static 멤버라고 부른다.<br>
static 멤버는 일반 멤버들과 다른 특성을 가진다.<br>


static 멤버는 이 멤버를 포함하는 객체가 생성되기 전에 별도의 외부 공간에<br>
존재하며, 동일한 클래스의 모든 객체가 공유한다.<br>


예를 들어,


```java
class StaticEx{
	int n;
	void g(){...}
	static int m;
	static void f(){...}
}
```


위의 클래스를 이용해 객체를 생성한다고 하자.<br>


StaticEx a = new StaticEx();<br>
StaticEx b = new StaticEx();<br>
StaticEx c = new StaticEx();<br>


이 때 static 멤버인 int m 과 void f() 는 객체가 생성되기 전,<br>
외부의 별도 공간에 이미 존재하고, 객체 a, b, c 모두 이 멤버들을 공유한다.<br>


static 멤버는 일반 멤버와 달리 객체 이름뿐만 아니라 클래스 이름으로도 사용 가능하다.<br>


```java
//클래스 이름으로 접근
StaticEx.m = 1;
StaticEx.f();
//또는
StaticEx a = new StaticEx();	//객체 생성후
//객체 이름으로 접근
a.m = 7;
a.f();
```


자바에서는 C/C++과 달리 클래스 바깥에 어떤 변수나 함수도 존재할 수 없다.<br>
그렇기 때문에 static은 전역 변수, 전역 함수와 같이 동작하게 하고자 할 때 사용된다.<br>
또는 공유 멤버를 만들고자 할 때 활용되기도 한다.<br>


단, 이렇게 만들어진 static 메소드는 2가지 제약 사항을 가진다.<br>


첫째, static 메소드는 같은 클래스의 인스턴스 멤버를 직접 접근할 수 없다.<br>
static 메소드는 객체 생성 전에 이미 존재하므로 인스턴스 메소드, 필드 사용이 불가하다.<br>
(여기서 인스턴스는 클래스로부터 만들어진 객체라는 의미)<br>


```java
class StaticMethod{
	int n;
	void f1(int x) { n = x; }	//정상
	void f2(int x) { m = x; }	//정상

	static int m;
	static void s1(int x) { n = x;}		//컴파일 오류
	static void s2(int x) { f1(3); }	//컴파일 오류
	static void s3(int x) { m = x; }	//정상
	static void s4(int x) { s3(3); }	//정상
}
```


static 메소드는 static 필드, 메소드만 직접 접근이 가능하고,<br>
non-static 메소드는 static 필드, 메소드에 접근이 가능하다.<br>


둘째, static 메소드에선 this 사용이 불가하다.<br>
static 메소드는 객체 없이도 존재하기 때문에, this를 사용할 수 없다.<br>


```java
static void f() { this.n = x; }	//오류
```


정리하자면 다음과 같다.<br>
static 멤버는 클래스에 소속된 멤버이며<br> 
인스턴스 멤버는 객체에 소속된 멤버이다.<br>
static 메소드는 객체의 존재를 전제로 하지 않기 때문에<br> 
인스턴스 멤버와 this를 직접 사용할 수 없다.<br>






## 12. final


final 키워드는 클래스, 메소드, 필드 앞에 붙어 각각 다른 용도로 사용된다<br>


### final 클래스


```java
final class FinalClass{
	.......
}

class SubClass extends FinalClass{	//컴파일 오류
	.......
}
```


final 키워드가 클래스 앞에 붙을 경우, 상속 불가를 뜻한다.<br>


### final 메소드


```java
public class SuperClass{
	protected final int finalMethod() {...}
}

class SubClass extends SuperClass{
	protected int finalMethod() {...}	//컴파일 오류
}
```


final 키워드가 메소드 앞에 붙을 경우, 오버라이딩 불가를 뜻한다.<br>


### final 필드


```java
public class FinalFieldClass{
	final int ROWS = 7;	//상수 선언
	void f(){
		int [] intArray = new int[ROWS];	//상수 활용
		ROWS = 33;							//컴파일 오류 -> 상수값 변경 불가
	}
}
```


final 키워드가 필드 앞에 붙을 경우, 한 번 초기화된 이후 값 변경이 불가능하다.<br>


만약 프로그램 전체에서 공유하는 상수를 만들고 싶다면 다음과 같이 선언하면 된다.<br>


```java
class SharedClass{
	public static final double PI = 3.14;
}
```


이러면 파이값 3.14를 모든 클래스에서 공유하며 사용할 수 있게 된다.<br>


-----------------------------------------------------------------------<br>


지금까지 자바의 클래스와 객체에 대해 공부해 보았다.<br>
다음 글에서는 자바의 상속에 대해서 공부해 보겠다.<br>


---
※ 본 글은 개인 학습을 목적으로 「명품 자바 에센셜」(황기태 지음, 생능출판)을 참고하여 작성하였습니다.